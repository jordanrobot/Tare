# F-008: Format Extensions (Composite & Known Targets)

**Status**: Planned  
**Priority**: P1 (Must)  
**Effort**: M (1.5–2 days)  
**Epic**: E-001 — Option A Hybrid Core  
**Dependencies**: F-002 (Dimension Signature Model), F-003 (Unit Normalization), F-005 (Known-Signature Naming Map), F-006 (Composite Unit Formatter), F-007 (Operators Integration)

---

## Feature Overview

This feature extends the `Format()` method to accept composite unit strings and known signature aliases as target units, enabling users to format quantities into dimensional algebra results and complex unit combinations. After this feature, users can format quantities like `q.Format("Nm")` for torque or `q.Format("lbf*in")` for US Customary torque, leveraging the dimensional algebra engine to compute correct conversions.

### User Story

**As a** Tare library user performing engineering calculations  
**I want** to format quantities using composite unit targets (e.g., "Nm", "lbf*in", "kg·m²/s²")  
**So that** I can express results in derived or composed units without manually computing intermediate conversions

### Context

F-008 is the eighth feature in the E-001 epic implementing Option A (Hybrid Core). It builds on:
- **F-002**: Dimension signature model for representing dimensional compositions
- **F-003**: Unit normalization and alias resolver for canonical unit resolution
- **F-005**: Known-signature naming map for recognized composite unit names
- **F-006**: Composite unit formatter for generating stable composite strings
- **F-007**: Operators integration that produces dimensional algebra results

This feature completes the user-facing formatting API, allowing quantities to be formatted into any dimensionally valid target unit, whether simple (existing behavior), known composite (e.g., "Nm", "Pa"), or arbitrary composite (e.g., "kg*m/s^2").

**Current Behavior** (F-007 completed):
```csharp
var force = new Quantity(100, "N");
var distance = new Quantity(2, "m");
var torque = force * distance; // Returns: Quantity(200, "Nm")
torque.Format("Nm"); // Returns: "200 Nm" (works if Nm is in catalog)
torque.Format("lbf*in"); // Throws: "Unknown unit lbf*in" (composite not supported)
```

**New Behavior** (after F-008):
```csharp
var force = new Quantity(100, "N");
var distance = new Quantity(2, "m");
var torque = force * distance; // Returns: Quantity(200, "Nm")
torque.Format("Nm"); // Returns: "200 Nm" (known signature)
torque.Format("lbf*in"); // Returns: "1771.05 lbf*in" (composite parsing + conversion)
torque.Format("kg*m^2/s^2"); // Returns: "200 kg*m^2/s^2" (explicit composite)
```

---

## Mandatory Thinking Process (DDD/.NET Guidelines)

### 1. Domain Analysis (REQUIRED)

#### Domain Concepts Involved

- **Format Target**: A unit string that specifies the desired output unit for formatting
- **Known Composite Unit**: A recognized composed unit with an entry in the signature map (e.g., "Nm", "Pa", "W")
- **Arbitrary Composite Unit**: A user-specified composite unit string that must be parsed and resolved (e.g., "lbf*in", "kg·m²/s²")
- **Composite Parsing**: The process of parsing a composite unit string into base units and dimensional signature
- **Dimensional Conversion**: Converting a quantity from its current units to a dimensionally compatible target unit
- **Format String Compatibility**: Ensuring the source and target units have compatible dimension signatures

#### Aggregate Boundaries and Consistency Requirements

- **Value Objects**: 
  - `Quantity` — Existing public readonly struct (Format method extended)
  - `DimensionSignature` — Internal signature from F-002 (consumed for validation)
  - `PreferredUnit` — Internal naming from F-005 (consumed for known units)
  - `ResolvedUnit` — Internal from F-003 (consumed for normalization)
- **Domain Services**: 
  - `ICompositeParser` — New interface for parsing composite unit strings
  - `CompositeParser` — New implementation parsing composite strings to signatures
  - `IUnitResolver` — Existing from F-003 (consumed for unit resolution)
  - `IKnownSignatureMap` — Existing from F-005 (consumed for known unit lookup)
  - `ICompositeFormatter` — Existing from F-006 (consumed for fallback formatting)
- **Consistency**: 
  - Format method validates dimensional compatibility before conversion
  - Composite parsing produces deterministic signatures matching formatter output
  - Round-trip consistency: `Format(CompositeFormatter.Format(sig))` produces equivalent values

#### Ubiquitous Language Terms

- **Format Target**, **Composite Unit**, **Known Unit**, **Arbitrary Composite**, **Parsing**, **Dimensional Compatibility**, **Conversion Factor**, **Target Signature**, **Base Unit Token**

#### Business Rules and Invariants

- **Dimensional Compatibility**: Source and target units must have matching dimension signatures
- **Parsing Determinism**: Same composite string always produces same signature
- **Conversion Accuracy**: Format uses exact factor calculations (no cumulative drift)
- **Format Priority**: Known units preferred over arbitrary composites when both exist
- **Backward Compatibility**: Existing Format behavior for simple units unchanged
- **Immutability**: Format returns new string; never mutates quantity

### 2. Architecture Review (REQUIRED)

#### Layer Responsibilities

- **Domain Layer**: 
  - Extend `Quantity.Format()` to route composite targets to parser and converter
  - Add `CompositeParser` service to parse composite strings into signatures and factors
  - Validate dimensional compatibility before conversion
  - Integrate with existing unit resolution and signature services
- **Integration Points**:
  - Calls `IUnitResolver.Resolve()` from F-003 for base unit resolution
  - Calls `IKnownSignatureMap.TryGetPreferredUnit()` from F-005 for known units
  - Calls `ICompositeFormatter.Format()` from F-006 for consistency validation
  - Maintains compatibility with existing `UnitDefinitions` parsing

#### SOLID Principles Adherence

- **SRP**: `CompositeParser` has single responsibility—parse composite strings to signatures
- **OCP**: Format method extensible via internal services without modifying signature
- **LSP**: Format contract unchanged; composite targets are additive capability
- **ISP**: CompositeParser depends only on minimal unit resolution interfaces
- **DIP**: Format depends on abstractions (`ICompositeParser`, `IUnitResolver`) not implementations

#### Domain Events

- N/A — Format is a pure string generation operation with no side effects

#### Security Implications

- No user credentials or sensitive data
- Deterministic behavior prevents timing attacks
- Input validation prevents malformed composite strings from causing exceptions
- Bounded parsing prevents denial-of-service via complex composites

### 3. Implementation Planning (REQUIRED)

#### Files to Create/Modify

| File | Type | Justification |
|------|------|---------------|
| `src/Quantity.cs` | Modified | Extend `Format()` method to handle composite targets |
| `src/Internal/Units/ICompositeParser.cs` | New | Interface for parsing composite unit strings |
| `src/Internal/Units/CompositeParser.cs` | New | Implementation parsing composites to signatures/factors |
| `tests/QuantityFormatTests.cs` | New | Comprehensive format extension tests |
| `tests/CompositeParserTests.cs` | New | Unit tests for composite parsing logic |
| `docs/CHANGELOG.md` | Modified | Document new formatting capability |

#### Test Cases (Following `MethodName_Condition_ExpectedResult()` Pattern)

**Known Composite Formatting:**
- `Format_TorqueToNewtonMeter_ReturnsCorrectValue()`
- `Format_TorqueToLbfIn_ConvertsCorrectly()`
- `Format_PressureToPascal_ReturnsCorrectValue()`
- `Format_PowerToWatt_ConvertsCorrectly()`
- `Format_EnergyToJoule_ReturnsCorrectValue()`

**Arbitrary Composite Formatting:**
- `Format_ForceToKgMPerS2_ConvertsCorrectly()`
- `Format_TorqueToLbfMultiplyIn_ParsesAndConverts()`
- `Format_VelocityToMPerS_HandlesSlashNotation()`
- `Format_AccelerationToFtPerS2_ParsesExponents()`
- `Format_AreaToM2_RecognizesSquareNotation()`

**Composite Parsing:**
- `Parse_SimpleMultiplication_ReturnsCorrectSignature()`
- `Parse_SimpleDivision_ReturnsCorrectSignature()`
- `Parse_MixedNumeratorDenominator_ParsesCorrectly()`
- `Parse_ExponentNotation_ParsesExponents()`
- `Parse_MiddleDotSeparator_RecognizesSeparator()`
- `Parse_ParenthesesGrouping_HandlesGrouping()`

**Dimensional Validation:**
- `Format_IncompatibleDimensions_ThrowsInvalidOperationException()`
- `Format_LengthToForce_ThrowsException()`
- `Format_ScalarToLength_ThrowsException()`

**Backward Compatibility:**
- `Format_SimpleUnitTarget_UnchangedBehavior()`
- `Format_AliasTarget_ResolvesAsExpected()`
- `Format_WithFormatString_PreservesFormatting()`

**Edge Cases:**
- `Format_DimensionlessToScalar_Succeeds()`
- `Format_ComplexCompositeRoundTrip_MaintainsPrecision()`
- `Format_UnknownBaseUnit_ThrowsException()`

**Format String Integration:**
- `Format_CompositeWithFormatString_AppliesFormatting()`
- `Format_KnownUnitWithFormatString_PreservesFormatting()`

#### Error Handling and Validation Strategy

- **Unknown Base Units**: Throw `ArgumentException` with unit name in message
- **Incompatible Dimensions**: Throw `InvalidOperationException` with clear description
- **Malformed Composite**: Throw `FormatException` with parsing context
- **Division by Zero**: Propagate decimal division exception naturally
- **Null/Empty Target**: Throw `ArgumentException` with parameter name
- **Parser Failures**: Wrap in clear exception with original input for debugging

#### Performance and Scalability Considerations

- **Parsing Cache**: Cache parsed composite signatures to avoid re-parsing
- **Known Unit Fast Path**: Check known signatures before parsing composite
- **Regex Optimization**: Use compiled regex for composite pattern matching
- **Allocation Minimization**: Reuse parsing structures where possible
- **Complexity Bounds**: Limit composite nesting depth to prevent pathological cases

---

## Detailed Implementation Design

### Extended Format Method Signature

```csharp
/// <summary>
/// Format the quantity using the specified unit and optional format string.
/// Supports simple units, known composite units (Nm, Pa, W), and arbitrary composites (lbf*in, kg·m²/s²).
/// </summary>
/// <param name="unit">Target unit (simple, known composite, or arbitrary composite)</param>
/// <param name="format">Optional numeric format specifier (default "G")</param>
/// <returns>String value of Quantity formatted in the specified units of measure.</returns>
/// <exception cref="ArgumentException">Thrown when unit is null, empty, or contains unknown base units</exception>
/// <exception cref="InvalidOperationException">Thrown when dimensions are incompatible</exception>
/// <exception cref="FormatException">Thrown when composite string is malformed</exception>
/// <remarks>
/// Format resolution order:
/// 1. Simple unit from catalog (existing behavior)
/// 2. Known composite unit from signature map (e.g., Nm, Pa, W)
/// 3. Arbitrary composite parsed and resolved (e.g., lbf*in, kg*m/s^2)
/// 
/// Examples:
/// - Format("m") → "10 m" (simple unit)
/// - Format("Nm") → "20 Nm" (known composite)
/// - Format("lbf*in") → "177.1 lbf*in" (arbitrary composite)
/// - Format("kg·m²/s²", "F2") → "200.00 kg·m²/s²" (arbitrary with formatting)
/// </remarks>
public string Format(string unit, string format = "G")
{
    ArgumentNullException.ThrowIfNull(unit);
    if (string.IsNullOrWhiteSpace(unit))
    {
        throw new ArgumentException("Unit string cannot be empty or whitespace.", nameof(unit));
    }

    // Fast path: try simple unit from catalog first
    if (UnitDefinitions.IsValidUnit(unit))
    {
        // Existing simple unit behavior (unchanged)
        var targetUnit = UnitDefinitions.Parse(unit);
        var thisFactor = Factor;
        var targetFactor = targetUnit.Factor;
        return ((thisFactor * Value) / targetFactor).ToString(format) + " " + unit;
    }

    // Try parsing as composite unit
    var parser = CompositeParser.Instance;
    if (!parser.TryParse(unit, out var targetSignature, out var targetFactor))
    {
        throw new ArgumentException($"Unknown or malformed unit: {unit}", nameof(unit));
    }

    // Validate dimensional compatibility
    var resolver = UnitResolver.Instance;
    var sourceResolved = resolver.Resolve(Unit);
    
    if (!sourceResolved.Signature.Equals(targetSignature))
    {
        throw new InvalidOperationException(
            $"Cannot format {Unit} (dimension: {sourceResolved.Signature}) as {unit} " +
            $"(dimension: {targetSignature}): incompatible dimensions.");
    }

    // Convert value from source to target units
    // sourceValue * sourceFactor = base units
    // baseUnits / targetFactor = target units
    var baseValue = Value * Factor;
    var targetValue = baseValue / targetFactor;

    return targetValue.ToString(format) + " " + unit;
}
```

### CompositeParser Interface

```csharp
namespace Tare.Internal.Units;

/// <summary>
/// Service interface for parsing composite unit strings into dimension signatures and factors.
/// </summary>
internal interface ICompositeParser
{
    /// <summary>
    /// Parses a composite unit string into its dimension signature and conversion factor.
    /// </summary>
    /// <param name="compositeUnit">The composite unit string (e.g., "Nm", "lbf*in", "kg·m²/s²")</param>
    /// <param name="signature">Output dimension signature</param>
    /// <param name="factor">Output conversion factor to base units</param>
    /// <returns>True if parsing succeeded; false otherwise</returns>
    /// <remarks>
    /// Supports:
    /// - Multiplication: "N*m", "N·m", "lbf*in"
    /// - Division: "kg/m", "m/s", "J/s"
    /// - Exponents: "m^2", "s^-2", "in^3"
    /// - Parentheses: "(kg*m)/s^2"
    /// - Unicode: "m²", "s⁻²" (future)
    /// </remarks>
    bool TryParse(string compositeUnit, out DimensionSignature signature, out decimal factor);
    
    /// <summary>
    /// Validates if a string can be parsed as a composite unit.
    /// </summary>
    /// <param name="compositeUnit">The composite unit string to validate</param>
    /// <returns>True if the string is a valid composite unit; false otherwise</returns>
    bool IsValidComposite(string compositeUnit);
}
```

### CompositeParser Implementation

```csharp
using System;
using System.Collections.Generic;
using System.Text.RegularExpressions;

namespace Tare.Internal.Units;

/// <summary>
/// Parses composite unit strings into dimension signatures and conversion factors.
/// </summary>
/// <remarks>
/// This sealed class implements deterministic parsing for composite unit expressions.
/// Supports multiplication (*,·), division (/), exponents (^n), and parentheses grouping.
/// </remarks>
internal sealed class CompositeParser : ICompositeParser
{
    /// <summary>
    /// Singleton instance for efficient reuse.
    /// </summary>
    public static readonly CompositeParser Instance = new CompositeParser();
    
    // Regex patterns for composite parsing
    private static readonly Regex UnitTokenPattern = new Regex(
        @"([a-zA-Z]+)(?:\^([\-\+]?\d+))?",
        RegexOptions.Compiled);
    
    private static readonly Regex CompositePattern = new Regex(
        @"^[\w\*·\/\^\(\)\s\-\+]+$",
        RegexOptions.Compiled);
    
    private readonly IUnitResolver _resolver;
    
    private CompositeParser()
    {
        _resolver = UnitResolver.Instance;
    }
    
    /// <inheritdoc/>
    public bool TryParse(string compositeUnit, out DimensionSignature signature, out decimal factor)
    {
        signature = DimensionSignature.Dimensionless;
        factor = 1m;
        
        if (string.IsNullOrWhiteSpace(compositeUnit))
        {
            return false;
        }
        
        // Quick validation
        if (!CompositePattern.IsMatch(compositeUnit))
        {
            return false;
        }
        
        try
        {
            // Split by division first to separate numerator and denominator
            var parts = compositeUnit.Split('/');
            if (parts.Length > 2)
            {
                // Complex nested division not supported in MVP
                return false;
            }
            
            // Parse numerator
            var numeratorSig = DimensionSignature.Dimensionless;
            var numeratorFactor = 1m;
            if (!ParseProduct(parts[0], ref numeratorSig, ref numeratorFactor))
            {
                return false;
            }
            
            // Parse denominator if present
            if (parts.Length == 2)
            {
                var denominatorSig = DimensionSignature.Dimensionless;
                var denominatorFactor = 1m;
                if (!ParseProduct(parts[1], ref denominatorSig, ref denominatorFactor))
                {
                    return false;
                }
                
                // Subtract denominator signature (division)
                signature = numeratorSig.Subtract(denominatorSig);
                factor = numeratorFactor / denominatorFactor;
            }
            else
            {
                signature = numeratorSig;
                factor = numeratorFactor;
            }
            
            return true;
        }
        catch
        {
            // Any parsing error returns false
            return false;
        }
    }
    
    /// <inheritdoc/>
    public bool IsValidComposite(string compositeUnit)
    {
        return TryParse(compositeUnit, out _, out _);
    }
    
    /// <summary>
    /// Parses a product expression (units separated by * or ·).
    /// </summary>
    private bool ParseProduct(string expression, ref DimensionSignature signature, ref decimal factor)
    {
        if (string.IsNullOrWhiteSpace(expression))
        {
            return false;
        }
        
        // Split by multiplication operators
        var tokens = expression.Split(new[] { '*', '·' }, StringSplitOptions.RemoveEmptyEntries);
        
        foreach (var token in tokens)
        {
            if (!ParseUnitToken(token.Trim(), ref signature, ref factor))
            {
                return false;
            }
        }
        
        return true;
    }
    
    /// <summary>
    /// Parses a single unit token with optional exponent (e.g., "m", "kg^2", "s^-1").
    /// </summary>
    private bool ParseUnitToken(string token, ref DimensionSignature signature, ref decimal factor)
    {
        var match = UnitTokenPattern.Match(token);
        if (!match.Success)
        {
            return false;
        }
        
        var unitName = match.Groups[1].Value;
        var exponentStr = match.Groups[2].Value;
        var exponent = string.IsNullOrEmpty(exponentStr) ? 1 : int.Parse(exponentStr);
        
        // Resolve base unit
        if (!_resolver.TryResolve(unitName, out var resolved))
        {
            return false;
        }
        
        // Apply exponent to signature and factor
        for (int i = 0; i < Math.Abs(exponent); i++)
        {
            if (exponent > 0)
            {
                signature = signature.Add(resolved.Signature);
                factor *= resolved.Factor;
            }
            else
            {
                signature = signature.Subtract(resolved.Signature);
                factor /= resolved.Factor;
            }
        }
        
        return true;
    }
}
```

**Design Notes**:
- **Parsing Strategy**: Split by division first, then multiply within numerator/denominator
- **Exponent Handling**: Apply signature add/subtract operations repeatedly for exponents
- **Factor Calculation**: Multiply/divide factors in parallel with signature operations
- **Error Handling**: Return false for any parsing failure; no exceptions in TryParse
- **Limitations**: MVP supports single-level division (no nested fractions or parentheses)

---

## Composite Syntax Support

### Supported Notation

| Notation | Example | Description |
|----------|---------|-------------|
| Multiplication (asterisk) | `N*m`, `lbf*in` | Multiply two units |
| Multiplication (middle dot) | `N·m`, `kg·m` | Unicode multiplication separator |
| Division (slash) | `m/s`, `kg/m^3` | Divide units |
| Exponent (caret) | `m^2`, `s^-2`, `in^3` | Raise unit to power |
| Implicit exponent 1 | `N*m` (not `N^1*m^1`) | Exponent 1 is implicit |

### Parsing Examples

**Basic Multiplication:**
- `N*m` → Force · Length signature, factor = N_factor * m_factor
- `lbf*in` → Force · Length signature, factor = lbf_factor * in_factor

**Basic Division:**
- `m/s` → Length / Time signature, factor = m_factor / s_factor
- `kg/m^3` → Mass / Length³ signature, factor = kg_factor / (m_factor³)

**Exponents:**
- `m^2` → Length² signature, factor = m_factor²
- `s^-2` → 1/Time² signature, factor = 1/(s_factor²)
- `kg*m^2/s^2` → Energy signature, factor = kg_factor * m_factor² / s_factor²

**Complex Composites:**
- `kg*m^2/s^2` → Energy (same as Joule signature)
- `lbf*in^3/s^2` → Custom composite for specific engineering calculation

---

## Specific Tasks

### Phase 1: Composite Parser Implementation (Day 1, 3-4 hours)

- [ ] Create `ICompositeParser` interface
  - [ ] Define `TryParse` method signature
  - [ ] Define `IsValidComposite` method signature
  - [ ] Add comprehensive XML documentation
- [ ] Create `CompositeParser` implementation
  - [ ] Implement singleton pattern
  - [ ] Define regex patterns for unit tokens and validation
  - [ ] Implement `TryParse` method
    - [ ] Split by division operator
    - [ ] Parse numerator product
    - [ ] Parse denominator product (if present)
    - [ ] Compute combined signature and factor
  - [ ] Implement `ParseProduct` helper
    - [ ] Split by multiplication operators
    - [ ] Parse each token with exponents
  - [ ] Implement `ParseUnitToken` helper
    - [ ] Extract unit name and exponent
    - [ ] Resolve unit via `UnitResolver`
    - [ ] Apply exponent to signature and factor
  - [ ] Implement `IsValidComposite` method
  - [ ] Add comprehensive XML documentation
- [ ] Code review for correctness
  - [ ] Verify parsing logic handles all supported notations
  - [ ] Confirm signature and factor calculations correct
  - [ ] Validate error handling (return false, no exceptions)

### Phase 2: Format Method Extension (Day 1, 2-3 hours)

- [ ] Modify `Quantity.Format()` method
  - [ ] Add input validation (null, empty checks)
  - [ ] Preserve existing simple unit fast path
  - [ ] Add composite parsing path
    - [ ] Call `CompositeParser.TryParse`
    - [ ] Handle parsing failure with clear exception
  - [ ] Add dimensional compatibility validation
    - [ ] Resolve source unit signature
    - [ ] Compare source and target signatures
    - [ ] Throw clear exception for incompatible dimensions
  - [ ] Implement conversion calculation
    - [ ] Convert to base units
    - [ ] Convert to target units
    - [ ] Apply format string to decimal value
  - [ ] Update XML documentation
    - [ ] Document composite support
    - [ ] Add examples for different notation types
    - [ ] Document exception conditions
- [ ] Run existing format tests
  - [ ] Verify all existing tests still pass
  - [ ] Confirm simple unit formatting unchanged

### Phase 3: Comprehensive Testing (Day 2, 3-4 hours)

- [ ] Create `CompositeParserTests.cs`
  - [ ] Test basic multiplication parsing
  - [ ] Test basic division parsing
  - [ ] Test exponent parsing (positive, negative, >1)
  - [ ] Test middle dot separator
  - [ ] Test complex composite expressions
  - [ ] Test invalid input (returns false)
  - [ ] Test signature correctness for all cases
  - [ ] Test factor calculation correctness
- [ ] Create `QuantityFormatTests.cs` (or extend existing)
  - [ ] Test known composite formatting (Nm, Pa, W, J)
  - [ ] Test arbitrary composite formatting (lbf*in, kg*m/s^2)
  - [ ] Test dimensional compatibility validation
  - [ ] Test incompatible dimensions throw exception
  - [ ] Test format string integration with composites
  - [ ] Test backward compatibility with simple units
  - [ ] Test mixed SI and US Customary composites
  - [ ] Test round-trip consistency (format → parse → format)
  - [ ] Test edge cases (dimensionless, complex exponents)
  - [ ] Test error messages clarity
- [ ] Add integration tests
  - [ ] Test operator result formatting
    - [ ] Multiply force * distance → format as Nm and lbf*in
    - [ ] Divide energy / time → format as W and various composites
  - [ ] Test chained operations and formatting
  - [ ] Test cross-unit-system scenarios

### Phase 4: Documentation and Validation (Day 2, 1-2 hours)

- [ ] Update XML documentation
  - [ ] Format method reflects composite support
  - [ ] Examples show composite formatting
  - [ ] Remarks explain resolution order
- [ ] Update CHANGELOG.md
  - [ ] Document new composite formatting capability
  - [ ] Provide migration examples
  - [ ] Note backward compatibility preservation
- [ ] Create usage examples
  - [ ] Simple composite formatting
  - [ ] Complex engineering calculations
  - [ ] Mixed unit system scenarios
- [ ] Code review
  - [ ] SOLID principles adherence
  - [ ] Error handling clarity
  - [ ] Performance considerations
  - [ ] Naming consistency
- [ ] Integration validation
  - [ ] Test with F-006 formatter output
  - [ ] Test with F-007 operator results
  - [ ] Verify round-trip consistency

---

## Acceptance Criteria

### Functional Requirements

✅ **AC-1**: Format accepts known composite units (Nm, Pa, W, J) and converts correctly  
✅ **AC-2**: Format accepts arbitrary composites (lbf*in, kg*m/s^2) and converts correctly  
✅ **AC-3**: Format validates dimensional compatibility and throws clear exception for mismatches  
✅ **AC-4**: CompositeParser handles multiplication (*,·), division (/), and exponents (^n)  
✅ **AC-5**: Format calculation maintains precision (uses decimal factors)  
✅ **AC-6**: Format string parameter works with composite targets  
✅ **AC-7**: Simple unit formatting behavior unchanged (backward compatibility)  
✅ **AC-8**: Mixed SI and US Customary composites supported  
✅ **AC-9**: Dimensionless quantities format correctly  
✅ **AC-10**: Round-trip consistency maintained (format → parse → format)

### Quality Requirements

✅ **AC-11**: All tests follow `MethodName_Condition_ExpectedResult()` naming convention  
✅ **AC-12**: Test coverage ≥85% for CompositeParser and Format extension  
✅ **AC-13**: No public API breaking changes (Format signature unchanged)  
✅ **AC-14**: No external dependencies added  
✅ **AC-15**: Builds successfully on both `netstandard2.0` and `net7.0` TFMs  
✅ **AC-16**: No compiler warnings related to new code  
✅ **AC-17**: XML documentation updated for all modified/new members

### Non-Functional Requirements

✅ **AC-18**: Parsing performance acceptable (<1ms for typical composites)  
✅ **AC-19**: Error messages clear and actionable  
✅ **AC-20**: Deterministic parsing (same input → same output)  
✅ **AC-21**: Thread-safe (stateless parser, pure functions)  
✅ **AC-22**: CHANGELOG.md updated with capability and examples  
✅ **AC-23**: Format method validates input (null, empty checks)

### Integration Requirements

✅ **AC-24**: Integrates with `IUnitResolver` from F-003  
✅ **AC-25**: Compatible with `DimensionSignature` from F-002  
✅ **AC-26**: Compatible with `KnownSignatureMap` from F-005  
✅ **AC-27**: Parses `CompositeFormatter` output correctly (round-trip)  
✅ **AC-28**: Works with F-007 operator results seamlessly

---

## Test Plan

### Test Organization

**Test Files**:
- `tests/CompositeParserTests.cs` — Parser unit tests
- `tests/QuantityFormatTests.cs` — Format method extension tests (new file or extend existing)
- `tests/QuantityFormatIntegrationTests.cs` — End-to-end formatting scenarios

**Test Framework**: NUnit (consistent with existing test structure)  
**Test Categories**: 
- Unit tests for parser logic
- Unit tests for format method
- Integration tests for operator + format workflows

### Test Structure Template

```csharp
[TestFixture]
public class CompositeParserTests
{
    [Test]
    public void TryParse_SimpleMultiplication_ReturnsCorrectSignature()
    {
        // Arrange
        var parser = CompositeParser.Instance;
        var composite = "N*m";
        
        // Act
        var success = parser.TryParse(composite, out var signature, out var factor);
        
        // Assert
        Assert.That(success, Is.True);
        Assert.That(signature, Is.EqualTo(DimensionSignature.TorqueSignature));
        Assert.That(factor, Is.GreaterThan(0));
    }
}

[TestFixture]
public class QuantityFormatTests
{
    [Test]
    public void Format_TorqueToNewtonMeter_ReturnsCorrectValue()
    {
        // Arrange
        var torque = new Quantity(200, "Nm");
        
        // Act
        var result = torque.Format("Nm");
        
        // Assert
        Assert.That(result, Is.EqualTo("200 Nm"));
    }
    
    [Test]
    public void Format_TorqueToLbfIn_ConvertsCorrectly()
    {
        // Arrange
        var torque = new Quantity(200, "Nm");
        
        // Act
        var result = torque.Format("lbf*in");
        
        // Assert
        // Expected: 200 Nm ≈ 1770.88 lbf*in
        Assert.That(result, Does.Contain("1770"));
    }
    
    [Test]
    public void Format_IncompatibleDimensions_ThrowsInvalidOperationException()
    {
        // Arrange
        var length = new Quantity(10, "m");
        
        // Act & Assert
        Assert.Throws<InvalidOperationException>(() => length.Format("N*m"));
    }
}
```

### Test Coverage Matrix

| Category | Test Count | Focus Areas |
|----------|------------|-------------|
| Parser - Basic Operations | 8 | Multiplication, division, exponents |
| Parser - Notation Variants | 4 | Asterisk, middle dot, slash, caret |
| Parser - Complex Expressions | 6 | Multiple terms, mixed operations |
| Parser - Error Handling | 4 | Invalid input, unknown units, malformed |
| Format - Known Composites | 6 | Nm, Pa, W, J conversions |
| Format - Arbitrary Composites | 8 | lbf*in, kg*m/s^2, custom units |
| Format - Validation | 5 | Dimensional compatibility, error messages |
| Format - Backward Compatibility | 4 | Simple units unchanged, aliases work |
| Format - Integration | 6 | Operator results, round-trip, mixed systems |
| **Total** | **51** | **Comprehensive coverage** |

---

## Dependencies

### Upstream Dependencies (Required)

- **F-002**: `DimensionSignature` model with add/subtract operations
  - Provides signature structure for dimensional validation
- **F-003**: `IUnitResolver` for base unit resolution
  - Enables resolving unit names to signatures and factors
- **F-005**: `IKnownSignatureMap` for known composite lookup
  - Provides preferred names for common composite signatures
- **F-006**: `ICompositeFormatter` for consistency validation
  - Generates composite strings that parser should handle
- **F-007**: Operators integration producing dimensional results
  - Creates quantities with composite units that need formatting

**Critical**: All upstream features must be complete, tested, and stable before starting F-008.

### Downstream Consumers (Will Benefit From This)

- **F-009**: Optional Composite Construction
  - Will leverage composite parser for `Quantity(10, "lbf*in")` construction
- **F-012**: API Helpers
  - May add convenience methods using composite formatting
- **End Users**: All users performing engineering calculations with complex units

---

## Risks and Mitigations

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Parsing ambiguity | Medium | Medium | Clear precedence rules; limit complexity in MVP |
| Performance regression | Low | Medium | Cache parsed composites; benchmark hot paths |
| Breaking existing code | Low | High | Comprehensive backward compatibility tests |
| User confusion on syntax | Medium | Low | Clear documentation; examples; helpful error messages |
| Round-trip inconsistency | Medium | Medium | Validate parser matches formatter output; add tests |

---

## Integration Examples

### Known Composite Formatting

```csharp
// Torque example
var force = new Quantity(100, "N");
var distance = new Quantity(2, "m");
var torque = force * distance; // Quantity(200, "Nm")

torque.Format("Nm");        // "200 Nm"
torque.Format("lbf*in");    // "1770.88 lbf*in"
torque.Format("lbf*in", "F2"); // "1770.88 lbf*in"

// Power example
var energy = new Quantity(1000, "J");
var time = new Quantity(10, "s");
var power = energy / time; // Quantity(100, "W")

power.Format("W");         // "100 W"
power.Format("kg*m^2/s^3"); // "100 kg*m^2/s^3"
```

### Arbitrary Composite Formatting

```csharp
// Engineering calculation
var pressure = new Quantity(101325, "Pa");

pressure.Format("Pa");              // "101325 Pa"
pressure.Format("N/m^2");           // "101325 N/m^2"
pressure.Format("kg/m*s^2");        // "101325 kg/m*s^2"
pressure.Format("lbf/in^2", "F2"); // "14.70 lbf/in^2"

// Custom composite
var customUnit = "lbf*in^3/s^2";
var result = torque.Format(customUnit); // Parses and converts
```

### Mixed Unit Systems

```csharp
// SI to US Customary
var siTorque = new Quantity(200, "Nm");
var usResult = siTorque.Format("lbf*in"); // "1770.88 lbf*in"

// US Customary to SI
var usTorque = new Quantity(1200, "lbf*in");
var siResult = usTorque.Format("N*m"); // "135.59 N*m"
```

### Round-Trip Consistency

```csharp
// Operator produces composite
var force = new Quantity(10, "N");
var length = new Quantity(5, "m");
var torque = force * length; // Quantity(50, "Nm")

// Format to arbitrary composite
var formatted = torque.Format("kg*m^2/s^2"); // "50 kg*m^2/s^2"

// Parse and format again
var parsed = Quantity.Parse(formatted);
var reformatted = parsed.Format("Nm"); // "50 Nm"

// Round-trip maintains value (within precision)
Assert.That(reformatted, Is.EqualTo("50 Nm"));
```

---

## Out of Scope

The following are explicitly NOT part of F-008:

❌ **Parentheses Grouping**: Complex nested expressions like `(kg*m)/(s^2)` (deferred to future)  
❌ **Unicode Superscripts**: Parsing "m²" instead of "m^2" (deferred to future)  
❌ **Composite Construction**: Using composites in `Quantity` constructor (handled by F-009)  
❌ **Unit System Preferences**: Configuring preferred composite styles (handled by F-005 extensions)  
❌ **Validation Diagnostics**: Detailed parsing error messages with position (MVP uses simple messages)  
❌ **Format Current Unit**: Overloads to format without specifying unit (handled by F-016)  
❌ **IFormattable Implementation**: Full .NET formatting interface support (handled by F-015)  
❌ **Localized Separators**: Culture-specific composite separators (deferred to localization feature)

---

## Quality Checklist

### Domain Design Validation

- [ ] I have verified that CompositeParser correctly parses composite strings to signatures
- [ ] I have confirmed consistent terminology (composite, target, parsing, compatibility)
- [ ] I have verified SOLID principles adherence (SRP, DIP for parser)
- [ ] I have validated dimensional compatibility checking is correct
- [ ] I have ensured immutability and value semantics preserved

### Implementation Quality Validation

- [ ] I have written comprehensive tests following `MethodName_Condition_ExpectedResult()` naming
- [ ] I have achieved ≥85% code coverage for CompositeParser and Format extensions
- [ ] I have validated all existing format tests still pass
- [ ] I have created backward compatibility test suite
- [ ] I have documented all APIs with XML comments and examples

### Precision & Correctness Validation

- [ ] I have validated parsing produces correct signatures for all notation types
- [ ] I have tested factor calculations maintain precision
- [ ] I have verified dimensional compatibility validation works correctly
- [ ] I have tested round-trip consistency (format → parse → format)
- [ ] I have validated composite strings match formatter output

### Integration Readiness Validation

- [ ] I have verified integration with F-003 (UnitResolver)
- [ ] I have verified integration with F-005 (KnownSignatureMap)
- [ ] I have verified integration with F-006 (CompositeFormatter)
- [ ] I have verified integration with F-007 (operator results)
- [ ] I have updated CHANGELOG with usage examples

---

## Success Metrics

1. **Functionality**: All acceptance criteria met and validated
2. **Test Coverage**: ≥85% coverage for CompositeParser and Format extensions
3. **Backward Compatibility**: 100% of existing format tests pass
4. **Performance**: Composite parsing completes in <1ms for typical expressions
5. **Quality**: Zero regressions in existing test suite
6. **Integration**: Round-trip consistency validated with F-006 formatter

---

## Timeline

**Total Estimated Effort**: 1.5 - 2 days

- **Day 1 Morning**: Composite parser implementation (Phase 1) - 3-4 hours
- **Day 1 Afternoon**: Format method extension (Phase 2) - 2-3 hours
- **Day 2 Morning**: Comprehensive testing (Phase 3) - 3-4 hours
- **Day 2 Afternoon**: Documentation and validation (Phase 4) - 1-2 hours

**Note**: Timeline assumes F-002 through F-007 are complete, tested, and stable.

---

## References

### Internal References

- **E-001**: Epic — Option A Hybrid Core
- **F-002**: Dimension Signature Model (dependency)
- **F-003**: Unit Normalization and Alias Resolver (dependency)
- **F-005**: Known-Signature Naming Map (dependency)
- **F-006**: Composite Unit Formatter (dependency)
- **F-007**: Operators Integration (dependency)
- **F-009**: Optional Composite Construction (consumer)
- **F-012**: API Helpers (consumer)

### External References

- **UCUM (Unified Code for Units of Measure)**: https://ucum.org/ (reference for composite syntax)
- **SI Derived Units**: https://www.nist.gov/pml/owm/metric-si/si-derived-units
- **Dimensional Analysis (Wikipedia)**: https://en.wikipedia.org/wiki/Dimensional_analysis

---

## Open Questions

### Resolved Decisions

1. **Q**: Should we support parentheses grouping in MVP?  
   **A**: No, defer to future iteration. Split by `/` first, then by `*` is sufficient for MVP.

2. **Q**: Should we support Unicode superscripts (m² instead of m^2)?  
   **A**: No, defer to future iteration. Caret notation is universal and sufficient for MVP.

3. **Q**: Should Format validate against known signatures first?  
   **A**: Yes, check simple units, then known composites, then arbitrary composites (priority order).

4. **Q**: How to handle ambiguous parsing (e.g., "Nm" vs "N*m")?  
   **A**: Simple unit names take priority. "Nm" resolves as known unit if in catalog, else parses as composite.

### Open Questions for Review

1. **Q**: Should we provide hints for common parsing errors?  
   **Open**: MVP uses simple error messages. Enhanced diagnostics deferred to future iteration.

2. **Q**: Should we cache parsed composite results?  
   **Open**: Not in MVP. Profile performance first, then add caching in F-010 if needed.

3. **Q**: Should we validate factor calculation accuracy?  
   **Open**: Decimal precision should suffice. If issues arise, revisit in precision feature.

---

## Notes

- Format method remains the primary user-facing API for composite formatting
- Internal parsing keeps implementation details hidden from users
- Backward compatibility is paramount; all existing behaviors preserved
- Round-trip consistency ensures parser and formatter are aligned
- This feature completes the format capability for dimensional algebra in E-001

---

## Revision History

| Version | Date | Author | Changes |
|---------|------|--------|---------|
| 1.0 | 2025-11-09 | Copilot Agent | Initial planning document created per user request |

---

**Ready for Review** ✅  
This planning document defines F-008 (Format Extensions) implementation strategy, following the structure and standards established in F-001 through F-007 planning documents. The feature extends the Format method to support composite unit targets, enabling full dimensional algebra formatting while preserving backward compatibility.
