# F-004: Dimensional Math Engine

**Status**: Planned  
**Priority**: P1 (Must)  
**Effort**: M (1–2 days)  
**Epic**: E-001 — Option A Hybrid Core  
**Dependencies**: F-002 (Dimension Signature Model), F-003 (Unit Normalization and Alias Resolver)

---

## Feature Overview

This feature delivers the dimensional math engine for Tare's dimensional algebra capabilities. The engine combines dimension signatures and conversion factors to enable multiplication and division operations between `Quantity` instances with different units, producing dimensionally correct results.

### User Story

**As a** Tare library user performing engineering calculations  
**I want** to multiply and divide quantities with different units (e.g., `Quantity("36 in") * Quantity("2 ft")`)  
**So that** I can perform dimensional analysis and obtain results with proper unit combinations and cancellation

### Context

F-004 is the fourth feature in the E-001 epic implementing Option A (Hybrid Core). It builds on:
- **F-002**: Dimension signature model for representing dimensional compositions
- **F-003**: Unit normalization and alias resolution pipeline

The dimensional math engine is the core computational component that:
- Takes two normalized quantities with their dimension signatures and base factors
- Combines signatures through addition/subtraction of exponents
- Multiplies/divides the base values and factors
- Returns the resulting value, signature, and factor for further processing

This engine will be consumed by F-007 (Operators Integration) to wire the public `Quantity` operators.

---

## Mandatory Thinking Process (DDD/.NET Guidelines)

### 1. Analysis

#### Applicable Patterns
- **DDD Domain Service**: `IDimensionalMath` / `DimensionalMath` is a stateless domain service that encapsulates the core dimensional algebra rules
- **Value Objects**: Consumes `DimensionSignature`, `NormalizedUnit` value objects; produces value-based results
- **SOLID Principles**:
  - **SRP**: Engine focuses solely on dimensional computation; normalization and formatting handled elsewhere
  - **OCP**: New dimension combinations handled through signature composition without modifying engine
  - **DIP**: Public API depends on `IDimensionalMath` abstraction, not concrete implementation

#### Layers Affected
- **Domain**: Internal domain service for dimensional algebra
- **Application/Infrastructure**: Not directly affected; engine consumed by `Quantity` operators (wired in F-007)

#### Ubiquitous Language
- **Dimensional Algebra**: Mathematical operations on dimensioned quantities
- **Signature Combination**: Adding/subtracting exponents when multiplying/dividing quantities
- **Base Factor**: Conversion factor from a unit to its dimension's base unit
- **Resultant Signature**: The dimensional composition after an operation
- **Dimensional Cancellation**: When multiplication/division produces a dimensionless (scalar) result

#### Security & Compliance
- No user input processed directly by engine
- Deterministic operations with no side effects
- Precision maintained using `decimal` arithmetic per S-005 findings

### 2. Review Against Guidelines

#### Aggregate Boundaries
- Engine is a stateless service; no aggregates involved
- Operates on value objects (`DimensionSignature`, `NormalizedUnit`)
- No persistence or state management required

#### Single Responsibility
- Engine has one responsibility: combine dimensional signatures and factors
- Does NOT handle: parsing, normalization, formatting, operator delegation
- Clear separation from other concerns

#### Domain Rules Encapsulated
- Dimensional algebra rules (exponent addition/subtraction) encapsulated in engine methods
- Factor multiplication/division handled according to dimensional analysis principles
- Result identification (scalar vs. dimensioned) based on signature

#### Test Naming
- Follow `MethodName_Condition_ExpectedResult()` pattern
- Examples:
  - `Multiply_LengthByLength_ReturnsArea()`
  - `Divide_LengthByLength_ReturnsScalar()`
  - `Multiply_ForceByLength_ReturnsTorque()`

#### Ubiquitous Language Consistency
- Method names reflect domain operations (`Multiply`, `Divide`)
- Parameter names use domain terminology
- Comments reference dimensional analysis concepts

### 3. Implementation Planning

#### Entities/Value Objects Created/Modified
- **New**: `IDimensionalMath` (internal interface)
- **New**: `DimensionalMath` (internal sealed class implementing the interface)
- **New**: `DimensionalResult` (internal readonly struct for operation results)
- **Consumed**: `DimensionSignature` (from F-002)
- **Consumed**: `NormalizedUnit` (from F-003)

#### Domain Service Interface
```csharp
internal interface IDimensionalMath
{
    DimensionalResult Multiply(NormalizedUnit left, NormalizedUnit right, decimal leftValue, decimal rightValue);
    DimensionalResult Divide(NormalizedUnit numerator, NormalizedUnit denominator, decimal numeratorValue, decimal denominatorValue);
}
```

#### Result Structure
```csharp
internal readonly struct DimensionalResult
{
    public decimal Value { get; }
    public DimensionSignature Signature { get; }
    public decimal Factor { get; }  // Combined factor to base units
    
    // Constructor and helper properties
}
```

#### Tests Required
- Multiplication operations:
  - Length × Length → Area
  - Force × Length → Torque (Energy)
  - Scalar × Dimensioned → Dimensioned
  - Dimensioned × Scalar → Dimensioned
- Division operations:
  - Area ÷ Length → Length
  - Length ÷ Time → Velocity
  - Length ÷ Length → Scalar (dimensionless)
  - Dimensioned ÷ Scalar → Dimensioned
  - Scalar ÷ Dimensioned → Inverse dimension
- Edge cases:
  - Operations with zero values
  - Very large/small factors
  - Dimension cancellation scenarios

---

## Detailed Requirements

### Functional Requirements

**FR-1: Multiplication Operation**
- Input: Two `NormalizedUnit` instances with their decimal values
- Process:
  1. Add dimension signatures (exponents)
  2. Multiply base factors
  3. Multiply values
- Output: `DimensionalResult` with combined signature, factor, and value

**FR-2: Division Operation**
- Input: Numerator and denominator `NormalizedUnit` instances with values
- Process:
  1. Subtract denominator signature from numerator (invert exponents)
  2. Divide base factors
  3. Divide values
- Output: `DimensionalResult` with resultant signature, factor, and value

**FR-3: Scalar Recognition**
- Identify when resulting signature is dimensionless (all exponents are zero)
- Mark result appropriately for consumer logic

**FR-4: Factor Preservation**
- Maintain exact conversion factors through operations
- Use `decimal` arithmetic per S-005 decision (adequate precision)

**FR-5: Value Computation**
- Compute final value in base units
- Preserve precision through calculation chain

### Non-Functional Requirements

**NFR-1: Performance**
- Operations complete in microseconds
- Minimal allocations (value types where possible)
- No caching in initial implementation (deferred to F-010)

**NFR-2: Testability**
- Interface-based design for easy testing
- Deterministic operations
- No external dependencies

**NFR-3: Maintainability**
- Clear, focused implementation
- Well-documented domain rules
- Consistent with existing codebase style

**NFR-4: Compatibility**
- Works with both netstandard2.0 and net7.0
- No breaking changes to existing code
- Consumed internally (not exposed in public API)

---

## Acceptance Criteria

### Core Functionality
✅ **AC-1**: Multiply operation combines signatures correctly  
- Given two quantities with different units
- When multiplied
- Then resulting signature has summed exponents

✅ **AC-2**: Divide operation combines signatures correctly  
- Given two quantities with different units
- When divided
- Then resulting signature has subtracted exponents (numerator - denominator)

✅ **AC-3**: Factor multiplication works correctly  
- Given two quantities with base factors
- When multiplied
- Then resulting factor is product of input factors

✅ **AC-4**: Factor division works correctly  
- Given two quantities with base factors
- When divided
- Then resulting factor is quotient of input factors

✅ **AC-5**: Scalar results identified correctly  
- Given operations that produce dimensionless results
- When signature has all zero exponents
- Then result is marked as scalar/dimensionless

✅ **AC-6**: Value computation maintains precision  
- Given input values with decimal precision
- When operations performed
- Then output maintains precision within acceptable tolerance

### Test Coverage
✅ **AC-7**: Comprehensive unit tests written  
- All test names follow `MethodName_Condition_ExpectedResult()` pattern
- Minimum 85% code coverage for engine implementation
- Tests cover happy path and edge cases

✅ **AC-8**: Example scenarios validated  
- Length × Length → Area (verified)
- Force × Length → Energy/Torque (verified)
- Area ÷ Length → Length (verified)
- Length ÷ Length → Scalar (verified)

### Integration Readiness
✅ **AC-9**: Interface suitable for F-007 consumption  
- Clear method signatures
- Appropriate input/output types
- Well-documented behavior

✅ **AC-10**: No regressions introduced  
- All existing tests remain passing
- No changes to public API surface

---

## Technical Design

### Architecture

```
┌─────────────────────────────────────────────────────────┐
│                    Quantity (Public)                     │
│  (F-007 will wire operators to engine)                  │
└─────────────────────┬───────────────────────────────────┘
                      │
                      │ Uses (in F-007)
                      ▼
┌─────────────────────────────────────────────────────────┐
│              IDimensionalMath (Internal)                 │
│  + Multiply(left, right, values) → DimensionalResult    │
│  + Divide(num, denom, values) → DimensionalResult       │
└─────────────────────┬───────────────────────────────────┘
                      │
                      │ Implemented by
                      ▼
┌─────────────────────────────────────────────────────────┐
│            DimensionalMath (Internal Sealed)             │
│  - Combines signatures (add/subtract exponents)         │
│  - Multiplies/divides factors                           │
│  - Computes result values                               │
└───────┬──────────────────────────────────┬──────────────┘
        │                                  │
        │ Consumes                         │ Consumes
        ▼                                  ▼
┌──────────────────┐            ┌──────────────────────┐
│ DimensionSignature│            │   NormalizedUnit     │
│   (from F-002)   │            │    (from F-003)      │
└──────────────────┘            └──────────────────────┘
```

### Component Design

#### IDimensionalMath Interface
- **Location**: `src/Internal/Units/IDimensionalMath.cs`
- **Visibility**: `internal`
- **Purpose**: Define dimensional algebra operations contract
- **Methods**:
  - `Multiply`: Combine two quantities through multiplication
  - `Divide`: Combine two quantities through division

#### DimensionalMath Implementation
- **Location**: `src/Internal/Units/DimensionalMath.cs`
- **Visibility**: `internal sealed`
- **Stateless**: No instance state; could be static methods, but interface allows for future extensibility
- **Thread-safe**: Pure functions with no shared state

#### DimensionalResult Structure
- **Location**: `src/Internal/Units/DimensionalResult.cs`
- **Type**: `internal readonly struct`
- **Properties**:
  - `Value`: The computed decimal value in base units
  - `Signature`: The resulting `DimensionSignature`
  - `Factor`: The combined conversion factor
  - `IsScalar`: Helper property (signature.IsDimensionless)
- **Purpose**: Encapsulate operation result for consumption by operator layer

### Signature Combination Rules

**Multiplication**: Add exponents
```
[L¹] × [L¹] = [L²]  (meter × meter = meter²)
[L²] × [L¹] = [L³]  (area × length = volume)
[M¹L¹T⁻²] × [L¹] = [M¹L²T⁻²]  (force × length = energy/torque)
```

**Division**: Subtract exponents (numerator - denominator)
```
[L²] ÷ [L¹] = [L¹]  (area ÷ length = length)
[L¹] ÷ [T¹] = [L¹T⁻¹]  (length ÷ time = velocity)
[L¹] ÷ [L¹] = [L⁰] = Scalar  (length ÷ length = dimensionless)
```

### Factor Combination Rules

**Multiplication**: Multiply factors
```
factor_result = factor_left × factor_right
value_result = value_left × value_right
```

**Division**: Divide factors
```
factor_result = factor_numerator ÷ factor_denominator
value_result = value_numerator ÷ value_denominator
```

### Precision Considerations

Per S-005 findings:
- Use `decimal` for all calculations
- No custom `Rational` type needed (F-001 deferred)
- `decimal` provides adequate precision for dimensional algebra
- Typical precision loss < 0.001% for common scenarios

---

## Implementation Tasks

### Phase 1: Core Implementation (Day 1)

**Task 1.1**: Create `DimensionalResult` structure
- Define readonly struct with Value, Signature, Factor properties
- Add `IsScalar` helper property
- Add constructor and basic validation
- Estimated: 30 minutes

**Task 1.2**: Create `IDimensionalMath` interface
- Define `Multiply` method signature
- Define `Divide` method signature
- Add XML documentation
- Estimated: 20 minutes

**Task 1.3**: Implement `DimensionalMath.Multiply`
- Implement signature combination (add exponents)
- Implement factor multiplication
- Implement value computation
- Add input validation (null checks, etc.)
- Estimated: 1 hour

**Task 1.4**: Implement `DimensionalMath.Divide`
- Implement signature combination (subtract exponents)
- Implement factor division
- Implement value computation
- Add divide-by-zero handling
- Estimated: 1 hour

### Phase 2: Testing (Day 1-2)

**Task 2.1**: Create test infrastructure
- Set up `DimensionalMathTests.cs` file
- Create test helper methods for common scenarios
- Estimated: 30 minutes

**Task 2.2**: Write multiplication tests
- Length × Length → Area
- Force × Length → Torque/Energy
- Scalar × Dimensioned (various)
- Edge cases (zeros, large values)
- Estimated: 2 hours

**Task 2.3**: Write division tests
- Area ÷ Length → Length
- Length ÷ Time → Velocity
- Length ÷ Length → Scalar
- Scalar ÷ Dimensioned
- Edge cases (zeros, divide-by-zero)
- Estimated: 2 hours

**Task 2.4**: Write integration validation tests
- Real-world scenarios (engineering calculations)
- Cross-check with known conversion factors
- Precision validation
- Estimated: 1 hour

### Phase 3: Documentation & Polish (Day 2)

**Task 3.1**: Add comprehensive XML documentation
- Document interface and implementation
- Add usage examples in comments
- Document edge cases and error handling
- Estimated: 1 hour

**Task 3.2**: Code review and refinement
- Verify SOLID principles adherence
- Ensure consistent style with codebase
- Optimize for readability
- Estimated: 1 hour

**Task 3.3**: Validation against acceptance criteria
- Review each AC item
- Run full test suite
- Verify no regressions
- Estimated: 30 minutes

---

## Test Plan

### Test Categories

#### 1. Multiplication Tests
```csharp
// Basic dimensional algebra
Multiply_LengthByLength_ReturnsArea()
Multiply_LengthByLengthByLength_ReturnsVolume()
Multiply_ForceByLength_ReturnsTorque()
Multiply_MassByAcceleration_ReturnsForce()

// Scalar interactions
Multiply_ScalarByLength_ReturnsLength()
Multiply_LengthByScalar_ReturnsLength()
Multiply_ScalarByScalar_ReturnsScalar()

// Factor combination
Multiply_InchByInch_ReturnsCorrectSquareInchFactor()
Multiply_MeterByFoot_ReturnsCorrectAreaFactor()

// Edge cases
Multiply_ZeroByLength_ReturnsZero()
Multiply_VeryLargeValues_MaintainsPrecision()
```

#### 2. Division Tests
```csharp
// Basic dimensional algebra
Divide_AreaByLength_ReturnsLength()
Divide_VolumeByArea_ReturnsLength()
Divide_LengthByTime_ReturnsVelocity()
Divide_LengthByLength_ReturnsScalar()

// Scalar interactions
Divide_LengthByScalar_ReturnsLength()
Divide_ScalarByLength_ReturnsInverseLength()
Divide_ScalarByScalar_ReturnsScalar()

// Factor combination
Divide_SquareInchByInch_ReturnsCorrectInchFactor()
Divide_SquareMeterByFoot_ReturnsCorrectLengthFactor()

// Edge cases
Divide_ZeroByLength_ReturnsZero()
Divide_LengthByZero_ThrowsException()
Divide_VerySmallByVeryLarge_MaintainsPrecision()
```

#### 3. Signature Combination Tests
```csharp
SignatureCombination_Multiply_AddsExponents()
SignatureCombination_Divide_SubtractsExponents()
SignatureCombination_Cancellation_ReturnsScalar()
SignatureCombination_ComplexUnits_CorrectlyComputes()
```

#### 4. Precision Tests
```csharp
Precision_InchToMeterMultiplication_WithinTolerance()
Precision_PoundForceInchTorque_WithinTolerance()
Precision_ChainedOperations_AccumulatesMinimalError()
```

### Test Data Examples

| Operation | Left | Right | Expected Result |
|-----------|------|-------|-----------------|
| Multiply | 2 m | 3 m | 6 m² (signature: L²) |
| Multiply | 10 lbf | 2 in | 20 lbf·in (signature: ML²T⁻²) |
| Divide | 12 m² | 4 m | 3 m (signature: L¹) |
| Divide | 100 m | 10 s | 10 m/s (signature: L¹T⁻¹) |
| Divide | 5 ft | 5 ft | 1 (scalar, signature: all zeros) |

---

## Dependencies

### Upstream Dependencies (Required)
- **F-002**: `DimensionSignature` must be implemented and tested
  - Provides signature addition/subtraction operations
  - Provides dimensionless detection
- **F-003**: `UnitResolver` and `NormalizedUnit` must be available
  - Provides normalized unit representations
  - Provides base conversion factors

### Downstream Consumers (Will Use This)
- **F-007**: Operators Integration
  - Will wire public `Quantity` operators to engine
  - Will handle special cases (temperature, etc.)
- **F-008**: Format Extensions
  - May use engine results for formatting decisions
- **F-010**: Performance & Caching
  - May cache engine results for common operations

---

## Risks and Mitigations

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Precision loss in chained operations | Low | Medium | Use `decimal` throughout; validate with tests; document limits |
| Performance concerns with complex signatures | Low | Low | Initial implementation focuses on correctness; F-010 addresses performance |
| Integration complexity with F-007 | Medium | Medium | Design clear interface now; collaborate on F-007 requirements |
| Edge cases not covered | Medium | Medium | Comprehensive test suite; real-world scenario validation |
| Divide-by-zero handling | Low | Medium | Explicit guards; clear exception messages |

---

## Integration Notes

### For F-007 (Operators Integration)
The engine is designed to be consumed by the `Quantity` operator layer:

```csharp
// Example integration pattern (to be implemented in F-007)
public static Quantity operator *(Quantity left, Quantity right)
{
    // Handle special cases (both scalar, one scalar, etc.)
    if (left.UnitType == UnitTypeEnum.Scalar && right.UnitType == UnitTypeEnum.Scalar)
        return new Quantity(left.Value * right.Value);
    
    // Resolve to normalized units
    var leftNorm = resolver.Resolve(left.Unit);
    var rightNorm = resolver.Resolve(right.Unit);
    
    // Use engine for dimensional computation
    var result = engine.Multiply(leftNorm, rightNorm, left.Value, right.Value);
    
    // Convert result back to appropriate unit (handled by naming/formatting layers)
    return CreateQuantityFromResult(result);
}
```

### Interface Contract
- **Input**: Always normalized units with their dimension signatures and factors
- **Output**: Always base unit values with combined signatures and factors
- **Errors**: Throw `InvalidOperationException` for divide-by-zero only
- **Thread Safety**: Stateless, safe for concurrent calls

---

## Out of Scope

The following are explicitly NOT part of F-004:

❌ **Unit Naming/Formatting**: Handled by F-005 (Known Signature Map) and F-006 (Composite Formatter)  
❌ **Operator Wiring**: Handled by F-007 (Operators Integration)  
❌ **Parsing Composite Units**: Deferred to F-009  
❌ **Performance Optimization**: Deferred to F-010 (caching, memoization)  
❌ **Temperature Handling**: Special case logic in F-007  
❌ **User-Facing API**: Engine is internal; public API unchanged  
❌ **Validation of Unit Compatibility**: Add/subtract validation remains in existing operator logic

---

## Quality Checklist

### Domain Design Validation
- [ ] I have verified that the engine properly models dimensional algebra concepts
- [ ] I have confirmed consistent terminology (signature, factor, dimension)
- [ ] I have verified SOLID principles adherence (SRP, DIP)
- [ ] I have validated domain rules for signature combination

### Implementation Quality Validation
- [ ] I have written comprehensive tests following `MethodName_Condition_ExpectedResult()` naming
- [ ] I have achieved >85% code coverage for engine implementation
- [ ] I have considered performance and used value types appropriately
- [ ] I have documented all public-within-internal APIs

### Precision & Compliance Validation
- [ ] I have used `decimal` types for all calculations
- [ ] I have validated precision within acceptable tolerances
- [ ] I have tested with real-world engineering scenarios
- [ ] I have documented precision characteristics and limitations

### Integration Readiness Validation
- [ ] I have designed interface suitable for F-007 consumption
- [ ] I have verified no breaking changes to existing code
- [ ] I have confirmed all existing tests still pass
- [ ] I have provided clear integration examples

---

## Success Metrics

1. **Functionality**: All acceptance criteria met and validated
2. **Test Coverage**: >85% coverage for `DimensionalMath` implementation
3. **Performance**: Operations complete in <1ms for typical cases (baseline for F-010)
4. **Quality**: Zero regressions in existing test suite
5. **Readiness**: F-007 team confirms interface meets their needs

---

## Timeline

**Total Estimated Effort**: 1.5 - 2 days

- **Day 1 Morning**: Implementation (Tasks 1.1-1.4) - 3 hours
- **Day 1 Afternoon**: Basic testing (Task 2.1-2.2) - 3 hours
- **Day 2 Morning**: Advanced testing (Task 2.3-2.4) - 3 hours
- **Day 2 Afternoon**: Documentation & validation (Tasks 3.1-3.3) - 2.5 hours

**Note**: Timeline assumes F-002 and F-003 are complete and stable.

---

## References

### Internal References
- **E-001**: Epic — Option A Hybrid Core
- **S-005**: Decimal Precision Spike (validated decimal sufficiency)
- **F-001**: Core Rational Arithmetic (deferred per S-005)
- **F-002**: Dimension Signature Model (dependency)
- **F-003**: Unit Normalization and Alias Resolver (dependency)
- **F-007**: Operators Integration (consumer)

### External References
- **Dimensional Analysis (Wikipedia)**: https://en.wikipedia.org/wiki/Dimensional_analysis
- **Kennedy Paper on Types and Units**: http://typesatwork.imm.dtu.dk/material/TaW_Paper_TypesAtWork_Kennedy.pdf
- **Frink Language**: https://frinklang.org/ (reference implementation for dimensional algebra)

---

## Open Questions

1. **Q**: Should the engine handle temperature difference vs absolute temperature?  
   **A**: No, special temperature handling delegated to F-007 operator layer.

2. **Q**: Should we cache common signature combinations?  
   **A**: No, deferred to F-010. Initial implementation prioritizes correctness.

3. **Q**: How should we handle very large or very small exponents (overflow)?  
   **A**: `sbyte` range (-128 to 127) is sufficient for any practical dimensional algebra. Document this limitation.

4. **Q**: Should we provide an async version of the interface?  
   **A**: No, operations are pure computation with no I/O. Synchronous is appropriate.

5. **Q**: Do we need a `TryMultiply` / `TryDivide` pattern?  
   **A**: Not initially. Only divide-by-zero can fail; let it throw. Revisit in F-011 if needed.

---

## Notes

- This is a foundational feature; correctness is prioritized over performance
- F-010 will optimize hot paths after establishing correct baseline behavior
- Engine is internal API; breaking changes allowed before 1.0 if needed
- Collaboration with F-007 team recommended during implementation to validate interface design
