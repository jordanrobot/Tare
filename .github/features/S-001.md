# S-001: Dimensional analysis and cross-unit operations (spike)

This spike explores ways to enable dimensionally-aware math across different unit types and to preserve meaningful results. Examples:

- 6 in × 10 lbf → 60 lbf·in (torque/energy unit)
- 48 in*in ÷ 4 in → 12 in (length)
- 48 in ÷ 1 in → 48 (unit cancellation to scalar)

The goal is to evaluate multiple designs, surface trade‑offs, and outline a small proof-of-concept plan with tests, while keeping changes safe and incremental for this library.

## Goals

- Allow multiplication/division between compatible dimensional types and produce correct derived units and values.
- Preserve immutability, value semantics, and decimal precision.
- Keep public API changes to an absolute minimum; favor additive, internal implementation where possible.
- Work with existing `UnitDefinitions` (parsing, factors, aliases) and reuse its conversion mechanisms.
- Provide a path to simplify/cancel units (e.g., in*in ÷ in → in; and in ÷ in → scalar).
- If the development of this spike reveals that public API changes are needed, document them for future consideration.
- If the development of this spike is too constrained by the existing API surface, document the limitations and propose a follow-up RFC for a more extensive redesign. 

## Non-goals

- Do not introduce runtime dependencies or change target frameworks.
- Do not introduce a heavy algebra/units package.
- Do not broadly refactor `Quantity` public API unless a later RFC justifies it.

## Constraints and current state

- `Quantity` is a readonly struct using decimal for value and a single `Unit` string with `Factor` and `UnitType` from `UnitDefinitions`.
- Existing operators only allow cross-unit comparison within the same `UnitTypeEnum`; `*` and `/` work with scalars or throw when both operands have units.
- `UnitDefinitions` already contains some derived/compound names (e.g., `in*lbf`, `ft*lbf`, `Nm`) mapped to energy/torque semantics. This is a useful foundation.

## Success criteria

- Numeric correctness for representative examples using decimal math.
- Deterministic unit results (consistent string and `UnitType` where applicable).
- Ability to convert derived results into other equivalent units (e.g., `60 lbf·in` ↔ `6.779... Nm`).
- Unit cancellation works for simple cases (area ÷ length → length; unit ÷ same unit → scalar).
- Behavior stays backward compatible for existing operations.

---

## Option A — Catalog-driven composites (rule table over UnitTypes)

Approach
- Define a small, explicit rule table for dimensional products/quotients mapping operand `UnitTypeEnum` pairs to a resulting `UnitTypeEnum` (e.g., `Length × Force → Energy`).
- For each operator application, look up the pair (and division variant) and compute the resulting value via factor algebra. The unit string is chosen by either:
  - A canonical derived unit name (e.g., `Nm` for SI), or
  - A composite textual form derived from operands (e.g., `in*lbf`) when a canonical exists in `UnitDefinitions`.
- Extend `UnitDefinitions` with the minimal set of missing derived unit entries and aliases to support common combinations and conversions.

Pros
- Minimal changes to `Quantity` structure and public API.
- Predictable, whitelisted combinations; easier to reason about.
- Leverages existing `UnitDefinitions` for factors and aliases.

Cons / Risks
- Coverage requires manual rule growth; long tail of combinations.
- May devolve into many entries or special cases over time.
- Unit cancellation (e.g., `in*in ÷ in → in` and `in ÷ in → scalar`) requires special handling rather than general algebra.

Spike plan
- Add a small in-memory rule table (internal) for: `Length×Force→Energy`, `Area÷Length→Length`, `Length×Length→Area`, `Volume÷Length→Area` (illustrative set).
- Implement `Quantity` `*` and `/` branches that check the rule table before falling back to current behavior.
- Reuse `UnitDefinitions` to select a presentable unit: prefer a known derived name; otherwise synthesize `"{leftUnit}*{rightUnit}"` (only if present in definitions).
- Tests: the three examples above plus SI/Imperial cross-checks (e.g., `0.5 m × 20 N = 10 Nm`, equals `~88.50 lbf·in`).

---

## Option B — Internal dimension vectors (fundamental exponents)

Approach
- Introduce an internal "dimension signature" representation (e.g., exponents over fundamental dimensions like L, M, T). Example signatures:
  - Length = L¹, Area = L², Force = M¹·L¹·T⁻², Energy = M¹·L²·T⁻².
- Each `UnitDefinition` gets (internally) mapped to a signature; multiply/divide add/subtract exponents; simplify to produce cancellation (e.g., L²/L → L).
- For naming the result, attempt a reverse map from signatures to known `UnitTypeEnum`/preferred unit symbol; fallback to a normalized composite string.

Pros
- General solution covers all compositions/cancellations consistently.
- Natural unit simplification emerges from exponent math.
- Easier to extend to more derived types later.

Cons / Risks
- More moving parts (signature map, normalization, pretty-printing).
- Requires curating signature mappings for existing `UnitTypeEnum` values.
- Choosing display units consistently (e.g., SI-first vs. operand-derived) needs policy.
- Potential need for a new `UnitTypeEnum.Derived` for signatures without a named type (public API change) unless kept internal.

Spike plan
- Add a private `DimensionSignature` type (e.g., small fixed struct or dictionary of base dims); map current UnitTypes to signatures.
- Implement internal helpers to combine/simplify signatures on `*` and `/`.
- Keep public API unchanged by storing the string unit and factor as today; signature is computed on the fly or cached internally.
- Naming policy: if signature matches a known named type, select canonical unit (e.g., `Nm`); else synthesize a normalized composite (like `lbf*in`) when present in `UnitDefinitions`; otherwise return a mechanically built string.
- Tests: same as Option A plus additional cancellation cases (e.g., `m^3 / m^2 = m`).

---

## Option C — Hybrid: dimension vectors for math + catalog for naming

Approach
- Use Option B’s internal signature math for correctness and cancellation.
- Use `UnitDefinitions` as a naming/formatting catalog: prefer existing named units/aliases for known signatures. Provide a small mapping from signature → preferred unit key(s).

Pros
- Mathematical robustness with friendly, familiar unit names.
- Leverages existing `UnitDefinitions` investments and avoids inventing many composite entries.

Cons / Risks
- Requires maintaining a small signature→name lookup for best display units.
- Two sources of truth (math vs. naming) must stay consistent.

Spike plan
- Implement the signature math core for `*` and `/`.
- Build a small map for common signatures (Energy, Torque, Pressure, etc.) to preferred units (e.g., `Nm`, `Pa`).
- Fallback to composite naming when no preferred unit is defined.

---

## Option D — String-composition only (lightweight, limited)

Approach
- On `*` and `/`, synthesize a composite unit string (e.g., `in*lbf`, `in*in/in`) and compute the new factor as pure algebra of operand factors; attempt string-level simplifications for trivial cases (e.g., cancel same unit tokens when exponents allow).

Pros
- Minimal implementation, no new internal model.
- Can be made to work for the showcased examples if units match exactly.

Cons / Risks
- Fragile: relies on string parsing to simplify; error-prone for aliases, mixed systems, or formatting variants.
- No principled dimensional validation; easier to produce odd composites.
- Hard to generalize.

Spike plan
- Implement only for demonstration; restrict to exact-unit token matches and simple exponent math; document limitations.

---

## Edge cases to consider

- Scalars: existing behavior must remain; scalar×unit and unit÷scalar work unchanged.
- Unknown units: operations with `UnitTypeEnum.Unknown` should continue to throw or return a safe error per current patterns.
- Zero and negative values: ensure correct algebra and signs.
- Aliases: `UnitDefinitions` normalization should be applied before composition; avoid `"inch"` vs `"in"` mismatches.
- Formatting: `Format()` and `ToString()` must remain locale-stable; include composite units where applicable.
- Conversions: derived results should convert via factors to any compatible target unit (e.g., `lbf*in` ↔ `Nm`).
- Comparisons: equality/ordering on derived units should compare on common base value (factor-normalized) within the same dimensional signature.

## Minimal test matrix (illustrative)

- Multiply: `6 in * 10 lbf = 60 lbf*in`; equals `~6.779 Nm` (value check within decimal precision; verify reversible conversion).
- Divide (compose then reduce): `48 in*in / 4 in = 12 in`.
- Unit cancellation to scalar: `48 in / 1 in = 48`.
- SI checks: `0.5 m * 20 N = 10 Nm`; equals `~88.50 lbf*in`.
- Mixed aliases: `2 inch * 3 pound force` normalizes to `6 lbf*in`.
- Error on incompatible add/sub: addition rules unchanged; cross-unit add still throws.

## API impact and compatibility

- Preferred path: keep `Quantity` public API unchanged. Implement dimensional logic internally in operators `*` and `/`.
- If a new public `UnitTypeEnum` is required (e.g., `Derived`), treat that as a follow-up RFC; avoid in the spike.
- No new packages; retain decimal for all computations.

## Recommendation for the spike

- Primary: pursue Option C (Hybrid). It gives robust math (via internal signatures) and friendly naming (via `UnitDefinitions`), while keeping public API stable.
- Baseline: implement a very small Option A rule table to support 2–3 high-value cases immediately (Energy/Torque; simple cancellation). This de-risks early demos and provides a fallback if signature work takes longer.

## Timebox and deliverables

- Timebox: 1–2 days of focused spike work.
- Deliverables:
  - A throwaway branch with a minimal internal signature type, rule table, and modified `*` and `/` paths.
  - Unit tests for the examples and SI/Imperial equivalence.
  - A short readme note summarizing outcomes and any API pressure points.

## Next steps

- Confirm acceptance of the Hybrid-first spike plan.
- Identify the minimal set of base dimensions to support (L, M, T are likely sufficient to cover showcased cases).
- Draft the signature mapping for current `UnitTypeEnum` values (Length, Area, Volume, Mass, Force, Energy, Pressure, Time, Velocity, Acceleration, etc.).
- Implement POC and tests; evaluate display naming policy (SI-first by default with alias-friendly fallbacks).
