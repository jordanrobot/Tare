# F-012: Error Handling and Diagnostics

**Status**: Planned  
**Epic**: E-001 (Option A Hybrid Core)  
**Priority**: P2 (Should)  
**Effort**: M (1–2 days)  
**Dependencies**: F-011 (Performance & Caching)

---

## Mandatory Thinking (DDD/.NET Guidelines)

### 1) Analysis

**Applicable Patterns**:
- **Domain Service**: Error handling policies encapsulate business rules for exception scenarios
- **SOLID Principles**:
  - **SRP**: Exception handling separated by layer (Domain validation, Application orchestration)
  - **OCP**: Exception types extensible without modifying existing handlers
  - **ISP**: Diagnostic interfaces focused on specific concerns (cache stats, parse metrics)
- **Ubiquitous Language**: Error messages use consistent domain terminology (Quantity, Unit, Signature, Composite, Catalog)

**Layers Affected**:
- **Domain**: All value objects (Quantity, Rational, DimensionSignature) and domain services (DimensionalMath)
- **Application**: Error propagation and diagnostic reporting
- **Infrastructure**: N/A (library context, no external dependencies)

**Security & Compliance**:
- No sensitive data in exception messages
- Deterministic error behavior for audit trails
- No information leakage about internal implementation

### 2) Review Against Guidelines

**Aggregate Boundaries**: Error handling respects value object immutability; exceptions thrown before state changes

**SRP Compliance**: Each exception type has single responsibility; diagnostic collection separate from business logic

**Domain Rules Encapsulated**: Validation logic (incompatible units, null checks, divide-by-zero) encapsulated in value objects and services

**Tests**: All exception scenarios tested using `MethodName_Condition_ExpectedResult()` pattern

**Ubiquitous Language**: Consistent terminology in all error messages

### 3) Implementation Plan Validation

**Files to Create/Modify**:
- Modify: `src/Internal/Units/CompositeParser.cs` (null handling bug fix)
- Modify: `src/Quantity.cs` (standardize error messages)
- Modify: `src/UnitDefinitions.cs` (standardize error messages)
- Modify: `src/Internal/Rational.cs` (standardize error messages)
- Modify: `src/Internal/Units/*.cs` (standardize error messages across all internal units)
- Optional Create: `src/Diagnostics/IDiagnostics.cs` (if unified diagnostics API needed)

**Tests**:
- All existing exception tests remain green
- New tests for standardized error messages
- Test for CompositeParser null handling bug fix
- Tests for any new diagnostic APIs

**Error Handling Strategy**:
- Fail fast with clear exceptions at boundaries
- Use specific exception types (ArgumentException, InvalidOperationException, FormatException, DivideByZeroException)
- No silent failures; all errors propagate with context

---

## Description

Establish consistent, tested error handling and diagnostics throughout the Tare library. This feature ensures:
1. Clear, actionable exception messages using ubiquitous language
2. Consistent exception types across similar scenarios
3. Proper null/empty input validation everywhere
4. Comprehensive test coverage for all error paths
5. Optional diagnostic capabilities (cache stats, performance metrics)

---

## User Story

As a **developer using Tare**, I want:
- Clear error messages when I provide invalid inputs, so I can quickly understand and fix issues
- Consistent exception types for similar errors, so I can write predictable error handling code
- Access to diagnostics (cache hits/misses), so I can optimize my usage patterns

---

## Acceptance Criteria

### 1. Null and Empty Input Handling
- ✅ All public APIs guard against null inputs with `ArgumentNullException`
- ✅ All public APIs guard against empty/whitespace strings with `ArgumentException`
- ✅ All `TryParse` methods handle null gracefully, returning false without throwing
- ✅ Error messages include parameter names using `nameof()`

### 2. Exception Type Consistency
- ✅ Use `ArgumentNullException` for null arguments
- ✅ Use `ArgumentException` for invalid arguments (empty, malformed, unknown units)
- ✅ Use `InvalidOperationException` for incompatible operations (adding Length to Mass)
- ✅ Use `FormatException` for malformed composite unit syntax
- ✅ Use `DivideByZeroException` for division by zero

### 3. Error Message Standards
- ✅ All messages use ubiquitous language: "Quantity", "Unit", "Signature", "Composite", "Catalog"
- ✅ Messages include context: what was invalid, why it's invalid, what's expected
- ✅ No implementation details leaked (no internal type names in public exceptions)
- ✅ Consistent format: "Cannot [action]. [Reason]. [Guidance]."

**Examples**:
```csharp
// Good
throw new ArgumentException(
    "Unknown or malformed unit: 'xyz'. " +
    "Unit must be either a valid catalog unit or a composite unit. " +
    "Use UnitDefinitions.IsValidUnit() to check catalog units.",
    nameof(unit));

// Good
throw new InvalidOperationException(
    "Cannot add quantities with incompatible units. " +
    "Quantities must have the same dimension (e.g., Length + Length). " +
    $"Attempted: {UnitType} + {other.UnitType}");

// Bad (inconsistent, lacks context)
throw new Exception("Error");
```

### 4. Comprehensive Test Coverage
- ✅ Every `throw` statement has at least one test using `MethodName_Condition_ExpectedResult()` pattern
- ✅ Tests verify exception type, message content, and parameter name
- ✅ Edge cases covered: null, empty, whitespace, malformed, unknown, incompatible

### 5. Diagnostics (Optional/Future)
- ✅ Cache statistics accessible via `CompositeParser` (already implemented in F-011)
- ⏸️ Unified diagnostics API deferred to F-013 (API Helpers) if user demand exists

---

## Technical Approach

### Phase 1: Bug Fixes (Critical Path)
**Fix CompositeParser null handling** (BLOCKING: causes test failure)

**File**: `src/Internal/Units/CompositeParser.cs`

**Current Bug**:
```csharp
public bool TryParse(string compositeUnit, out DimensionSignature signature, out decimal factor)
{
    // BUG: ConcurrentDictionary.TryGetValue throws on null key
    if (_parseCache.TryGetValue(compositeUnit, out var cachedResult))
    {
        // ...
    }
}
```

**Fix**:
```csharp
public bool TryParse(string compositeUnit, out DimensionSignature signature, out decimal factor)
{
    // Guard against null/empty input
    if (string.IsNullOrWhiteSpace(compositeUnit))
    {
        signature = DimensionSignature.Dimensionless;
        factor = 1m;
        return false;
    }
    
    // Check cache (now safe)
    if (_parseCache.TryGetValue(compositeUnit, out var cachedResult))
    {
        // ...
    }
}
```

### Phase 2: Message Standardization
**Audit and standardize all error messages**

**Current State Analysis** (from code review):
| Location | Current Message | Status | Action Needed |
|----------|----------------|--------|---------------|
| Quantity.cs:79 | "Unknown or malformed unit..." | ✅ Good | None |
| Quantity.cs:142 | "Unknown or malformed unit..." | ✅ Good | None |
| Quantity.cs:493 | "Cannot add quantities of incompatible units." | ⚠️ Good but could add context | Enhance with unit types |
| Quantity.cs:699 | "Cannot divide integers by quantities with units" | ⚠️ Inconsistent capitalization | Standardize |
| UnitDefinitions.cs:68 | "No matching unit X was found." | ⚠️ Lacks guidance | Add next steps |
| Rational.cs:29 | "Denominator cannot be zero." | ✅ Good | None |

**Standardization Rules**:
1. **Sentence structure**: "Cannot [action]. [Reason]. [Optional guidance]."
2. **Terminology**: Always use: Quantity, Unit, Catalog, Composite, Dimension, Signature
3. **Capitalization**: Full sentences with proper punctuation
4. **Context**: Include actual values when helpful (use string interpolation safely)
5. **Guidance**: When possible, tell user how to fix or check

### Phase 3: Test Coverage Expansion
**Ensure every error path is tested**

**Current Test Coverage** (from code review):
- ✅ Format exceptions: `QuantityFormatCompositeTests.cs` (well covered)
- ✅ UnitToken validation: `UnitTokenTests.cs` (well covered)
- ✅ Incompatible operations: `QuantityOperatorTests.cs` (partial coverage)
- ⚠️ Null handling: Missing tests in several areas
- ⚠️ Message content: Not explicitly verified

**New Tests Needed**:
1. Verify error messages contain expected keywords
2. Test all TryParse null/empty scenarios
3. Test incompatible operations across all operators
4. Test divide-by-zero in all contexts (Rational, DimensionalMath, Quantity operators)

**Test Pattern**:
```csharp
[Test]
public void Constructor_NullUnit_ThrowsArgumentNullException()
{
    // Arrange & Act & Assert
    var ex = Assert.Throws<ArgumentNullException>(() => new Quantity(10, null));
    Assert.That(ex.ParamName, Is.EqualTo("unit"));
}

[Test]
public void Add_IncompatibleUnits_ThrowsInvalidOperationExceptionWithContext()
{
    // Arrange
    var length = Quantity.Parse("10 m");
    var mass = Quantity.Parse("5 kg");
    
    // Act & Assert
    var ex = Assert.Throws<InvalidOperationException>(() => _ = length + mass);
    Assert.That(ex.Message, Does.Contain("incompatible"));
    Assert.That(ex.Message, Does.Contain("Length"));
    Assert.That(ex.Message, Does.Contain("Mass"));
}
```

---

## Out of Scope

- ❌ Custom exception types (use standard .NET exceptions)
- ❌ Localization of error messages (English only for now)
- ❌ Structured logging framework (library context, consumers handle logging)
- ❌ Error recovery mechanisms (fail-fast philosophy)
- ❌ Exception wrapping/chaining (keep exception hierarchy simple)

---

## Dependencies

### Consumes
- **F-011**: Uses cache statistics already implemented in CompositeParser

### Enables
- **F-013**: API Helpers may expose diagnostics as public API if user demand exists

---

## Testing Strategy

### Unit Tests
**Target**: All exception paths in domain logic

**Naming Convention**: `MethodName_Condition_ExpectedResult()`

**Coverage Goals**:
- 100% of `throw` statements covered
- All TryParse methods tested with null/empty/invalid inputs
- All operators tested with incompatible operands

**Test Categories**:
1. **Validation Tests**: Null, empty, whitespace, malformed, unknown
2. **Operation Tests**: Incompatible add/sub, divide-by-zero
3. **Message Tests**: Verify error text contains expected context

### Integration Tests
**Target**: End-to-end error scenarios

**Examples**:
- Parse invalid composite → catch exception → verify message
- Multiply incompatible quantities → verify dimensional error
- Format to incompatible target → verify dimension error

---

## Documentation Updates

### XML Comments
- ✅ Ensure all public APIs document their `<exception>` tags
- ✅ Include exception type, condition, and parameter name

**Example**:
```csharp
/// <summary>
/// Creates a Quantity with the specified value and unit.
/// </summary>
/// <param name="value">The numeric value of the quantity.</param>
/// <param name="unit">The unit of measure (catalog or composite).</param>
/// <exception cref="ArgumentNullException">Thrown when <paramref name="unit"/> is null.</exception>
/// <exception cref="ArgumentException">Thrown when <paramref name="unit"/> is empty, whitespace, or contains unknown base units.</exception>
/// <exception cref="FormatException">Thrown when composite unit syntax is malformed.</exception>
public Quantity(decimal value, string unit)
```

### CHANGELOG.md
Add entry:
```markdown
## [version] - [date]

### Fixed
- Fixed null input handling in `CompositeParser.TryParse()` (F-012)
- Standardized error messages across all exception types (F-012)

### Improved
- Enhanced exception messages with actionable guidance (F-012)
- Added comprehensive test coverage for all error scenarios (F-012)
```

### Contributor Guidelines
- Document error handling patterns for future contributors
- Include examples of good vs. bad error messages

---

## Quality Checklist

### Domain Design Validation
- ✅ I have verified that error handling respects value object immutability
- ✅ I have confirmed consistent terminology in all error messages
- ✅ I have verified SOLID principles, especially SRP for exception handling
- ✅ I have validated that domain validation rules are enforced at boundaries

### Implementation Quality Validation
- ✅ I have written comprehensive tests using `MethodName_Condition_ExpectedResult()` naming
- ✅ I have considered performance (exceptions are expensive, but correctness first)
- ✅ I have implemented null checks at all public API boundaries
- ✅ I have documented all exceptions in XML comments

### Error Handling Validation
- ✅ I have used specific exception types appropriate to each scenario
- ✅ I have ensured error messages are clear, consistent, and actionable
- ✅ I have verified no sensitive data or implementation details leak in messages
- ✅ I have tested all error paths with explicit assertions on exception content

---

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| Changing error messages breaks consumer code parsing messages | Low | Medium | Document that consumers should catch exception types, not parse messages |
| Performance impact of additional validation | Low | Low | Guards are cheap; fail-fast reduces wasted work |
| Test brittleness from message assertions | Medium | Low | Assert on keywords/patterns, not exact text |

---

## Timeline

**Estimated Effort**: 1–2 days

**Breakdown**:
- Day 1 AM: Fix critical null handling bug, run tests
- Day 1 PM: Audit and standardize error messages
- Day 2 AM: Write missing tests, ensure 100% exception coverage
- Day 2 PM: Update documentation, final verification

---

## Success Metrics

### Objective Measures
- ✅ Test suite passes 100% (including fixed `TryParse_NullInput_ReturnsFalse`)
- ✅ Zero `throw` statements without corresponding test
- ✅ All public APIs have `<exception>` XML documentation

### Subjective Measures
- ✅ Error messages reviewed and deemed clear/helpful by team
- ✅ Consistent terminology verified across all messages
- ✅ Exception handling patterns documented for contributors

---

## References

### Internal
- **E-001**: Epic defining F-012 scope and dependencies
- **F-011**: Performance & Caching (provides cache stats for diagnostics)
- **F-013**: API Helpers (may consume diagnostics)

### External
- **.NET Exception Best Practices**: https://learn.microsoft.com/en-us/dotnet/standard/exceptions/best-practices-for-exceptions
- **Fail-Fast Principle**: https://enterprisecraftsmanship.com/posts/fail-fast-principle/
- **Defensive Programming**: Guard clauses and validation patterns

---

## Open Questions

### Q1: Should we expose cache statistics publicly?
**Context**: F-011 implemented cache stats internally. Should we surface these?

**Options**:
- **A**: Keep internal; defer to F-013 (API Helpers) if user demand exists
- **B**: Expose simple `GetCacheStats()` method now

**Decision**: **Option A** (defer to F-013). Rationale:
- Follows YAGNI principle
- Keeps F-012 focused on error handling
- F-013 can design comprehensive diagnostics API with user input

### Q2: Should we create custom exception types?
**Context**: Currently using standard .NET exceptions. Should we add `TareException`, `IncompatibleUnitsException`, etc.?

**Options**:
- **A**: Use standard .NET exceptions (current approach)
- **B**: Create custom exception hierarchy

**Decision**: **Option A** (standard exceptions). Rationale:
- Standard exceptions well-understood by .NET developers
- Reduces API surface and maintenance burden
- Consumers can catch specific types or base `Exception`
- Custom types not needed for current scenarios

---

## Decisions Recorded

1. **Null Handling Strategy** (2025-11-11): All `TryParse` methods return `false` for null/empty input without throwing. All constructors and direct methods throw `ArgumentNullException` for null inputs.

2. **Error Message Format** (2025-11-11): Standardize on "Cannot [action]. [Reason]. [Optional guidance]." format with full sentences and proper punctuation.

3. **Diagnostics Exposure** (2025-11-11): Defer public diagnostics API to F-013. Keep F-011 cache stats internal for now.

4. **Exception Types** (2025-11-11): Use standard .NET exceptions. No custom exception hierarchy needed at this time.
