# F-012: Error Handling and Diagnostics

**Status**: Planned  
**Epic**: E-001 (Option A Hybrid Core)  
**Priority**: P2 (Should)  
**Effort**: M (1‚Äì2 days)  
**Dependencies**: F-011 (Performance & Caching)

---

## TL;DR ‚Äî Quick Reference

**Goal**: Standardize error handling and fix critical null-handling bug

**Effort**: 1-2 days (M)

**Impact**: Better developer experience, fixes test failure, zero breaking changes

### What Gets Fixed

**üêõ Critical Bug (BLOCKING)**  
`CompositeParser.TryParse(null, ...)` throws instead of returning false  
**Time**: <1 hour

**üìù Error Message Standardization**  
Inconsistent error messages across 25+ throw sites  
**Time**: 4-6 hours

**‚úÖ Test Coverage**  
Not all exception scenarios tested  
**Time**: 2-4 hours

### Quick Command Reference

```bash
# Build project
dotnet build

# Run all tests
dotnet test

# Run specific test
dotnet test --filter "TryParse_NullInput_ReturnsFalse"

# Check for coverage gaps (if tool installed)
dotnet-coverage collect -f cobertura -o coverage.xml dotnet test
```

---

## Mandatory Thinking (DDD/.NET Guidelines)

### 1) Analysis

**Applicable Patterns**:
- **Domain Service**: Error handling policies encapsulate business rules for exception scenarios
- **SOLID Principles**:
  - **SRP**: Exception handling separated by layer (Domain validation, Application orchestration)
  - **OCP**: Exception types extensible without modifying existing handlers
  - **ISP**: Diagnostic interfaces focused on specific concerns (cache stats, parse metrics)
- **Ubiquitous Language**: Error messages use consistent domain terminology (Quantity, Unit, Signature, Composite, Catalog)

**Layers Affected**:
- **Domain**: All value objects (Quantity, Rational, DimensionSignature) and domain services (DimensionalMath)
- **Application**: Error propagation and diagnostic reporting
- **Infrastructure**: N/A (library context, no external dependencies)

**Security & Compliance**:
- No sensitive data in exception messages
- Deterministic error behavior for audit trails
- No information leakage about internal implementation

### 2) Review Against Guidelines

**Aggregate Boundaries**: Error handling respects value object immutability; exceptions thrown before state changes

**SRP Compliance**: Each exception type has single responsibility; diagnostic collection separate from business logic

**Domain Rules Encapsulated**: Validation logic (incompatible units, null checks, divide-by-zero) encapsulated in value objects and services

**Tests**: All exception scenarios tested using `MethodName_Condition_ExpectedResult()` pattern

**Ubiquitous Language**: Consistent terminology in all error messages

### 3) Implementation Plan Validation

**Files to Create/Modify**:
- Modify: `src/Internal/Units/CompositeParser.cs` (null handling bug fix)
- Modify: `src/Quantity.cs` (standardize error messages)
- Modify: `src/UnitDefinitions.cs` (standardize error messages)
- Modify: `src/Internal/Rational.cs` (standardize error messages)
- Modify: `src/Internal/Units/*.cs` (standardize error messages across all internal units)
- Optional Create: `src/Diagnostics/IDiagnostics.cs` (if unified diagnostics API needed)

**Tests**:
- All existing exception tests remain green
- New tests for standardized error messages
- Test for CompositeParser null handling bug fix
- Tests for any new diagnostic APIs

**Error Handling Strategy**:
- Fail fast with clear exceptions at boundaries
- Use specific exception types (ArgumentException, InvalidOperationException, FormatException, DivideByZeroException)
- No silent failures; all errors propagate with context

---

## Description

Establish consistent, tested error handling and diagnostics throughout the Tare library. This feature ensures:
1. Clear, actionable exception messages using ubiquitous language
2. Consistent exception types across similar scenarios
3. Proper null/empty input validation everywhere
4. Comprehensive test coverage for all error paths
5. Optional diagnostic capabilities (cache stats, performance metrics)

---

## User Story

As a **developer using Tare**, I want:
- Clear error messages when I provide invalid inputs, so I can quickly understand and fix issues
- Consistent exception types for similar errors, so I can write predictable error handling code
- Access to diagnostics (cache hits/misses), so I can optimize my usage patterns

---

## Acceptance Criteria

### 1. Null and Empty Input Handling
- ‚úÖ All public APIs guard against null inputs with `ArgumentNullException`
- ‚úÖ All public APIs guard against empty/whitespace strings with `ArgumentException`
- ‚úÖ All `TryParse` methods handle null gracefully, returning false without throwing
- ‚úÖ Error messages include parameter names using `nameof()`

### 2. Exception Type Consistency
- ‚úÖ Use `ArgumentNullException` for null arguments
- ‚úÖ Use `ArgumentException` for invalid arguments (empty, malformed, unknown units)
- ‚úÖ Use `InvalidOperationException` for incompatible operations (adding Length to Mass)
- ‚úÖ Use `FormatException` for malformed composite unit syntax
- ‚úÖ Use `DivideByZeroException` for division by zero

### 3. Error Message Standards
- ‚úÖ All messages use ubiquitous language: "Quantity", "Unit", "Signature", "Composite", "Catalog"
- ‚úÖ Messages include context: what was invalid, why it's invalid, what's expected
- ‚úÖ No implementation details leaked (no internal type names in public exceptions)
- ‚úÖ Consistent format: "Cannot [action]. [Reason]. [Guidance]."

**Examples**:
```csharp
// Good
throw new ArgumentException(
    "Unknown or malformed unit: 'xyz'. " +
    "Unit must be either a valid catalog unit or a composite unit. " +
    "Use UnitDefinitions.IsValidUnit() to check catalog units.",
    nameof(unit));

// Good
throw new InvalidOperationException(
    "Cannot add quantities with incompatible units. " +
    "Quantities must have the same dimension (e.g., Length + Length). " +
    $"Attempted: {UnitType} + {other.UnitType}");

// Bad (inconsistent, lacks context)
throw new Exception("Error");
```

### 4. Comprehensive Test Coverage
- ‚úÖ Every `throw` statement has at least one test using `MethodName_Condition_ExpectedResult()` pattern
- ‚úÖ Tests verify exception type, message content, and parameter name
- ‚úÖ Edge cases covered: null, empty, whitespace, malformed, unknown, incompatible

### 5. Diagnostics (Optional/Future)
- ‚úÖ Cache statistics accessible via `CompositeParser` (already implemented in F-011)
- ‚è∏Ô∏è Unified diagnostics API deferred to F-013 (API Helpers) if user demand exists

---

## Technical Approach

### Phase 1: Bug Fixes (Critical Path)
**Fix CompositeParser null handling** (BLOCKING: causes test failure)

**File**: `src/Internal/Units/CompositeParser.cs`

**Current Bug**:
```csharp
public bool TryParse(string compositeUnit, out DimensionSignature signature, out decimal factor)
{
    // BUG: ConcurrentDictionary.TryGetValue throws on null key
    if (_parseCache.TryGetValue(compositeUnit, out var cachedResult))
    {
        // ...
    }
}
```

**Fix**:
```csharp
public bool TryParse(string compositeUnit, out DimensionSignature signature, out decimal factor)
{
    // Guard against null/empty input
    if (string.IsNullOrWhiteSpace(compositeUnit))
    {
        signature = DimensionSignature.Dimensionless;
        factor = 1m;
        return false;
    }
    
    // Check cache (now safe)
    if (_parseCache.TryGetValue(compositeUnit, out var cachedResult))
    {
        // ...
    }
}
```

### Phase 2: Message Standardization
**Audit and standardize all error messages**

**Current State Analysis** (from code review):
| Location | Current Message | Status | Action Needed |
|----------|----------------|--------|---------------|
| Quantity.cs:79 | "Unknown or malformed unit..." | ‚úÖ Good | None |
| Quantity.cs:142 | "Unknown or malformed unit..." | ‚úÖ Good | None |
| Quantity.cs:493 | "Cannot add quantities of incompatible units." | ‚ö†Ô∏è Good but could add context | Enhance with unit types |
| Quantity.cs:699 | "Cannot divide integers by quantities with units" | ‚ö†Ô∏è Inconsistent capitalization | Standardize |
| UnitDefinitions.cs:68 | "No matching unit X was found." | ‚ö†Ô∏è Lacks guidance | Add next steps |
| Rational.cs:29 | "Denominator cannot be zero." | ‚úÖ Good | None |

**Standardization Rules**:
1. **Sentence structure**: "Cannot [action]. [Reason]. [Optional guidance]."
2. **Terminology**: Always use: Quantity, Unit, Catalog, Composite, Dimension, Signature
3. **Capitalization**: Full sentences with proper punctuation
4. **Context**: Include actual values when helpful (use string interpolation safely)
5. **Guidance**: When possible, tell user how to fix or check

### Phase 3: Test Coverage Expansion
**Ensure every error path is tested**

**Current Test Coverage** (from code review):
- ‚úÖ Format exceptions: `QuantityFormatCompositeTests.cs` (well covered)
- ‚úÖ UnitToken validation: `UnitTokenTests.cs` (well covered)
- ‚úÖ Incompatible operations: `QuantityOperatorTests.cs` (partial coverage)
- ‚ö†Ô∏è Null handling: Missing tests in several areas
- ‚ö†Ô∏è Message content: Not explicitly verified

**New Tests Needed**:
1. Verify error messages contain expected keywords
2. Test all TryParse null/empty scenarios
3. Test incompatible operations across all operators
4. Test divide-by-zero in all contexts (Rational, DimensionalMath, Quantity operators)

**Test Pattern**:
```csharp
[Test]
public void Constructor_NullUnit_ThrowsArgumentNullException()
{
    // Arrange & Act & Assert
    var ex = Assert.Throws<ArgumentNullException>(() => new Quantity(10, null));
    Assert.That(ex.ParamName, Is.EqualTo("unit"));
}

[Test]
public void Add_IncompatibleUnits_ThrowsInvalidOperationExceptionWithContext()
{
    // Arrange
    var length = Quantity.Parse("10 m");
    var mass = Quantity.Parse("5 kg");
    
    // Act & Assert
    var ex = Assert.Throws<InvalidOperationException>(() => _ = length + mass);
    Assert.That(ex.Message, Does.Contain("incompatible"));
    Assert.That(ex.Message, Does.Contain("Length"));
    Assert.That(ex.Message, Does.Contain("Mass"));
}
```

---

## Exception Type Standards

| Scenario | Exception Type | When to Use |
|----------|---------------|-------------|
| Null parameter | `ArgumentNullException` | Parameter is null |
| Empty/whitespace string | `ArgumentException` | String is empty or whitespace |
| Unknown/malformed unit | `ArgumentException` | Unit not in catalog and not valid composite |
| Incompatible operation | `InvalidOperationException` | Adding Length to Mass, etc. |
| Malformed composite syntax | `FormatException` | Composite parsing fails structurally |
| Division by zero | `DivideByZeroException` | Dividing by zero value |

---

## Ubiquitous Language in Error Messages

**Always Use These Terms**:
- ‚úÖ Quantity (not "value", "number", "amount")
- ‚úÖ Unit (not "unit of measure", "UOM")
- ‚úÖ Catalog (not "definition", "lookup")
- ‚úÖ Composite (not "complex", "compound", "derived")
- ‚úÖ Signature (not "dimension vector", "exponents")
- ‚úÖ Dimension (not "dimension type", "unit type")

**Examples**:
```csharp
// Good
"Unit must be either a valid catalog unit or a composite unit."

// Bad
"Unit must be in the definition list or be a compound unit."
```

---

## Out of Scope

- ‚ùå Custom exception types (use standard .NET exceptions)
- ‚ùå Localization of error messages (English only for now)
- ‚ùå Structured logging framework (library context, consumers handle logging)
- ‚ùå Error recovery mechanisms (fail-fast philosophy)
- ‚ùå Exception wrapping/chaining (keep exception hierarchy simple)

---

## Dependencies

### Consumes
- **F-011**: Uses cache statistics already implemented in CompositeParser

### Enables
- **F-013**: API Helpers may expose diagnostics as public API if user demand exists

---

## Testing Strategy

### Unit Tests
**Target**: All exception paths in domain logic

**Naming Convention**: `MethodName_Condition_ExpectedResult()`

**Coverage Goals**:
- 100% of `throw` statements covered
- All TryParse methods tested with null/empty/invalid inputs
- All operators tested with incompatible operands

**Test Categories**:
1. **Validation Tests**: Null, empty, whitespace, malformed, unknown
2. **Operation Tests**: Incompatible add/sub, divide-by-zero
3. **Message Tests**: Verify error text contains expected context

### Integration Tests
**Target**: End-to-end error scenarios

**Examples**:
- Parse invalid composite ‚Üí catch exception ‚Üí verify message
- Multiply incompatible quantities ‚Üí verify dimensional error
- Format to incompatible target ‚Üí verify dimension error

---

## Breaking Changes

‚úÖ **NONE** - This feature is 100% backwards compatible

**Why No Breaking Changes**:
1. Exception types unchanged (still standard .NET exceptions)
2. Error messages enhanced, not removed
3. Null handling fix only affects broken scenarios
4. Tests may need updates if they assert exact message text

**Migration Guide**: Not needed (backwards compatible)

---

## Documentation Updates

### XML Comments
- ‚úÖ Ensure all public APIs document their `<exception>` tags
- ‚úÖ Include exception type, condition, and parameter name

**Example**:
```csharp
/// <summary>
/// Creates a Quantity with the specified value and unit.
/// </summary>
/// <param name="value">The numeric value of the quantity.</param>
/// <param name="unit">The unit of measure (catalog or composite).</param>
/// <exception cref="ArgumentNullException">Thrown when <paramref name="unit"/> is null.</exception>
/// <exception cref="ArgumentException">Thrown when <paramref name="unit"/> is empty, whitespace, or contains unknown base units.</exception>
/// <exception cref="FormatException">Thrown when composite unit syntax is malformed.</exception>
public Quantity(decimal value, string unit)
```

### CHANGELOG.md
Add entry:
```markdown
## [version] - [date]

### Fixed
- Fixed null input handling in `CompositeParser.TryParse()` (F-012)
- Standardized error messages across all exception types (F-012)

### Improved
- Enhanced exception messages with actionable guidance (F-012)
- Added comprehensive test coverage for all error scenarios (F-012)
```

### Contributor Guidelines
- Document error handling patterns for future contributors
- Include examples of good vs. bad error messages

---

## Files to Modify

### Critical (Phase 1)
- `src/Internal/Units/CompositeParser.cs` (null guard)

### Message Standardization (Phase 2)
- `src/Quantity.cs` (~15 throw statements)
- `src/UnitDefinitions.cs` (1 throw)
- `src/Internal/Rational.cs` (3 throws)
- `src/Internal/Units/UnitResolver.cs` (~4 throws)
- `src/Internal/Units/DimensionalMath.cs` (1 throw)
- `src/Internal/Units/CompositeFormatter.cs` (1 throw)
- `src/Internal/Units/UnitToken.cs` (2 throws)
- `src/Internal/Units/PreferredUnit.cs` (2 throws)

### Test Enhancement (Phase 3)
- `tests/CompositeParserTests.cs` (verify null test passes)
- `tests/QuantityTests.cs` (add missing null/empty tests)
- `tests/QuantityOperatorTests.cs` (enhance incompatible operation tests)
- Various test files (add message content assertions)

### Documentation (Phase 4)
- `docs/CHANGELOG.md` (add F-012 entry)
- `src/**/*.cs` (XML comments for exceptions)

---

## Quality Gates

### Before Committing
- [ ] All tests pass (including `TryParse_NullInput_ReturnsFalse`)
- [ ] Every throw statement has a test
- [ ] All error messages follow standard format
- [ ] All error messages use ubiquitous language
- [ ] XML `<exception>` tags updated

### Before PR Merge
- [ ] Code review passed
- [ ] CHANGELOG.md updated
- [ ] Build succeeds with zero warnings related to changes
- [ ] Test coverage at 100% for exception paths

---

## Quality Checklist

### Domain Design Validation
- ‚úÖ I have verified that error handling respects value object immutability
- ‚úÖ I have confirmed consistent terminology in all error messages
- ‚úÖ I have verified SOLID principles, especially SRP for exception handling
- ‚úÖ I have validated that domain validation rules are enforced at boundaries

### Implementation Quality Validation
- ‚úÖ I have written comprehensive tests using `MethodName_Condition_ExpectedResult()` naming
- ‚úÖ I have considered performance (exceptions are expensive, but correctness first)
- ‚úÖ I have implemented null checks at all public API boundaries
- ‚úÖ I have documented all exceptions in XML comments

### Error Handling Validation
- ‚úÖ I have used specific exception types appropriate to each scenario
- ‚úÖ I have ensured error messages are clear, consistent, and actionable
- ‚úÖ I have verified no sensitive data or implementation details leak in messages
- ‚úÖ I have tested all error paths with explicit assertions on exception content

---

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| Changing error messages breaks consumer code parsing messages | Low | Medium | Document that consumers should catch exception types, not parse messages |
| Performance impact of additional validation | Low | Low | Guards are cheap; fail-fast reduces wasted work |
| Test brittleness from message assertions | Medium | Low | Assert on keywords/patterns, not exact text |

---

## Timeline

**Estimated Effort**: 1‚Äì2 days

**Breakdown**:
- Day 1 AM: Fix critical null handling bug, run tests
- Day 1 PM: Audit and standardize error messages
- Day 2 AM: Write missing tests, ensure 100% exception coverage
- Day 2 PM: Update documentation, final verification

---

## Success Metrics

### Objective Measures
- ‚úÖ Test suite passes 100% (including fixed `TryParse_NullInput_ReturnsFalse`)
- ‚úÖ Zero `throw` statements without corresponding test
- ‚úÖ All public APIs have `<exception>` XML documentation

### Subjective Measures
- ‚úÖ Error messages reviewed and deemed clear/helpful by team
- ‚úÖ Consistent terminology verified across all messages
- ‚úÖ Exception handling patterns documented for contributors

---

## References

### Internal
- **E-001**: Epic defining F-012 scope and dependencies
- **F-011**: Performance & Caching (provides cache stats for diagnostics)
- **F-013**: API Helpers (may consume diagnostics)

### External
- **.NET Exception Best Practices**: https://learn.microsoft.com/en-us/dotnet/standard/exceptions/best-practices-for-exceptions
- **Fail-Fast Principle**: https://enterprisecraftsmanship.com/posts/fail-fast-principle/
- **Defensive Programming**: Guard clauses and validation patterns

---

## Open Questions

### Q1: Should we expose cache statistics publicly?
**Context**: F-011 implemented cache stats internally. Should we surface these?

**Options**:
- **A**: Keep internal; defer to F-013 (API Helpers) if user demand exists
- **B**: Expose simple `GetCacheStats()` method now

**Decision**: **Option A** (defer to F-013). Rationale:
- Follows YAGNI principle
- Keeps F-012 focused on error handling
- F-013 can design comprehensive diagnostics API with user input

### Q2: Should we create custom exception types?
**Context**: Currently using standard .NET exceptions. Should we add `TareException`, `IncompatibleUnitsException`, etc.?

**Options**:
- **A**: Use standard .NET exceptions (current approach)
- **B**: Create custom exception hierarchy

**Decision**: **Option A** (standard exceptions). Rationale:
- Standard exceptions well-understood by .NET developers
- Reduces API surface and maintenance burden
- Consumers can catch specific types or base `Exception`
- Custom types not needed for current scenarios

---

## Decisions Recorded

1. **Null Handling Strategy** (2025-11-11): All `TryParse` methods return `false` for null/empty input without throwing. All constructors and direct methods throw `ArgumentNullException` for null inputs.

2. **Error Message Format** (2025-11-11): Standardize on "Cannot [action]. [Reason]. [Optional guidance]." format with full sentences and proper punctuation.

3. **Diagnostics Exposure** (2025-11-11): Defer public diagnostics API to F-013. Keep F-011 cache stats internal for now.

4. **Exception Types** (2025-11-11): Use standard .NET exceptions. No custom exception hierarchy needed at this time.
