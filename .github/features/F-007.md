# F-007: Operators Integration

**Status**: Planned  
**Priority**: P1 (Must)  
**Effort**: M (1.5–2 days)  
**Epic**: E-001 — Option A Hybrid Core  
**Dependencies**: F-002 (Dimension Signature Model), F-003 (Unit Normalization), F-004 (Dimensional Math Engine), F-005 (Known-Signature Naming Map), F-006 (Composite Unit Formatter)

---

## Feature Overview

This feature integrates the dimensional algebra engine with `Quantity`'s multiplication and division operators, enabling full cross-unit arithmetic operations. After this feature, multiplying or dividing quantities with different units will produce dimensionally correct results with proper unit naming, rather than throwing exceptions.

### User Story

**As a** Tare library user performing engineering calculations  
**I want** to multiply and divide quantities with different units (e.g., force × distance, area ÷ length)  
**So that** I can perform dimensional algebra and get results with correct units (e.g., "Nm" for torque, "m" for area÷length)

### Context

F-007 is the seventh feature in the E-001 epic implementing Option A (Hybrid Core). It builds on:
- **F-002**: Dimension signature model for representing dimensional compositions
- **F-003**: Unit normalization and alias resolver for converting units to canonical forms
- **F-004**: Dimensional math engine that performs signature and factor calculations
- **F-005**: Known-signature naming map for resolving preferred unit names
- **F-006**: Composite unit formatter for generating unit strings when signatures are unknown

This feature wires the complete dimensional algebra stack into the public `Quantity` API, replacing the current limited operators that throw exceptions for cross-unit operations.

**Current Behavior** (to be replaced):
```csharp
var force = new Quantity(10, "N");
var distance = new Quantity(2, "m");
var result = force * distance; // Throws: "Cannot multiply quantities with units"
```

**New Behavior** (after F-007):
```csharp
var force = new Quantity(10, "N");
var distance = new Quantity(2, "m");
var torque = force * distance; // Returns: Quantity(20, "Nm")
```

---

## Mandatory Thinking Process (DDD/.NET Guidelines)

### 1. Domain Analysis (REQUIRED)

#### Domain Concepts Involved

- **Dimensional Multiplication**: Combining two quantities by multiplying their values and adding their dimensional exponents (e.g., Force × Length = Torque)
- **Dimensional Division**: Dividing two quantities by dividing their values and subtracting their dimensional exponents (e.g., Area ÷ Length = Length)
- **Unit Cancellation**: When dividing compatible units, dimensions cancel to produce a scalar (e.g., Length ÷ Length = Scalar)
- **Scalar Preservation**: Multiplying or dividing by a dimensionless quantity preserves the other quantity's units
- **Result Naming**: Using known signatures or composite formatting to name the resulting unit
- **Backward Compatibility**: Existing scalar operations and same-unit division must continue working unchanged

#### Aggregate Boundaries and Consistency Requirements

- **Value Objects**: 
  - `Quantity` — Existing public readonly struct (modified operators only)
  - `DimensionSignature` — Internal signature from F-002 (consumed)
  - `DimensionalResult` — Internal result from F-004 (consumed)
  - `PreferredUnit` — Internal naming from F-005 (consumed)
- **Domain Services**: 
  - `IDimensionalMath` — Interface for dimensional operations (consumed via F-004)
  - `IKnownSignatureMap` — Interface for signature resolution (consumed via F-005)
  - `ICompositeFormatter` — Interface for fallback formatting (consumed via F-006)
- **Consistency**: 
  - Operators remain value operations (no side effects)
  - Results are new `Quantity` instances (immutability preserved)
  - Existing behavior for scalars and same-unit division unchanged

#### Ubiquitous Language Terms

- **Dimensional Algebra**, **Multiplication Operator**, **Division Operator**, **Unit Cancellation**, **Signature Resolution**, **Composite Fallback**, **Scalar Quantity**, **Result Naming**

#### Business Rules and Invariants

- **Dimensional Correctness**: Multiplication adds exponents, division subtracts exponents
- **Scalar Identity**: Scalar × Quantity = Quantity, Scalar ÷ Scalar = Scalar
- **Unit Cancellation**: Same unit types divide to produce scalars
- **Result Naming Priority**: Known signature names preferred over composite strings
- **Backward Compatibility**: Existing tests and behaviors must remain unchanged
- **Immutability**: Operators return new instances; never mutate operands

### 2. Architecture Review (REQUIRED)

#### Layer Responsibilities

- **Domain Layer**: 
  - Modify `Quantity` operators to route cross-unit operations to dimensional engine
  - Preserve existing scalar operations and compatibility checks
  - Delegate naming to signature map and composite formatter
- **Integration Points**:
  - Calls `IDimensionalMath.Multiply()` and `IDimensionalMath.Divide()` from F-004
  - Calls `IKnownSignatureMap.TryGetPreferredUnit()` from F-005
  - Calls `ICompositeFormatter.Format()` from F-006 as fallback
  - Maintains compatibility with existing `UnitDefinitions` and `Extensions`

#### SOLID Principles Adherence

- **SRP**: `Quantity` operators focus on delegation; dimensional logic in dedicated services
- **OCP**: Operators extensible via internal services without modifying operator signatures
- **LSP**: Operator contracts unchanged; all existing behaviors preserved
- **ISP**: Operators depend only on minimal service interfaces needed for their operations
- **DIP**: Operators depend on abstractions (`IDimensionalMath`, etc.) not concrete implementations

#### Domain Events

- N/A — Operators are pure value operations with no side effects

#### Security Implications

- No user input validation needed (unit strings already validated by `Quantity` constructor)
- Deterministic behavior prevents timing attacks
- No external dependencies or I/O operations
- Immutable operations prevent mutation attacks

### 3. Implementation Planning (REQUIRED)

#### Files to Create/Modify

| File | Type | Justification |
|------|------|---------------|
| `src/Quantity.cs` | Modified | Update `operator *` and `operator /` to wire dimensional engine |
| `tests/QuantityOperatorTests.cs` | Modified | Add comprehensive dimensional algebra tests |
| `tests/QuantityOperatorBackCompatTests.cs` | New | Validate all existing behaviors remain unchanged |
| `docs/CHANGELOG.md` | Modified | Document new capability and breaking change removal |

#### Test Cases (Following `MethodName_Condition_ExpectedResult()` Pattern)

**Dimensional Multiplication:**
- `Multiply_LengthByLength_ReturnsArea()`
- `Multiply_LengthByLengthByLength_ReturnsVolume()`
- `Multiply_ForceByLength_ReturnsTorque()`
- `Multiply_MassByAcceleration_ReturnsForce()`
- `Multiply_ForceByVelocity_ReturnsPower()`
- `Multiply_DensityByVolume_ReturnsMass()`

**Dimensional Division:**
- `Divide_AreaByLength_ReturnsLength()`
- `Divide_VolumeByArea_ReturnsLength()`
- `Divide_TorqueByLength_ReturnsForce()`
- `Divide_PowerByForce_ReturnsVelocity()`
- `Divide_EnergyByTime_ReturnsPower()`

**Unit Cancellation:**
- `Divide_LengthByLength_ReturnsScalar()`
- `Divide_MassByMass_ReturnsScalar()`
- `Divide_InchByMeter_ReturnsScalar()` // Different units, same type
- `Divide_ForceByForce_ReturnsScalar()`

**Scalar Operations (Backward Compatibility):**
- `Multiply_ScalarByScalar_ReturnsScalar()`
- `Multiply_ScalarByQuantity_ReturnsQuantity()`
- `Multiply_QuantityByScalar_ReturnsQuantity()`
- `Divide_ScalarByScalar_ReturnsScalar()`
- `Divide_QuantityByScalar_ReturnsQuantity()`

**Known Signature Resolution:**
- `Multiply_NewtonByMeter_ReturnsNmNotComposite()`
- `Multiply_PoundForceByInch_ReturnsLbfInNotComposite()`
- `Divide_JouleBySecond_ReturnsWattNotComposite()`
- `Divide_NewtonBySquareMeter_ReturnsPascalNotComposite()`

**Composite Fallback:**
- `Multiply_UnknownSignature_ReturnsCompositeUnit()`
- `Divide_UnknownSignature_ReturnsCompositeUnit()`
- `Multiply_ComplexUnits_ProducesStableComposite()`

**Mixed Unit Systems:**
- `Multiply_SILength_USCustomaryForce_ProducesCorrectValue()`
- `Divide_USCustomaryArea_SILength_ProducesCorrectValue()`
- `Multiply_MeterByFoot_ProducesCorrectAreaValue()`

**Numeric Operators (Unchanged):**
- `Multiply_QuantityByDecimal_PreservesUnit()`
- `Multiply_QuantityByDouble_PreservesUnit()`
- `Multiply_QuantityByInt_PreservesUnit()`
- `Divide_QuantityByDecimal_PreservesUnit()`
- `Divide_QuantityByDouble_PreservesUnit()`
- `Divide_QuantityByInt_PreservesUnit()`

**Edge Cases:**
- `Multiply_VerySmallQuantities_MaintainsPrecision()`
- `Multiply_VeryLargeQuantities_MaintainsPrecision()`
- `Divide_ByNearZero_ThrowsException()`
- `Multiply_ZeroQuantity_ReturnsZero()`

#### Error Handling and Validation Strategy

- **Division by Zero**: Handled naturally by `decimal` division (throws `DivideByZeroException`)
- **Invalid Units**: Already validated by `Quantity` constructor; operators assume valid inputs
- **Overflow**: Let `decimal` overflow behavior propagate naturally
- **Null Handling**: Value type operators don't accept null; no null checks needed
- **Engine Failures**: Engine methods guaranteed to succeed for valid inputs; no try-catch needed

#### Performance and Scalability Considerations

- **Optimization**: Short-circuit scalar cases before calling engine
- **Caching**: Engine and maps cache internally; operators don't need caching layer
- **Allocations**: Minimize by reusing engine results directly
- **Hot Path**: Scalar operations remain fast path (unchanged)
- **Cold Path**: Cross-unit operations acceptable to be slower (rare in typical use)

---

## Detailed Implementation Design

### Current Operator Implementation (To Be Replaced)

```csharp
// Current implementation throws for cross-unit operations
public static Quantity operator *(Quantity q1, Quantity q2)
{
    if (q1.UnitType == UnitTypeEnum.Scalar && q2.UnitType == UnitTypeEnum.Scalar)
    {
        return new Quantity(q1.Value * q2.Value);
    }

    if (q1.UnitType == UnitTypeEnum.Scalar)
    {
        return new Quantity(q1.Value * q2.Value, q2.Unit);
    }

    if (q2.UnitType == UnitTypeEnum.Scalar)
    {
        return new Quantity(q1.Value * q2.Value, q1.Unit);
    }

    throw new InvalidOperationException("Cannot multiply quantities with units");
}

public static Quantity operator /(Quantity q1, Quantity q2)
{
    if (q1.UnitType == q2.UnitType)
    {
        //convert each quantity and return a scalar
        return ((q1.Factor * q1.Value) / (q2.Factor * q2.Value));
    }

    if (q2.UnitType == UnitTypeEnum.Scalar)
    {
        return new(q1.Value / q2.Value, q1.Unit);
    }

    throw new InvalidOperationException("Cannot divide quantities with units");
}
```

### New Operator Implementation (Dimensional Algebra Enabled)

```csharp
/// <summary>
/// Multiplies two specified Quantity values using dimensional algebra.
/// </summary>
/// <param name="q1">The first quantity.</param>
/// <param name="q2">The second quantity.</param>
/// <returns>The result of multiplying q1 by q2 with dimensional unit composition.</returns>
/// <remarks>
/// Supports:
/// - Scalar × Scalar → Scalar
/// - Scalar × Quantity → Quantity (preserves unit)
/// - Quantity × Scalar → Quantity (preserves unit)
/// - Quantity × Quantity → Quantity (dimensional algebra: adds signatures)
/// 
/// Examples:
/// - 10m × 5m → 50m²
/// - 10N × 2m → 20Nm (torque)
/// - 5kg × 2m/s² → 10N (force)
/// </remarks>
public static Quantity operator *(Quantity q1, Quantity q2)
{
    // Fast path: both scalars
    if (q1.UnitType == UnitTypeEnum.Scalar && q2.UnitType == UnitTypeEnum.Scalar)
    {
        return new Quantity(q1.Value * q2.Value);
    }

    // Fast path: scalar × quantity (preserve quantity's unit)
    if (q1.UnitType == UnitTypeEnum.Scalar)
    {
        return new Quantity(q1.Value * q2.Value, q2.Unit);
    }

    // Fast path: quantity × scalar (preserve quantity's unit)
    if (q2.UnitType == UnitTypeEnum.Scalar)
    {
        return new Quantity(q1.Value * q2.Value, q1.Unit);
    }

    // Dimensional algebra path: both have units
    var engine = DimensionalMath.Instance;
    var result = engine.Multiply(q1.Unit, q1.Value, q2.Unit, q2.Value);

    // Name the result using known signatures or composite fallback
    string resultUnit = ResolveUnitName(result.Signature);

    return new Quantity(result.Value, resultUnit);
}

/// <summary>
/// Divides two specified Quantity values using dimensional algebra.
/// </summary>
/// <param name="q1">The dividend quantity.</param>
/// <param name="q2">The divisor quantity.</param>
/// <returns>The result of dividing q1 by q2 with dimensional unit composition.</returns>
/// <remarks>
/// Supports:
/// - Scalar ÷ Scalar → Scalar
/// - Quantity ÷ Scalar → Quantity (preserves unit)
/// - Quantity ÷ Quantity (same unit type) → Scalar (unit cancellation)
/// - Quantity ÷ Quantity (different types) → Quantity (dimensional algebra: subtracts signatures)
/// 
/// Examples:
/// - 50m² ÷ 10m → 5m
/// - 10m ÷ 2s → 5m/s (velocity)
/// - 20Nm ÷ 5m → 4N (force)
/// - 100kg ÷ 50kg → 2 (scalar)
/// </remarks>
public static Quantity operator /(Quantity q1, Quantity q2)
{
    // Fast path: same unit types cancel to scalar
    if (q1.UnitType == q2.UnitType && q1.UnitType != UnitTypeEnum.Scalar)
    {
        // Convert to base units and divide (existing behavior preserved)
        return new Quantity((q1.Factor * q1.Value) / (q2.Factor * q2.Value));
    }

    // Fast path: both scalars
    if (q1.UnitType == UnitTypeEnum.Scalar && q2.UnitType == UnitTypeEnum.Scalar)
    {
        return new Quantity(q1.Value / q2.Value);
    }

    // Fast path: quantity ÷ scalar (preserve quantity's unit)
    if (q2.UnitType == UnitTypeEnum.Scalar)
    {
        return new Quantity(q1.Value / q2.Value, q1.Unit);
    }

    // Dimensional algebra path: cross-unit division
    var engine = DimensionalMath.Instance;
    var result = engine.Divide(q1.Unit, q1.Value, q2.Unit, q2.Value);

    // Check if result is dimensionless (unit cancellation across different unit types)
    if (result.Signature.IsDimensionless())
    {
        return new Quantity(result.Value);
    }

    // Name the result using known signatures or composite fallback
    string resultUnit = ResolveUnitName(result.Signature);

    return new Quantity(result.Value, resultUnit);
}

/// <summary>
/// Resolves a dimension signature to a preferred unit name.
/// </summary>
/// <param name="signature">The dimension signature to resolve.</param>
/// <returns>The preferred unit name or composite string.</returns>
/// <remarks>
/// Resolution priority:
/// 1. Known signature map (e.g., Force → "N", Torque → "Nm")
/// 2. Composite formatter fallback (e.g., "kg·m²/s²")
/// </remarks>
private static string ResolveUnitName(DimensionSignature signature)
{
    // Try known signature resolution first
    var knownMap = KnownSignatureMap.Instance;
    if (knownMap.TryGetPreferredUnit(signature, out var preferredUnit))
    {
        return preferredUnit.CanonicalName;
    }

    // Fallback to composite formatting
    var formatter = CompositeFormatter.Instance;
    return formatter.Format(signature);
}
```

**Design Notes**:
- **Fast Paths**: Scalar operations remain unchanged for performance
- **Same-Unit Division**: Existing behavior preserved for backward compatibility
- **Engine Integration**: Dimensional algebra only invoked for cross-unit operations
- **Naming Strategy**: Known signatures preferred, composite as fallback
- **Immutability**: All operations return new `Quantity` instances

---

## Operator Behavior Matrix

### Multiplication Truth Table

| Left Type | Right Type | Behavior | Example |
|-----------|------------|----------|---------|
| Scalar | Scalar | Scalar result | `2 × 3 → 6` |
| Scalar | Length | Length result | `2 × 5m → 10m` |
| Length | Scalar | Length result | `5m × 2 → 10m` |
| Length | Length | Area result | `5m × 4m → 20m²` |
| Force | Length | Torque result | `10N × 2m → 20Nm` |
| Mass | Acceleration | Force result | `5kg × 2m/s² → 10N` |

### Division Truth Table

| Left Type | Right Type | Behavior | Example |
|-----------|------------|----------|---------|
| Scalar | Scalar | Scalar result | `6 ÷ 3 → 2` |
| Length | Scalar | Length result | `10m ÷ 2 → 5m` |
| Length | Length | Scalar result (cancellation) | `10m ÷ 5m → 2` |
| Area | Length | Length result | `20m² ÷ 5m → 4m` |
| Torque | Length | Force result | `20Nm ÷ 5m → 4N` |
| Energy | Time | Power result | `100J ÷ 10s → 10W` |

---

## Specific Tasks

### Phase 1: Operator Replacement (Day 1, 3 hours)

- [ ] Backup current operator implementations (copy to comments for reference)
- [ ] Implement new `operator *` with dimensional algebra
  - [ ] Preserve scalar fast paths
  - [ ] Add dimensional engine integration
  - [ ] Add unit name resolution logic
  - [ ] Update XML documentation
- [ ] Implement new `operator /` with dimensional algebra
  - [ ] Preserve scalar fast paths
  - [ ] Preserve same-unit cancellation behavior
  - [ ] Add dimensional engine integration
  - [ ] Add unit name resolution logic
  - [ ] Handle dimensionless results
  - [ ] Update XML documentation
- [ ] Implement `ResolveUnitName` helper method
  - [ ] Try known signature resolution first
  - [ ] Fallback to composite formatting
  - [ ] Add XML documentation

### Phase 2: Backward Compatibility Testing (Day 1, 2-3 hours)

- [ ] Create `QuantityOperatorBackCompatTests.cs`
  - [ ] Test scalar × scalar unchanged
  - [ ] Test scalar × quantity unchanged
  - [ ] Test quantity × scalar unchanged
  - [ ] Test same-unit division unchanged (length÷length → scalar)
  - [ ] Test quantity ÷ scalar unchanged
  - [ ] Test numeric operators unchanged (×decimal, ×double, ×int, ÷decimal, etc.)
- [ ] Run all existing tests
  - [ ] Verify all existing operator tests pass
  - [ ] Identify any broken tests (should be tests for the exception cases)
  - [ ] Update or remove tests that expect exceptions

### Phase 3: Dimensional Algebra Testing (Day 2, 3-4 hours)

- [ ] Add dimensional multiplication tests
  - [ ] Length × Length → Area
  - [ ] Force × Length → Torque (known signature)
  - [ ] Mass × Acceleration → Force (known signature)
  - [ ] Complex unknown signatures → composite strings
  - [ ] Mixed unit systems (SI × US Customary)
- [ ] Add dimensional division tests
  - [ ] Area ÷ Length → Length
  - [ ] Torque ÷ Length → Force (known signature)
  - [ ] Energy ÷ Time → Power (known signature)
  - [ ] Complex unknown signatures → composite strings
  - [ ] Mixed unit systems
- [ ] Add unit cancellation tests
  - [ ] Length ÷ Length → Scalar
  - [ ] Different length units ÷ each other → Scalar
  - [ ] Force ÷ Force → Scalar
  - [ ] Cross-dimensional cancellation
- [ ] Add precision tests
  - [ ] Small values maintain precision
  - [ ] Large values maintain precision
  - [ ] Chained operations accumulate correctly
- [ ] Add edge case tests
  - [ ] Zero quantities
  - [ ] Very small and very large values
  - [ ] Composite result stability (same operation → same string)

### Phase 4: Integration Validation (Day 2, 1-2 hours)

- [ ] Integration smoke tests
  - [ ] Test complete workflow: parse → multiply → format
  - [ ] Test complete workflow: parse → divide → format
  - [ ] Test chained operations: `(force × distance) ÷ time`
  - [ ] Test mixed operations: `(length × length) / length`
- [ ] Real-world scenario tests
  - [ ] Physics calculations (force, energy, power)
  - [ ] Engineering calculations (stress, strain, torque)
  - [ ] Unit conversion chains
- [ ] Update CHANGELOG.md
  - [ ] Document new capability (dimensional algebra enabled)
  - [ ] Document breaking change removal (exceptions removed)
  - [ ] Provide migration examples
  - [ ] Note backward compatibility preservation
- [ ] Update XML documentation
  - [ ] Operator documentation reflects new capabilities
  - [ ] Examples show dimensional algebra
  - [ ] Remarks explain behavior for different input types

---

## Acceptance Criteria

### Functional Requirements

✅ **AC-1**: Multiplying two length quantities produces an area quantity  
✅ **AC-2**: Dividing an area by a length produces a length quantity  
✅ **AC-3**: Multiplying force by distance produces torque with "Nm" unit  
✅ **AC-4**: Dividing energy by time produces power with "W" unit  
✅ **AC-5**: Dividing two quantities of the same unit type produces a scalar  
✅ **AC-6**: Unknown signatures fallback to composite formatting  
✅ **AC-7**: Scalar operations remain unchanged (backward compatibility)  
✅ **AC-8**: Same-unit division remains unchanged (backward compatibility)  
✅ **AC-9**: Numeric operators remain unchanged (×decimal, ÷int, etc.)  
✅ **AC-10**: Mixed SI and US Customary units compute correctly

### Quality Requirements

✅ **AC-11**: All tests follow `MethodName_Condition_ExpectedResult()` naming convention  
✅ **AC-12**: All existing operator tests continue to pass  
✅ **AC-13**: Test coverage ≥85% for modified operators  
✅ **AC-14**: No new public API surface added (internal integration only)  
✅ **AC-15**: Builds successfully on both `netstandard2.0` and `net7.0` TFMs  
✅ **AC-16**: No compiler warnings related to modified code  
✅ **AC-17**: XML documentation updated for operator behavior

### Non-Functional Requirements

✅ **AC-18**: Scalar operations maintain current performance (no regression)  
✅ **AC-19**: Immutability preserved (operators return new instances)  
✅ **AC-20**: Thread-safe (pure functions, no shared mutable state)  
✅ **AC-21**: Deterministic results (same inputs → same outputs)  
✅ **AC-22**: CHANGELOG.md updated with capability and migration notes  
✅ **AC-23**: No exceptions thrown for cross-unit operations (behavior change)

### Integration Requirements

✅ **AC-24**: Integrates with `IDimensionalMath` from F-004  
✅ **AC-25**: Integrates with `IKnownSignatureMap` from F-005  
✅ **AC-26**: Integrates with `ICompositeFormatter` from F-006  
✅ **AC-27**: Compatible with existing `UnitDefinitions` and parsing  
✅ **AC-28**: Works with both SI and US Customary unit systems

---

## Test Plan

### Test Organization

**Test Files**:
- `tests/QuantityOperatorTests.cs` — Existing tests (modified to add dimensional algebra)
- `tests/QuantityOperatorBackCompatTests.cs` — New file for backward compatibility validation
- `tests/QuantityDimensionalAlgebraTests.cs` — New file for comprehensive dimensional tests

**Test Framework**: xUnit (consistent with existing test structure)  
**Test Categories**: 
- Unit tests for operator behavior
- Integration tests for complete workflows
- Backward compatibility tests for regression prevention

### Test Coverage Matrix

| Category | Test Count | Focus Areas |
|----------|------------|-------------|
| Backward Compatibility | 12 | Scalar ops, same-unit division, numeric ops unchanged |
| Dimensional Multiplication | 10 | Cross-unit multiplication, known signatures, composites |
| Dimensional Division | 10 | Cross-unit division, known signatures, composites |
| Unit Cancellation | 6 | Same type division, cross-unit cancellation |
| Mixed Unit Systems | 5 | SI × US Customary combinations |
| Precision & Edge Cases | 8 | Small/large values, zero, chains |
| Integration Workflows | 6 | End-to-end scenarios, chained operations |
| **Total** | **57** | **Comprehensive coverage** |

---

## Dependencies

### Upstream Dependencies (Required)

- **F-002**: `DimensionSignature` model with add/subtract operations
  - Provides signature structure and operations for dimensional algebra
- **F-003**: Unit normalization and alias resolver
  - Enables resolving unit strings to canonical forms and base factors
- **F-004**: `IDimensionalMath` engine implementation
  - Provides `Multiply()` and `Divide()` operations with signature calculations
- **F-005**: `IKnownSignatureMap` implementation
  - Provides preferred unit names for known signatures
- **F-006**: `ICompositeFormatter` implementation
  - Provides fallback formatting for unknown signatures

**Critical**: All upstream features must be complete, tested, and stable before starting F-007.

### Downstream Consumers (Will Benefit From This)

- **F-008**: Format Extensions
  - Will leverage dimensional algebra for format conversions to composite units
- **F-009**: Optional Composite Construction
  - Will parse composite strings to enable `Quantity(10, "lbf*in")` construction
- **F-015**: Precision & Formatting Integration
  - Will format dimensional algebra results with culture-aware number formatting
- **End Users**: All users performing engineering/physics calculations with Tare

---

## Risks and Mitigations

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Breaking existing code | Medium | High | Comprehensive backward compatibility tests; preserve all fast paths |
| Performance regression | Low | Medium | Profile scalar operations; maintain fast paths for common cases |
| Unexpected unit naming | Medium | Medium | Extensive test coverage for known signatures; validate against domain expectations |
| Precision loss in chains | Low | Medium | Test chained operations; validate cumulative precision |
| User confusion on behavior change | Medium | Low | Clear documentation; CHANGELOG migration guide; examples |

---

## Migration Notes

### Breaking Changes (Exceptions Removed)

**Before F-007** (throws exceptions):
```csharp
var force = new Quantity(10, "N");
var distance = new Quantity(2, "m");
var torque = force * distance; // InvalidOperationException: "Cannot multiply quantities with units"
```

**After F-007** (dimensional algebra):
```csharp
var force = new Quantity(10, "N");
var distance = new Quantity(2, "m");
var torque = force * distance; // Returns: Quantity(20, "Nm")
```

### Code Changes Required

**If your code currently catches `InvalidOperationException` for operator failures**, you can remove those catches:

```csharp
// OLD CODE (no longer needed)
try
{
    var result = quantity1 * quantity2;
}
catch (InvalidOperationException)
{
    // Handle incompatible units
}

// NEW CODE (works automatically)
var result = quantity1 * quantity2; // Always succeeds with dimensional algebra
```

### Backward Compatibility Preserved

The following behaviors remain **unchanged**:
- Scalar × Scalar → Scalar
- Scalar × Quantity → Quantity (preserves unit)
- Quantity × Scalar → Quantity (preserves unit)
- Quantity ÷ Scalar → Quantity (preserves unit)
- Same-UnitType ÷ Same-UnitType → Scalar (e.g., 10m ÷ 2m → 5)
- All numeric operators (×decimal, ×double, ×int, ÷decimal, ÷int, etc.)

---

## Integration Examples

### Basic Dimensional Algebra

```csharp
// Area calculation
var length = new Quantity(5, "m");
var width = new Quantity(3, "m");
var area = length * width; // Quantity(15, "m²")

// Volume calculation
var height = new Quantity(2, "m");
var volume = area * height; // Quantity(30, "m³")

// Back to area
var crossSection = volume / height; // Quantity(15, "m²")
```

### Physics Calculations

```csharp
// Force = mass × acceleration
var mass = new Quantity(10, "kg");
var acceleration = new Quantity(9.8, "m/s²");
var force = mass * acceleration; // Quantity(98, "N")

// Work/Energy = force × distance
var distance = new Quantity(5, "m");
var work = force * distance; // Quantity(490, "Nm") or "J"

// Power = energy / time
var time = new Quantity(2, "s");
var power = work / time; // Quantity(245, "W")
```

### Engineering Calculations

```csharp
// Torque = force × moment arm
var force = new Quantity(100, "lbf");
var momentArm = new Quantity(12, "in");
var torque = force * momentArm; // Quantity(1200, "lbf·in")

// Stress = force / area
var force = new Quantity(1000, "N");
var area = new Quantity(0.01, "m²");
var stress = force / area; // Quantity(100000, "Pa")

// Velocity = distance / time
var distance = new Quantity(100, "mi");
var time = new Quantity(2, "h");
var velocity = distance / time; // Quantity(50, "mi/h")
```

### Mixed Unit Systems

```csharp
// SI × US Customary
var siForce = new Quantity(10, "N");
var usDistance = new Quantity(12, "in");
var torque = siForce * usDistance; // Converts and computes correctly

// Result uses SI or composite depending on signature resolution
// Value is numerically correct regardless of unit systems
```

---

## Out of Scope

The following are explicitly NOT part of F-007:

❌ **Exponentiation Operator**: `Quantity ^ int` for repeated multiplication (e.g., area = length²)  
❌ **Addition/Subtraction Changes**: These operators already work correctly and are unchanged  
❌ **Comparison Operators**: `<`, `>`, `<=`, `>=` unchanged by this feature  
❌ **Format Method Changes**: Handled by F-008 (Format Extensions)  
❌ **Composite Parsing**: Handled by F-009 (Optional Composite Construction)  
❌ **Performance Optimization**: Handled by F-010 (Performance & Caching)  
❌ **Public API Helpers**: Handled by F-012 (API Helpers)  
❌ **Culture-Aware Formatting**: Handled by F-015 (Precision & Formatting Integration)

---

## Quality Checklist

### Domain Design Validation

- [ ] I have verified that operators correctly delegate to dimensional engine
- [ ] I have confirmed consistent terminology (multiplication, division, cancellation)
- [ ] I have verified SOLID principles adherence (SRP, DIP for delegation)
- [ ] I have validated dimensional algebra rules (exponent addition/subtraction)
- [ ] I have ensured immutability and value semantics preserved

### Implementation Quality Validation

- [ ] I have written comprehensive tests following `MethodName_Condition_ExpectedResult()` naming
- [ ] I have achieved ≥85% code coverage for modified operators
- [ ] I have validated all existing tests still pass
- [ ] I have created backward compatibility test suite
- [ ] I have documented all operator behaviors with XML comments

### Precision & Correctness Validation

- [ ] I have validated dimensional correctness (multiplication adds, division subtracts exponents)
- [ ] I have tested precision preservation in chained operations
- [ ] I have verified unit cancellation produces scalars correctly
- [ ] I have validated known signature resolution works as expected
- [ ] I have tested composite fallback produces stable strings

### Integration Readiness Validation

- [ ] I have verified integration with F-004 (DimensionalMath)
- [ ] I have verified integration with F-005 (KnownSignatureMap)
- [ ] I have verified integration with F-006 (CompositeFormatter)
- [ ] I have confirmed no regressions in existing functionality
- [ ] I have updated CHANGELOG with migration guidance

---

## Success Metrics

1. **Functionality**: All acceptance criteria met and validated
2. **Test Coverage**: ≥85% coverage for modified operators
3. **Backward Compatibility**: 100% of existing tests pass (minus exception tests)
4. **Performance**: Scalar operations show no regression (<5% slower)
5. **Quality**: Zero regressions in existing test suite
6. **Integration**: End-to-end workflows pass (parse → operate → format)

---

## Timeline

**Total Estimated Effort**: 1.5 - 2 days

- **Day 1 Morning**: Operator replacement and helper implementation (Phase 1) - 3 hours
- **Day 1 Afternoon**: Backward compatibility testing (Phase 2) - 2-3 hours
- **Day 2 Morning**: Dimensional algebra testing (Phase 3) - 3-4 hours
- **Day 2 Afternoon**: Integration validation and documentation (Phase 4) - 1-2 hours

**Note**: Timeline assumes F-002 through F-006 are complete, tested, and stable.

---

## References

### Internal References

- **E-001**: Epic — Option A Hybrid Core
- **F-002**: Dimension Signature Model (dependency)
- **F-003**: Unit Normalization and Alias Resolver (dependency)
- **F-004**: Dimensional Math Engine (dependency)
- **F-005**: Known-Signature Naming Map (dependency)
- **F-006**: Composite Unit Formatter (dependency)
- **F-008**: Format Extensions (consumer)
- **F-009**: Optional Composite Construction (consumer)

### External References

- **Dimensional Analysis (Wikipedia)**: https://en.wikipedia.org/wiki/Dimensional_analysis
- **SI Derived Units**: https://www.nist.gov/pml/owm/metric-si/si-derived-units
- **UCUM (Unified Code for Units of Measure)**: https://ucum.org/

---

## Open Questions

### Resolved Decisions

1. **Q**: Should we preserve the same-unit division fast path?  
   **A**: Yes, preserve for backward compatibility and performance. Users expect `10m / 5m → 2` (scalar).

2. **Q**: Should we short-circuit scalar operations?  
   **A**: Yes, scalar operations remain as fast paths. No need to invoke engine for scalar cases.

3. **Q**: How to handle dimensionless results from cross-unit division?  
   **A**: Check `IsDimensionless()` and return scalar `Quantity` without unit.

4. **Q**: What naming priority for results?  
   **A**: Known signatures first (via `KnownSignatureMap`), composite formatting as fallback.

### Open Questions for Review

1. **Q**: Should we log or track when composite fallback is used?  
   **Open**: Not for MVP. Could add telemetry/diagnostics in F-011 if needed.

2. **Q**: Should we provide a way to customize unit naming preferences per operation?  
   **Open**: Not for MVP. Unit system preferences handled at map level (F-005). Per-operation customization deferred.

3. **Q**: Should we add validation that engine results are non-null?  
   **Open**: Engine guaranteed to succeed for valid inputs. No validation needed initially; can add defensive checks if issues arise.

---

## Notes

- Operators remain the primary public API for dimensional algebra
- Internal wiring keeps implementation details hidden from users
- Backward compatibility is paramount; all existing behaviors preserved
- Known signature resolution provides domain-friendly unit names
- Composite formatting ensures all results are representable
- This feature completes the core dimensional algebra capability for E-001

---

## Revision History

| Version | Date | Author | Changes |
|---------|------|--------|---------|
| 1.0 | 2025-11-08 | Planning Team | Initial planning document created per user request |

---

**Ready for Review** ✅  
This planning document defines F-007 (Operators Integration) implementation strategy, following the structure and standards established in F-002 through F-006 planning documents. The feature wires the complete dimensional algebra stack into Quantity's multiplication and division operators, enabling full cross-unit arithmetic while preserving backward compatibility.
