# F-003: Unit Normalization and Alias Resolver

**Status**: Planned  
**Priority**: P1 (Must)  
**Effort**: M (1–2 days)  
**Epic**: E-001 — Option A Hybrid Core  
**Dependencies**: None (uses existing UnitDefinitions; prepares for F-004)

---

## Feature Overview

This feature delivers a unit normalization and alias resolution pipeline that standardizes unit representations across the Tare library. It leverages the existing `UnitDefinitions` catalog to map aliases to canonical unit tokens and compute exact base conversion factors, creating a foundation for dimensional algebra operations in F-004.

### User Story

**As a** Tare library maintainer developing dimensional algebra capabilities  
**I want** a normalization pipeline that resolves unit aliases and computes base factors  
**So that** operations like `Quantity("36 in") * Quantity("2 ft")` can identify that both use Length dimensions and convert to a common base before computing signatures

### Context

F-003 is the third feature in the E-001 epic implementing Option A (Hybrid Core). It bridges existing catalog-based parsing with the dimensional algebra engine planned in F-004. The normalization pipeline ensures that:
- Aliases like "inch"/"in"/"inches" normalize to the same canonical token
- Each unit's conversion factor to the dimension's base unit is computed
- Unit tokens are suitable for signature resolution and composite formatting

---

## Mandatory Thinking Process (DDD/.NET Guidelines)

### 1. Domain Analysis (REQUIRED)

#### Domain Concepts Involved

- **Unit**: A measure standard with a name, factor, and dimensional type (e.g., "meter", "inch", "pound force")
- **Alias**: Alternative names for the same unit (e.g., "in" = "inch" = "inches")
- **Canonical Token**: The normalized, unique identifier for a unit (e.g., "in" is canonical for inch aliases)
- **Base Unit**: The reference unit for a dimension (e.g., "m" for Length, "kg" for Mass)
- **Normalization**: The process of mapping any unit string (including aliases) to its canonical token
- **Resolution**: Computing the exact conversion factor from a unit to its dimension's base unit
- **Unit Family/Type**: A dimensional category (Length, Mass, Time, Force, Energy, etc.)

#### Aggregate Boundaries and Consistency Requirements

- **Value Objects**: 
  - `UnitToken` — Internal immutable identifier for normalized units
  - `NormalizedUnit` — Result of normalization containing token, factor, dimension signature
- **Domain Service**: 
  - `UnitResolver` — Stateless service providing normalization and resolution operations
- **Consistency**: 
  - Aliases must map uniquely to canonical tokens (no ambiguity)
  - Factors must be exact and deterministic (use `decimal`, preparing for F-001 `Rational` if needed)
  - Base unit for each dimension must be clearly defined

#### Ubiquitous Language Terms

- **Unit**, **Alias**, **Canonical Token**, **Base Unit**, **Factor**, **Normalize**, **Resolve**, **UnitType** (dimension family), **Signature** (dimensional composition from F-002)

#### Business Rules and Invariants

- **Uniqueness**: Each canonical token maps to exactly one unit definition
- **Alias Resolution**: All aliases for a unit resolve to the same canonical token
- **Factor Transitivity**: Factor from unit A → base → unit B equals direct factor from A → B
- **Case Insensitivity**: Unit resolution is case-insensitive (per existing Tare behavior)
- **Validation**: Unknown units throw informative exceptions (preserve existing error handling)

### 2. Architecture Review (REQUIRED)

#### Layer Responsibilities

- **Domain Layer**: 
  - `UnitToken` value object (internal)
  - `NormalizedUnit` value object (internal)
  - `IUnitResolver` interface (internal)
  - `UnitResolver` domain service implementation (internal)
- **Integration Points**:
  - Consumes `UnitDefinitions` catalog (existing)
  - Prepares data for `DimensionalMath` engine (F-004)
  - Used by `Quantity` operators (F-007)

#### SOLID Principles Adherence

- **SRP**: `UnitResolver` has single responsibility—normalize and resolve units to base factors
- **OCP**: Extensible to new units via `UnitDefinitions`; closed to modification of normalization logic
- **LSP**: N/A (no inheritance hierarchy)
- **ISP**: Interface focused on normalization/resolution operations only
- **DIP**: Depends on abstraction (`IUnitResolver`) rather than concrete implementation

#### Domain Events

- N/A — Normalization is a pure computational operation with no side effects

#### Security Implications

- No user credentials or sensitive data
- Input validation: unknown units throw exceptions (existing pattern)
- Deterministic behavior: no non-deterministic operations

### 3. Implementation Planning (REQUIRED)

#### Files to Create/Modify

| File | Type | Justification |
|------|------|---------------|
| `src/Internal/Units/UnitToken.cs` | New | Immutable value object for canonical unit identifiers |
| `src/Internal/Units/NormalizedUnit.cs` | New | Value object containing normalized token + factor + signature |
| `src/Internal/Units/IUnitResolver.cs` | New | Interface for normalization and resolution operations |
| `src/Internal/Units/UnitResolver.cs` | New | Domain service implementing normalization logic |
| `src/Internal/Units/BaseUnitMap.cs` | New | Static mapping of UnitType → base unit token |
| `tests/UnitResolverTests.cs` | New | Comprehensive unit tests for resolver |
| `tests/UnitTokenTests.cs` | New | Tests for UnitToken value object |
| `docs/CHANGELOG.md` | Modified | Document internal implementation note |

#### Test Cases (Following `MethodName_Condition_ExpectedResult()` Pattern)

**Alias Resolution:**
- `Normalize_InchWithVariousAliases_ResolveToSameCanonicalToken()`
- `Normalize_PoundForceWithAliases_ResolveToLbfToken()`
- `Normalize_CaseInsensitive_ResolveToCanonicalToken()`
- `Normalize_UnknownUnit_ThrowsArgumentException()`

**Base Factor Computation:**
- `Resolve_InchToMeter_ReturnsCorrectFactor()`
- `Resolve_FootToMeter_ReturnsCorrectFactor()`
- `Resolve_MileToMeter_ReturnsCorrectFactor()`
- `Resolve_PoundForceToNewton_ReturnsCorrectFactor()`
- `Resolve_BaseUnitToItself_ReturnsFactorOne()`

**Transitivity:**
- `Resolve_InchToFoot_MatchesDirectFactor()`
- `Resolve_ChainedConversions_MaintainsPrecision()`

**Edge Cases:**
- `Normalize_EmptyString_ThrowsArgumentException()`
- `Normalize_WhitespaceOnly_ThrowsArgumentException()`
- `Resolve_UnitWithoutDefinedBase_ThrowsInvalidOperationException()`

**Integration with UnitDefinitions:**
- `Normalize_AllDefinedUnits_ResolveSuccessfully()`
- `Resolve_AllDefinedUnits_HaveValidFactors()`

#### Error Handling and Validation Strategy

- **Unknown Units**: Throw `ArgumentException` with message: "Unknown unit: '{unit}'"
- **Invalid Input**: Throw `ArgumentException` for null, empty, or whitespace-only strings
- **Undefined Base**: Throw `InvalidOperationException` if a UnitType lacks a defined base unit
- **Clear Messages**: Follow existing Tare exception message patterns

#### Performance and Scalability Considerations

- **Caching Strategy**: 
  - Cache normalized tokens in `Dictionary<string, UnitToken>` (case-insensitive)
  - Cache resolved factors in `Dictionary<UnitToken, decimal>` per dimension
  - Defer comprehensive caching to F-010; start with simple memoization
- **Allocation Optimization**:
  - Use readonly structs for value objects
  - Avoid string allocations in hot paths (reuse tokens)
- **Lookup Efficiency**: O(1) dictionary lookups for both alias resolution and factor computation

---

## Detailed Implementation Design

### UnitToken Value Object

```csharp
namespace Tare.Internal.Units;

/// <summary>
/// Represents a normalized, canonical identifier for a unit.
/// Immutable value object ensuring unique representation across aliases.
/// </summary>
internal readonly struct UnitToken : IEquatable<UnitToken>
{
    /// <summary>
    /// Constructs a unit token from a canonical string.
    /// </summary>
    /// <param name="canonical">The canonical unit identifier (e.g., "in", "lbf", "m").</param>
    /// <exception cref="ArgumentException">Thrown when canonical is null, empty, or whitespace.</exception>
    public UnitToken(string canonical);
    
    /// <summary>
    /// Gets the canonical string representation of the unit.
    /// </summary>
    public string Canonical { get; }
    
    // IEquatable implementation
    public bool Equals(UnitToken other);
    public override bool Equals(object? obj);
    public override int GetHashCode();
    public static bool operator ==(UnitToken left, UnitToken right);
    public static bool operator !=(UnitToken left, UnitToken right);
    
    // String representation
    public override string ToString();
}
```

### NormalizedUnit Value Object

```csharp
namespace Tare.Internal.Units;

/// <summary>
/// Represents a fully normalized unit with its canonical token, base conversion factor,
/// and dimensional signature (when available).
/// </summary>
internal readonly struct NormalizedUnit
{
    /// <summary>
    /// Constructs a normalized unit.
    /// </summary>
    /// <param name="token">The canonical unit token.</param>
    /// <param name="factorToBase">Conversion factor to the dimension's base unit.</param>
    /// <param name="unitType">The unit type/dimension family.</param>
    public NormalizedUnit(UnitToken token, decimal factorToBase, UnitTypeEnum unitType);
    
    /// <summary>
    /// Gets the canonical unit token.
    /// </summary>
    public UnitToken Token { get; }
    
    /// <summary>
    /// Gets the conversion factor to the dimension's base unit.
    /// </summary>
    public decimal FactorToBase { get; }
    
    /// <summary>
    /// Gets the unit type (dimension family).
    /// </summary>
    public UnitTypeEnum UnitType { get; }
    
    /// <summary>
    /// Gets the dimension signature (added when F-002 is integrated).
    /// </summary>
    public DimensionSignature Signature { get; }
}
```

### IUnitResolver Interface

```csharp
namespace Tare.Internal.Units;

/// <summary>
/// Service interface for unit normalization and resolution operations.
/// </summary>
internal interface IUnitResolver
{
    /// <summary>
    /// Normalizes a unit string (including aliases) to its canonical token.
    /// </summary>
    /// <param name="unit">The unit string to normalize.</param>
    /// <returns>The canonical unit token.</returns>
    /// <exception cref="ArgumentException">Thrown when unit is unknown or invalid.</exception>
    UnitToken Normalize(string unit);
    
    /// <summary>
    /// Resolves a unit to its normalized representation with base conversion factor.
    /// </summary>
    /// <param name="unit">The unit string to resolve.</param>
    /// <returns>The normalized unit with token, factor, and dimension.</returns>
    /// <exception cref="ArgumentException">Thrown when unit is unknown or invalid.</exception>
    NormalizedUnit Resolve(string unit);
    
    /// <summary>
    /// Gets the base unit token for a given dimension type.
    /// </summary>
    /// <param name="unitType">The dimension type.</param>
    /// <returns>The base unit token for that dimension.</returns>
    UnitToken GetBaseUnit(UnitTypeEnum unitType);
    
    /// <summary>
    /// Checks if a unit string is valid (known in the catalog).
    /// </summary>
    /// <param name="unit">The unit string to check.</param>
    /// <returns>True if the unit is valid; false otherwise.</returns>
    bool IsValidUnit(string unit);
}
```

### UnitResolver Implementation

```csharp
namespace Tare.Internal.Units;

/// <summary>
/// Domain service providing unit normalization and resolution using the UnitDefinitions catalog.
/// </summary>
internal sealed class UnitResolver : IUnitResolver
{
    // Singleton instance (stateless service)
    public static readonly UnitResolver Instance = new UnitResolver();
    
    // Cached mappings (initialized lazily or at construction)
    private readonly Dictionary<string, UnitToken> _aliasToToken;
    private readonly Dictionary<UnitToken, UnitDefinition> _tokenToDefinition;
    private readonly Dictionary<UnitTypeEnum, UnitToken> _baseUnits;
    
    private UnitResolver()
    {
        // Initialize mappings from UnitDefinitions.Definitions
        // Build alias → canonical token map (case-insensitive)
        // Build token → definition map
        // Define base units per dimension
    }
    
    public UnitToken Normalize(string unit)
    {
        ArgumentNullException.ThrowIfNull(unit);
        if (string.IsNullOrWhiteSpace(unit))
            throw new ArgumentException("Unit cannot be empty or whitespace.", nameof(unit));
        
        // Lookup in alias map (case-insensitive)
        // Return canonical token or throw if unknown
    }
    
    public NormalizedUnit Resolve(string unit)
    {
        var token = Normalize(unit);
        var definition = _tokenToDefinition[token];
        var baseToken = GetBaseUnit(definition.UnitType);
        var factorToBase = ComputeFactorToBase(token, baseToken, definition);
        
        // When F-002 is integrated, compute signature here
        return new NormalizedUnit(token, factorToBase, definition.UnitType);
    }
    
    public UnitToken GetBaseUnit(UnitTypeEnum unitType)
    {
        if (!_baseUnits.TryGetValue(unitType, out var baseToken))
            throw new InvalidOperationException($"No base unit defined for {unitType}");
        
        return baseToken;
    }
    
    public bool IsValidUnit(string unit)
    {
        if (string.IsNullOrWhiteSpace(unit))
            return false;
        
        return _aliasToToken.ContainsKey(unit.ToLowerInvariant());
    }
    
    private decimal ComputeFactorToBase(UnitToken token, UnitToken baseToken, UnitDefinition definition)
    {
        // If token is already the base unit, factor is 1
        if (token == baseToken)
            return 1m;
        
        // Otherwise, use definition.Factor (which represents conversion to base)
        return definition.Factor;
    }
}
```

### BaseUnitMap Configuration

```csharp
namespace Tare.Internal.Units;

/// <summary>
/// Static mapping of dimension types to their base units.
/// Base units are the reference for each dimensional family.
/// </summary>
internal static class BaseUnitMap
{
    // SI base units for each dimension
    public static readonly Dictionary<UnitTypeEnum, string> BaseUnits = new()
    {
        { UnitTypeEnum.Length, "m" },           // meter
        { UnitTypeEnum.Mass, "kg" },            // kilogram
        { UnitTypeEnum.Time, "s" },             // second
        { UnitTypeEnum.Area, "m²" },            // square meter (derived, but serves as base)
        { UnitTypeEnum.Volume, "m³" },          // cubic meter (derived)
        { UnitTypeEnum.Force, "N" },            // newton (derived: kg⋅m/s²)
        { UnitTypeEnum.Energy, "J" },           // joule (derived: N⋅m)
        { UnitTypeEnum.Pressure, "Pa" },        // pascal (derived: N/m²)
        { UnitTypeEnum.Power, "W" },            // watt (derived: J/s)
        { UnitTypeEnum.Temperature, "K" },      // kelvin (SI base)
        { UnitTypeEnum.Angle, "rad" },          // radian
        // Add other types as needed
    };
}
```

---

## Task Breakdown

### Phase 1: Value Objects and Infrastructure (3-4 hours)

- [ ] Create `src/Internal/Units/` directory structure (if not exists)
- [ ] Implement `UnitToken` value object
  - [ ] Constructor with validation
  - [ ] `IEquatable<UnitToken>` implementation
  - [ ] `GetHashCode()` and equality operators
  - [ ] `ToString()` for debugging
- [ ] Implement `NormalizedUnit` value object
  - [ ] Constructor
  - [ ] Properties (Token, FactorToBase, UnitType)
  - [ ] Placeholder for Signature (F-002 integration point)
- [ ] Create `BaseUnitMap` static configuration
  - [ ] Define base units for all existing `UnitTypeEnum` values
  - [ ] Validate against current UnitDefinitions catalog
- [ ] Write tests for `UnitToken`
  - [ ] Construction tests
  - [ ] Equality tests
  - [ ] Hash code tests

**Validation**: UnitToken and NormalizedUnit tests pass; base unit map is complete.

### Phase 2: UnitResolver Service Implementation (4-5 hours)

- [ ] Define `IUnitResolver` interface
- [ ] Implement `UnitResolver` class
  - [ ] Constructor: build alias map from `UnitDefinitions.Definitions`
  - [ ] `Normalize(string unit)` method
  - [ ] `Resolve(string unit)` method
  - [ ] `GetBaseUnit(UnitTypeEnum unitType)` method
  - [ ] `IsValidUnit(string unit)` method
  - [ ] Private helper: `ComputeFactorToBase()`
- [ ] Handle case-insensitive lookups (use `StringComparer.OrdinalIgnoreCase`)
- [ ] Error handling for unknown units and invalid input
- [ ] Singleton pattern for stateless service

**Validation**: UnitResolver compiles; basic smoke tests pass.

### Phase 3: Comprehensive Testing (3-4 hours)

- [ ] Create `tests/UnitResolverTests.cs`
- [ ] Test alias resolution
  - [ ] Test "inch", "in", "inches" normalize to same token
  - [ ] Test "pound force", "lbf", "lb force" normalize to same token
  - [ ] Test case insensitivity ("IN", "In", "in")
- [ ] Test base factor computation
  - [ ] Test inch → meter factor (0.0254)
  - [ ] Test foot → meter factor (0.3048)
  - [ ] Test mile → meter factor (1609.344)
  - [ ] Test base unit → itself returns factor 1
- [ ] Test transitivity
  - [ ] Verify inch → foot via base matches direct conversion
  - [ ] Verify multiple conversions don't accumulate errors
- [ ] Test error cases
  - [ ] Unknown unit throws `ArgumentException`
  - [ ] Null/empty/whitespace throws `ArgumentException`
  - [ ] Undefined base unit throws `InvalidOperationException`
- [ ] Test all defined units
  - [ ] Iterate `UnitDefinitions.Definitions` and verify each resolves
  - [ ] Verify all have valid base units
- [ ] Test `IsValidUnit()` method
  - [ ] Known units return true
  - [ ] Unknown units return false
  - [ ] Invalid input returns false

**Validation**: All tests pass on both netstandard2.0 and net7.0; coverage ≥85%.

### Phase 4: Integration and Documentation (2 hours)

- [ ] Review integration points with existing code
  - [ ] Verify compatibility with `UnitDefinitions.Parse()`
  - [ ] Confirm factors match existing conversion behavior
- [ ] Add XML documentation comments
  - [ ] All public/internal members documented
  - [ ] Examples in remarks where helpful
- [ ] Update CHANGELOG.md
  - [ ] Note internal implementation (not public API change)
- [ ] Code review
  - [ ] SOLID principles adherence
  - [ ] Immutability verification
  - [ ] Performance considerations
  - [ ] Error handling completeness

**Validation**: Code review approved; documentation complete; no build warnings.

---

## Acceptance Criteria

### Functional Requirements

✅ **AC-1**: `Normalize()` resolves all aliases to correct canonical tokens  
✅ **AC-2**: Case-insensitive normalization (e.g., "IN" = "in" = "In")  
✅ **AC-3**: `Resolve()` returns correct base conversion factors for all defined units  
✅ **AC-4**: Base unit to itself resolves with factor 1.0  
✅ **AC-5**: Transitive conversions match direct factors (e.g., in→ft via m equals direct in→ft)  
✅ **AC-6**: Unknown units throw `ArgumentException` with clear message  
✅ **AC-7**: Invalid input (null, empty, whitespace) throws `ArgumentException`  
✅ **AC-8**: `IsValidUnit()` correctly identifies known and unknown units  
✅ **AC-9**: All existing `UnitDefinitions.Definitions` normalize and resolve successfully  
✅ **AC-10**: Base units defined for all `UnitTypeEnum` values

### Quality Requirements

✅ **AC-11**: All tests follow `MethodName_Condition_ExpectedResult()` naming convention  
✅ **AC-12**: Test coverage ≥85% for `UnitResolver` and related types  
✅ **AC-13**: No public API changes (internal implementation only)  
✅ **AC-14**: No external dependencies added  
✅ **AC-15**: Builds successfully on both `netstandard2.0` and `net7.0` TFMs  
✅ **AC-16**: No compiler warnings related to new code

### Non-Functional Requirements

✅ **AC-17**: O(1) lookup for normalization (dictionary-based)  
✅ **AC-18**: Minimal allocations (readonly structs for value objects)  
✅ **AC-19**: Thread-safe (immutable data structures, stateless service)  
✅ **AC-20**: XML documentation for all members  
✅ **AC-21**: CHANGELOG.md updated with internal implementation note

### Integration Requirements

✅ **AC-22**: Compatible with existing `UnitDefinitions` catalog  
✅ **AC-23**: Factors match existing conversion behavior (backward compatibility)  
✅ **AC-24**: Ready for F-004 (Dimensional Math Engine) integration  
✅ **AC-25**: Signature placeholder in `NormalizedUnit` for F-002 integration

---

## Testing Plan

### Test Organization

**Test Files**:
- `tests/UnitTokenTests.cs` — UnitToken value object tests
- `tests/UnitResolverTests.cs` — UnitResolver service tests

**Test Framework**: xUnit (consistent with existing test structure)  
**Test Categories**: Unit tests (no integration/acceptance tests needed at this stage)

### Test Structure Template

```csharp
[Fact]
public void Normalize_InchWithVariousAliases_ResolvesToSameCanonicalToken()
{
    // Arrange
    var resolver = UnitResolver.Instance;
    var aliases = new[] { "inch", "in", "inches", "IN", "Inch" };
    
    // Act
    var tokens = aliases.Select(a => resolver.Normalize(a)).ToList();
    
    // Assert
    Assert.True(tokens.All(t => t == tokens[0]), 
        "All inch aliases should resolve to the same canonical token");
}
```

### Test Coverage Matrix

| Category | Test Count | Focus Areas |
|----------|------------|-------------|
| UnitToken | 5 | Construction, equality, hash code, validation |
| Alias Resolution | 8 | Various aliases, case insensitivity, unknown units |
| Base Factor Computation | 6 | Common conversions, base to self, precision |
| Transitivity | 3 | Chained conversions, factor consistency |
| Error Cases | 5 | Unknown units, invalid input, undefined bases |
| Integration | 3 | All definitions resolve, valid factors, IsValidUnit |
| **Total** | **30** | **Comprehensive coverage** |

### Example Test Cases

**Test: Alias resolution for inch**
```csharp
[Fact]
public void Normalize_InchWithVariousAliases_ResolvesToSameCanonicalToken()
{
    // Arrange
    var resolver = UnitResolver.Instance;
    
    // Act
    var token1 = resolver.Normalize("inch");
    var token2 = resolver.Normalize("in");
    var token3 = resolver.Normalize("inches");
    var token4 = resolver.Normalize("IN");
    
    // Assert
    Assert.Equal(token1, token2);
    Assert.Equal(token2, token3);
    Assert.Equal(token3, token4);
}
```

**Test: Base factor computation**
```csharp
[Fact]
public void Resolve_InchToMeter_ReturnsCorrectFactor()
{
    // Arrange
    var resolver = UnitResolver.Instance;
    var expectedFactor = 0.0254m; // 1 inch = 0.0254 meters
    
    // Act
    var normalized = resolver.Resolve("in");
    
    // Assert
    Assert.Equal(expectedFactor, normalized.FactorToBase);
    Assert.Equal(UnitTypeEnum.Length, normalized.UnitType);
}
```

**Test: Unknown unit error**
```csharp
[Fact]
public void Normalize_UnknownUnit_ThrowsArgumentException()
{
    // Arrange
    var resolver = UnitResolver.Instance;
    
    // Act & Assert
    var ex = Assert.Throws<ArgumentException>(() => resolver.Normalize("unknownunit"));
    Assert.Contains("Unknown unit", ex.Message);
}
```

**Test: All definitions resolve**
```csharp
[Fact]
public void Resolve_AllDefinedUnits_ResolveSuccessfully()
{
    // Arrange
    var resolver = UnitResolver.Instance;
    var definitions = UnitDefinitions.Definitions;
    
    // Act & Assert
    foreach (var definition in definitions)
    {
        var normalized = resolver.Resolve(definition.Name);
        Assert.NotNull(normalized);
        Assert.True(normalized.FactorToBase > 0, 
            $"Unit {definition.Name} should have positive factor to base");
    }
}
```

### Test Execution

- **Command**: `dotnet test --filter "FullyQualifiedName~UnitResolverTests|FullyQualifiedName~UnitTokenTests"`
- **Success Criteria**: 100% pass rate, no warnings
- **Coverage Analysis**: Use `dotnet-coverage` to verify ≥85% coverage
  ```bash
  dotnet-coverage collect -f cobertura -o coverage.cobertura.xml dotnet test
  ```

---

## Technical Notes

### Design Decisions

**1. Why UnitToken as a struct?**
- **Rationale**: Small (single string reference), used frequently as dictionary keys, benefits from value semantics
- **Trade-off**: Slightly more stack allocation vs fewer heap allocations overall
- **Decision**: Use readonly struct for performance and value semantics

**2. Internal visibility for all components?**
- **Rationale**: Not yet validated as public API; allows iteration without breaking changes
- **Decision**: Keep internal for F-003; may promote to public in F-012 if needed

**3. Singleton vs instance-per-call?**
- **Rationale**: `UnitResolver` is stateless (all data in readonly dictionaries); singleton avoids repeated initialization
- **Decision**: Singleton pattern with `Instance` property; thread-safe immutable data

**4. Case sensitivity policy?**
- **Rationale**: Existing Tare behavior is case-insensitive for user friendliness
- **Decision**: Use `StringComparer.OrdinalIgnoreCase` for alias lookups

**5. Base unit selection criteria?**
- **Rationale**: Prefer SI base units; use commonly accepted derived units where no base exists (e.g., Newton for Force)
- **Decision**: Follow SI standards; document in `BaseUnitMap` comments

**6. Factor representation: decimal vs Rational?**
- **Rationale**: E-001 decided to start with `decimal` pending S-005 spike results
- **Decision**: Use `decimal` for F-003; mechanical swap to `Rational` if S-005 recommends it

### Integration Points

**With UnitDefinitions:**
- Parse all definitions at `UnitResolver` construction
- Build alias map from `Name` and `Aliases` properties
- Use `Factor` property for base conversion (currently `decimal`)
- Respect `UnitType` for dimension categorization

**With F-002 (DimensionSignature):**
- Add `Signature` property to `NormalizedUnit`
- Map `UnitTypeEnum` → `DimensionSignature` in resolver
- Compute signatures during resolution (deferred to F-004 integration)

**With F-004 (Dimensional Math Engine):**
- `UnitResolver` provides normalized tokens and factors for engine input
- Engine uses signatures from `NormalizedUnit` for dimensional algebra
- Factor ratios determine value scaling in multiplication/division

**With F-007 (Quantity Operators):**
- Operators call `UnitResolver.Resolve()` on operand units
- Compare signatures to validate compatibility
- Use factors to compute result values

### Performance Characteristics

| Operation | Complexity | Notes |
|-----------|------------|-------|
| Normalize | O(1) | Dictionary lookup |
| Resolve | O(1) | Dictionary lookup + trivial computation |
| IsValidUnit | O(1) | Dictionary containment check |
| Initialization | O(n) | Build maps from n definitions (one-time cost) |

**Memory footprint**:
- Alias map: ~200 entries (estimated) × (string key + UnitToken value)
- Token-to-definition map: ~100 entries × (UnitToken key + reference)
- Total: <100KB (negligible for library)

---

## Risk Assessment

### Technical Risks

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| **Ambiguous aliases** | Low | High | Validate alias uniqueness during initialization; throw if duplicate |
| **Missing base unit** | Low | Medium | Define base for all UnitTypeEnum values; throw clear exception if missing |
| **Factor precision loss** | Low | Medium | Use `decimal`; S-005 will validate sufficiency; ready to swap to `Rational` |
| **Performance regression** | Low | Low | Dictionary lookups are O(1); benchmark if needed in F-010 |

### Design Risks

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| **Incompatible base units** | Low | High | Choose SI-standard base units; document rationale |
| **Signature mismatch with F-002** | Medium | High | Coordinate mapping; validate in integration tests |
| **API stability for future public exposure** | Medium | Medium | Design as if public (clean interface); keep internal for now |

### Integration Risks

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| **UnitDefinitions schema change** | Low | Medium | Encapsulate parsing in resolver; use defensive copies |
| **F-004 needs different data structure** | Medium | Medium | Review F-004 requirements; iterate resolver API if needed |
| **Backward compatibility break** | Low | High | Validate factors match existing conversions; add regression tests |

### Testing Risks

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| **Incomplete alias coverage** | Medium | Medium | Test all definitions; manual review of aliases list |
| **Floating-point comparison issues** | Low | Low | Use appropriate tolerances; prefer exact decimal comparison |
| **Missing edge cases** | Medium | Medium | Systematic test matrix; code review checklist |

---

## Dependencies

### Prerequisite Features

- **None** (uses existing `UnitDefinitions`)
- **Optional**: F-001 (Rational) if S-005 determines need; F-003 designed to swap decimal→Rational easily

### Dependent Features

- **F-004 (Dimensional Math Engine)**: Primary consumer; needs normalized units and factors
- **F-005 (Known-Signature Naming Map)**: Uses normalized tokens for signature → name mapping
- **F-006 (Composite Unit Formatter)**: Uses canonical tokens for stable formatting
- **F-007 (Quantity Operators)**: Calls resolver during multiplication/division

### External Dependencies

- None (pure .NET; leverages existing `UnitDefinitions`)

---

## Quality Checklist (Mandatory Verification)

### Domain Design Validation (REQUIRED)

- [ ] **Domain Model**: I have verified that `UnitToken`, `NormalizedUnit`, and `UnitResolver` properly model unit normalization and resolution concepts.
- [ ] **Ubiquitous Language**: I have confirmed consistent terminology (Unit, Alias, Canonical Token, Base Unit, Factor, Normalize, Resolve).
- [ ] **SOLID Principles Adherence**: I have verified SRP (resolver focused on normalization) and DIP (depends on abstractions).
- [ ] **Business Rules**: I have validated alias uniqueness, factor transitivity, and case-insensitive resolution.
- [ ] **Value Semantics**: I have confirmed immutability of value objects and proper equality implementation.

### Implementation Quality Validation (REQUIRED)

- [ ] **Test Coverage**: I have written comprehensive tests following `MethodName_Condition_ExpectedResult()` naming convention.
- [ ] **Test Execution**: All tests pass on both netstandard2.0 and net7.0 target frameworks.
- [ ] **Performance**: I have considered O(1) lookups and minimal allocations.
- [ ] **Documentation**: I have documented design decisions, base unit choices, and integration points.
- [ ] **.NET Best Practices**: I have followed .NET best practices for value types, dictionaries, and singletons.

### Precision & Compliance Validation (REQUIRED)

- [ ] **Numeric Precision**: I have used `decimal` for exact factor representation.
- [ ] **Conversion Accuracy**: I have validated factors match existing Tare conversion behavior.
- [ ] **Deterministic Behavior**: I have ensured normalization is deterministic and locale-independent.
- [ ] **Backward Compatibility**: I have verified no breaking changes to existing conversion results.

### Integration Validation (REQUIRED)

- [ ] **UnitDefinitions Compatibility**: I have verified all definitions parse and resolve correctly.
- [ ] **F-002 Readiness**: I have prepared `NormalizedUnit` for signature integration.
- [ ] **F-004 Readiness**: I have designed resolver API suitable for dimensional math engine consumption.
- [ ] **No Public API Changes**: I have confirmed all new types are internal.

---

## Completion Criteria

### Definition of Done

1. [ ] All code implemented, reviewed, and merged to feature branch
2. [ ] All unit tests pass on both target frameworks
3. [ ] Code coverage ≥85% for `UnitResolver` and related types
4. [ ] XML documentation complete for all members
5. [ ] Code review completed by at least one reviewer
6. [ ] CHANGELOG.md updated with internal implementation note
7. [ ] No compiler warnings related to new code
8. [ ] Integration readiness validated (F-004 developer confirms API suitability)

### Acceptance Sign-Off

- [ ] Feature owner approval: Normalization and resolution work correctly for all defined units
- [ ] Code reviewer approval: Code quality, SOLID adherence, and test coverage meet standards
- [ ] Integration validation: F-004 developer confirms resolver API is suitable for dimensional math engine

---

## Open Questions

### Resolved Decisions

1. **Q**: Should we support composite unit normalization (e.g., "kg*m/s²")?  
   **A**: No, not in F-003. Composite parsing deferred to F-009. F-003 focuses on single-unit normalization only.

2. **Q**: What if two definitions have the same canonical name but different UnitTypes?  
   **A**: Validation error during initialization. Each canonical token must be unique across all definitions.

3. **Q**: How to handle temperature offsets (°C vs K, °F vs R)?  
   **A**: Out of scope for F-003. Temperature handling requires special logic; defer to dedicated feature.

4. **Q**: Should `IsValidUnit()` return true for aliases?  
   **A**: Yes. All aliases are valid if they resolve to a known canonical token.

5. **Q**: Case sensitivity for canonical tokens internally?  
   **A**: Store canonical tokens as-is from definitions; use case-insensitive comparison for alias resolution.

### Open Questions for Review

1. **Q**: Should we expose `UnitToken` as a public type in future?  
   **Open**: Defer decision to F-012 (API Helpers). Keep internal for now; review user demand.

2. **Q**: Should we cache resolved `NormalizedUnit` instances?  
   **Open**: Defer comprehensive caching to F-010 (Performance). Start with simple dictionary caching; optimize if profiling indicates need.

3. **Q**: What if a UnitType is added to enum without a base unit defined?  
   **Open**: Throw `InvalidOperationException` during initialization; require base units for all types. Add validation test.

---

## Files to Create/Modify

### New Files

- `src/Internal/Units/UnitToken.cs` — Canonical unit identifier value object
- `src/Internal/Units/NormalizedUnit.cs` — Resolved unit with token, factor, signature
- `src/Internal/Units/IUnitResolver.cs` — Resolver service interface
- `src/Internal/Units/UnitResolver.cs` — Resolver service implementation
- `src/Internal/Units/BaseUnitMap.cs` — Static base unit configuration
- `tests/UnitTokenTests.cs` — UnitToken value object tests
- `tests/UnitResolverTests.cs` — Resolver service tests

### Modified Files

- `docs/CHANGELOG.md` — Add internal implementation note for F-003

### Documentation

- XML comments on all types and members
- Code comments explaining base unit choices and alias resolution logic

---

## Timeline

**Estimated Effort**: 1–2 days (M)

### Day 1 (6-7 hours)

- **Morning (3-4 hours)**: 
  - Implement `UnitToken` value object (1 hour)
  - Implement `NormalizedUnit` value object (0.5 hour)
  - Create `BaseUnitMap` configuration (1 hour)
  - Write tests for `UnitToken` (1 hour)
- **Afternoon (3 hours)**: 
  - Implement `IUnitResolver` interface (0.5 hour)
  - Implement `UnitResolver` service (2.5 hours)

### Day 2 (5-6 hours)

- **Morning (3-4 hours)**: 
  - Write comprehensive `UnitResolver` tests (3-4 hours)
- **Afternoon (2 hours)**: 
  - Integration validation and bug fixes (1 hour)
  - Documentation and code review (1 hour)

### Contingency

- Additional time if alias conflicts discovered in definitions
- Additional time if factor precision issues found (would trigger S-005 evaluation)

---

## References

### Internal References

- **Epic E-001**: Option A Hybrid Core (Dimension vectors + catalog naming)
- **F-001**: Core rational arithmetic (optional dependency)
- **F-002**: Dimension signature model (integration point)
- **F-004**: Dimensional math engine (primary consumer)
- **S-005**: Decimal precision spike (determines decimal vs Rational choice)

### External References

- **SI Units**: https://www.nist.gov/pml/owm/metric-si/si-units
- **Unit Conversion Standards**: https://en.wikipedia.org/wiki/Conversion_of_units
- **Frink Units Database**: https://frinklang.org/frinkdata/units.txt (inspiration for alias handling)

---

## Revision History

| Version | Date | Author | Changes |
|---------|------|--------|---------|
| 1.0 | 2025-11-08 | Copilot Agent | Initial feature plan created per user request |

---

**Ready for Review** ✅  
This feature plan is complete and awaits user review and approval before implementation begins.
