# F-003: Unit Normalization and Alias Resolver

**Status**: Planned  
**Priority**: P1 (Must)  
**Effort**: L (2–3 days)  
**Epic**: E-001 — Option A Hybrid Core  
**Dependencies**: None (optimizes existing UnitDefinitions; prepares for F-004)  
**Integrates**: S-006 Option 1 (Dictionary-based UnitDefinitions optimization)

---

## Feature Overview

This feature delivers a unit normalization and alias resolution pipeline that standardizes unit representations across the Tare library. It leverages the existing `UnitDefinitions` catalog (with dictionary-based optimization from S-006) to map aliases to canonical unit tokens and compute exact base conversion factors, creating a foundation for dimensional algebra operations in F-004.

**Includes S-006 Option 1**: As part of this feature, we will implement dictionary-based indexing for `UnitDefinitions` to achieve O(1) lookups (100-1000x performance improvement) while maintaining full backward compatibility with existing public API.

### User Story

**As a** Tare library maintainer developing dimensional algebra capabilities  
**I want** a normalization pipeline that resolves unit aliases and computes base factors with high performance  
**So that** operations like `Quantity("36 in") * Quantity("2 ft")` can identify that both use Length dimensions and convert to a common base before computing signatures, without performance degradation

### Context

F-003 is the third feature in the E-001 epic implementing Option A (Hybrid Core). It bridges existing catalog-based parsing with the dimensional algebra engine planned in F-004. The normalization pipeline ensures that:
- Aliases like "inch"/"in"/"inches" normalize to the same canonical token
- Each unit's conversion factor to the dimension's base unit is computed
- Unit tokens are suitable for signature resolution and composite formatting
- **Performance optimization**: Dictionary-based indexing provides O(1) lookups instead of O(n) linear search
- **API preservation**: Existing `UnitDefinitions` public API remains unchanged

---

## Mandatory Thinking Process (DDD/.NET Guidelines)

### 1. Domain Analysis (REQUIRED)

#### Domain Concepts Involved

- **Unit**: A measure standard with a name, factor, and dimensional type (e.g., "meter", "inch", "pound force")
- **Alias**: Alternative names for the same unit (e.g., "in" = "inch" = "inches")
- **Canonical Token**: The normalized, unique identifier for a unit (e.g., "in" is canonical for inch aliases)
- **Base Unit**: The reference unit for a dimension (e.g., "m" for Length, "kg" for Mass)
- **Normalization**: The process of mapping any unit string (including aliases) to its canonical token
- **Resolution**: Computing the exact conversion factor from a unit to its dimension's base unit
- **Unit Family/Type**: A dimensional category (Length, Mass, Time, Force, Energy, etc.)

#### Aggregate Boundaries and Consistency Requirements

- **Value Objects**: 
  - `UnitToken` — Internal immutable identifier for normalized units
  - `NormalizedUnit` — Result of normalization containing token, factor, dimension signature
- **Domain Service**: 
  - `UnitResolver` — Stateless service providing normalization and resolution operations
- **Consistency**: 
  - Aliases must map uniquely to canonical tokens (no ambiguity)
  - Factors must be exact and deterministic (use `decimal`, preparing for F-001 `Rational` if needed)
  - Base unit for each dimension must be clearly defined

#### Ubiquitous Language Terms

- **Unit**, **Alias**, **Canonical Token**, **Base Unit**, **Factor**, **Normalize**, **Resolve**, **UnitType** (dimension family), **Signature** (dimensional composition from F-002)

#### Business Rules and Invariants

- **Uniqueness**: Each canonical token maps to exactly one unit definition
- **Alias Resolution**: All aliases for a unit resolve to the same canonical token
- **Factor Transitivity**: Factor from unit A → base → unit B equals direct factor from A → B
- **Case Insensitivity**: Unit resolution is case-insensitive (per existing Tare behavior)
- **Validation**: Unknown units throw informative exceptions (preserve existing error handling)

### 2. Architecture Review (REQUIRED)

#### Layer Responsibilities

- **Domain Layer**: 
  - `UnitToken` value object (internal)
  - `NormalizedUnit` value object (internal)
  - `IUnitResolver` interface (internal)
  - `UnitResolver` domain service implementation (internal)
- **Integration Points**:
  - Consumes `UnitDefinitions` catalog (existing)
  - Prepares data for `DimensionalMath` engine (F-004)
  - Used by `Quantity` operators (F-007)

#### SOLID Principles Adherence

- **SRP**: `UnitResolver` has single responsibility—normalize and resolve units to base factors
- **OCP**: Extensible to new units via `UnitDefinitions`; closed to modification of normalization logic
- **LSP**: N/A (no inheritance hierarchy)
- **ISP**: Interface focused on normalization/resolution operations only
- **DIP**: Depends on abstraction (`IUnitResolver`) rather than concrete implementation

#### Domain Events

- N/A — Normalization is a pure computational operation with no side effects

#### Security Implications

- No user credentials or sensitive data
- Input validation: unknown units throw exceptions (existing pattern)
- Deterministic behavior: no non-deterministic operations

### 3. Implementation Planning (REQUIRED)

#### Files to Create/Modify

| File | Type | Justification |
|------|------|---------------|
| `src/UnitDefinitions.cs` | Modified | Add internal dictionary indexes for O(1) lookup performance (S-006 Option 1); add dimensionless units (%, ppm, ppb, ppt) |
| `src/Internal/Units/UnitToken.cs` | New | Immutable value object for canonical unit identifiers |
| `src/Internal/Units/NormalizedUnit.cs` | New | Value object containing normalized token + factor + signature |
| `src/Internal/Units/IUnitResolver.cs` | New | Interface for normalization and resolution operations |
| `src/Internal/Units/UnitResolver.cs` | New | Domain service implementing normalization logic |
| `src/Internal/Units/BaseUnitMap.cs` | New | Static mapping of UnitType → base unit token (includes Scalar/"each") |
| `tests/UnitResolverTests.cs` | New | Comprehensive unit tests for resolver |
| `tests/UnitTokenTests.cs` | New | Tests for UnitToken value object |
| `tests/UnitDefinitionsPerformanceTests.cs` | New | Benchmark tests validating O(1) lookup performance |
| `tests/DimensionlessUnitsTests.cs` | New | Tests for dimensionless units (%, ppm, ppb, ppt) and conversions |
| `docs/CHANGELOG.md` | Modified | Document internal implementation, performance improvements, and new dimensionless units |

#### Test Cases (Following `MethodName_Condition_ExpectedResult()` Pattern)

**Alias Resolution:**
- `Normalize_InchWithVariousAliases_ResolveToSameCanonicalToken()`
- `Normalize_PoundForceWithAliases_ResolveToLbfToken()`
- `Normalize_CaseInsensitive_ResolveToCanonicalToken()`
- `Normalize_UnknownUnit_ThrowsArgumentException()`

**Base Factor Computation:**
- `Resolve_InchToMeter_ReturnsCorrectFactor()`
- `Resolve_FootToMeter_ReturnsCorrectFactor()`
- `Resolve_MileToMeter_ReturnsCorrectFactor()`
- `Resolve_PoundForceToNewton_ReturnsCorrectFactor()`
- `Resolve_BaseUnitToItself_ReturnsFactorOne()`

**Transitivity:**
- `Resolve_InchToFoot_MatchesDirectFactor()`
- `Resolve_ChainedConversions_MaintainsPrecision()`

**Dimensionless Units:**
- `Resolve_Percentage_ResolvesToCorrectFactor()`
- `Resolve_PartsPerMillion_ResolvesToCorrectFactor()`
- `Resolve_PartsPerBillion_ResolvesToCorrectFactor()`
- `Resolve_PartsPerTrillion_ResolvesToCorrectFactor()`
- `Resolve_DimensionlessConversions_WorkCorrectly()`
- `Normalize_PercentAliases_ResolveToSameToken()` (test %, percent, pct)

**Edge Cases:**
- `Normalize_EmptyString_ThrowsArgumentException()`
- `Normalize_WhitespaceOnly_ThrowsArgumentException()`
- `Resolve_UnitWithoutDefinedBase_ThrowsInvalidOperationException()`

**Integration with UnitDefinitions:**
- `Normalize_AllDefinedUnits_ResolveSuccessfully()`
- `Resolve_AllDefinedUnits_HaveValidFactors()`
- `IsValidUnit_DimensionlessUnits_ReturnsTrue()`

#### Error Handling and Validation Strategy

- **Unknown Units**: Throw `ArgumentException` with message: "Unknown unit: '{unit}'"
- **Invalid Input**: Throw `ArgumentException` for null, empty, or whitespace-only strings
- **Undefined Base**: Throw `InvalidOperationException` if a UnitType lacks a defined base unit
- **Clear Messages**: Follow existing Tare exception message patterns

#### Performance and Scalability Considerations

- **Caching Strategy**: 
  - Cache normalized tokens in `Dictionary<string, UnitToken>` (case-insensitive)
  - Cache resolved factors in `Dictionary<UnitToken, decimal>` per dimension
  - Defer comprehensive caching to F-010; start with simple memoization
- **Allocation Optimization**:
  - Use readonly structs for value objects
  - Avoid string allocations in hot paths (reuse tokens)
- **Lookup Efficiency**: O(1) dictionary lookups for both alias resolution and factor computation

---

## Detailed Implementation Design

### UnitToken Value Object

```csharp
namespace Tare.Internal.Units;

/// <summary>
/// Represents a normalized, canonical identifier for a unit.
/// Immutable value object ensuring unique representation across aliases.
/// </summary>
internal readonly struct UnitToken : IEquatable<UnitToken>
{
    /// <summary>
    /// Constructs a unit token from a canonical string.
    /// </summary>
    /// <param name="canonical">The canonical unit identifier (e.g., "in", "lbf", "m").</param>
    /// <exception cref="ArgumentException">Thrown when canonical is null, empty, or whitespace.</exception>
    public UnitToken(string canonical);
    
    /// <summary>
    /// Gets the canonical string representation of the unit.
    /// </summary>
    public string Canonical { get; }
    
    // IEquatable implementation
    public bool Equals(UnitToken other);
    public override bool Equals(object? obj);
    public override int GetHashCode();
    public static bool operator ==(UnitToken left, UnitToken right);
    public static bool operator !=(UnitToken left, UnitToken right);
    
    // String representation
    public override string ToString();
}
```

### NormalizedUnit Value Object

```csharp
namespace Tare.Internal.Units;

/// <summary>
/// Represents a fully normalized unit with its canonical token, base conversion factor,
/// and dimensional signature (when available).
/// </summary>
internal readonly struct NormalizedUnit
{
    /// <summary>
    /// Constructs a normalized unit.
    /// </summary>
    /// <param name="token">The canonical unit token.</param>
    /// <param name="factorToBase">Conversion factor to the dimension's base unit.</param>
    /// <param name="unitType">The unit type/dimension family.</param>
    public NormalizedUnit(UnitToken token, decimal factorToBase, UnitTypeEnum unitType);
    
    /// <summary>
    /// Gets the canonical unit token.
    /// </summary>
    public UnitToken Token { get; }
    
    /// <summary>
    /// Gets the conversion factor to the dimension's base unit.
    /// </summary>
    public decimal FactorToBase { get; }
    
    /// <summary>
    /// Gets the unit type (dimension family).
    /// </summary>
    public UnitTypeEnum UnitType { get; }
    
    /// <summary>
    /// Gets the dimension signature (added when F-002 is integrated).
    /// </summary>
    public DimensionSignature Signature { get; }
}
```

### IUnitResolver Interface

```csharp
namespace Tare.Internal.Units;

/// <summary>
/// Service interface for unit normalization and resolution operations.
/// </summary>
internal interface IUnitResolver
{
    /// <summary>
    /// Normalizes a unit string (including aliases) to its canonical token.
    /// </summary>
    /// <param name="unit">The unit string to normalize.</param>
    /// <returns>The canonical unit token.</returns>
    /// <exception cref="ArgumentException">Thrown when unit is unknown or invalid.</exception>
    UnitToken Normalize(string unit);
    
    /// <summary>
    /// Resolves a unit to its normalized representation with base conversion factor.
    /// </summary>
    /// <param name="unit">The unit string to resolve.</param>
    /// <returns>The normalized unit with token, factor, and dimension.</returns>
    /// <exception cref="ArgumentException">Thrown when unit is unknown or invalid.</exception>
    NormalizedUnit Resolve(string unit);
    
    /// <summary>
    /// Gets the base unit token for a given dimension type.
    /// </summary>
    /// <param name="unitType">The dimension type.</param>
    /// <returns>The base unit token for that dimension.</returns>
    UnitToken GetBaseUnit(UnitTypeEnum unitType);
    
    /// <summary>
    /// Checks if a unit string is valid (known in the catalog).
    /// </summary>
    /// <param name="unit">The unit string to check.</param>
    /// <returns>True if the unit is valid; false otherwise.</returns>
    bool IsValidUnit(string unit);
}
```

### UnitResolver Implementation

```csharp
namespace Tare.Internal.Units;

/// <summary>
/// Domain service providing unit normalization and resolution using the UnitDefinitions catalog.
/// </summary>
internal sealed class UnitResolver : IUnitResolver
{
    // Singleton instance (stateless service)
    public static readonly UnitResolver Instance = new UnitResolver();
    
    // Cached mappings (initialized lazily or at construction)
    private readonly Dictionary<string, UnitToken> _aliasToToken;
    private readonly Dictionary<UnitToken, UnitDefinition> _tokenToDefinition;
    private readonly Dictionary<UnitTypeEnum, UnitToken> _baseUnits;
    
    private UnitResolver()
    {
        // Initialize mappings from UnitDefinitions.Definitions
        // Build alias → canonical token map (case-insensitive)
        // Build token → definition map
        // Define base units per dimension
    }
    
    public UnitToken Normalize(string unit)
    {
        ArgumentNullException.ThrowIfNull(unit);
        if (string.IsNullOrWhiteSpace(unit))
            throw new ArgumentException("Unit cannot be empty or whitespace.", nameof(unit));
        
        // Lookup in alias map (case-insensitive)
        // Return canonical token or throw if unknown
    }
    
    public NormalizedUnit Resolve(string unit)
    {
        var token = Normalize(unit);
        var definition = _tokenToDefinition[token];
        var baseToken = GetBaseUnit(definition.UnitType);
        var factorToBase = ComputeFactorToBase(token, baseToken, definition);
        
        // When F-002 is integrated, compute signature here
        return new NormalizedUnit(token, factorToBase, definition.UnitType);
    }
    
    public UnitToken GetBaseUnit(UnitTypeEnum unitType)
    {
        if (!_baseUnits.TryGetValue(unitType, out var baseToken))
            throw new InvalidOperationException($"No base unit defined for {unitType}");
        
        return baseToken;
    }
    
    public bool IsValidUnit(string unit)
    {
        if (string.IsNullOrWhiteSpace(unit))
            return false;
        
        return _aliasToToken.ContainsKey(unit.ToLowerInvariant());
    }
    
    private decimal ComputeFactorToBase(UnitToken token, UnitToken baseToken, UnitDefinition definition)
    {
        // If token is already the base unit, factor is 1
        if (token == baseToken)
            return 1m;
        
        // Otherwise, use definition.Factor (which represents conversion to base)
        return definition.Factor;
    }
}
```

### BaseUnitMap Configuration

```csharp
namespace Tare.Internal.Units;

/// <summary>
/// Static mapping of dimension types to their base units.
/// Base units are the reference for each dimensional family.
/// </summary>
internal static class BaseUnitMap
{
    // SI base units for each dimension
    public static readonly Dictionary<UnitTypeEnum, string> BaseUnits = new()
    {
        { UnitTypeEnum.Scalar, "" },            // dimensionless (empty string = 1, "each" optional)
        { UnitTypeEnum.Length, "m" },           // meter
        { UnitTypeEnum.Mass, "kg" },            // kilogram
        { UnitTypeEnum.Time, "s" },             // second
        { UnitTypeEnum.Area, "m²" },            // square meter (derived, but serves as base)
        { UnitTypeEnum.Volume, "m³" },          // cubic meter (derived)
        { UnitTypeEnum.Force, "N" },            // newton (derived: kg⋅m/s²)
        { UnitTypeEnum.Energy, "J" },           // joule (derived: N⋅m)
        { UnitTypeEnum.Pressure, "Pa" },        // pascal (derived: N/m²)
        { UnitTypeEnum.Power, "W" },            // watt (derived: J/s)
        { UnitTypeEnum.Temperature, "K" },      // kelvin (SI base)
        { UnitTypeEnum.Angle, "rad" },          // radian
        // Add other types as needed
    };
}
```

### Dimensionless (Scalar) Units to be Added

As part of Phase 0, the following dimensionless units will be added to `UnitDefinitions` to support common scalar representations:

```csharp
// Dimensionless/Scalar units (relative to empty string "" base = 1, "each" is optional alias)
new UnitDefinition("percent", 0.01M, UnitTypeEnum.Scalar, 
    new HashSet<string> { "percent", "%", "pct" }),
    
new UnitDefinition("ppm", 0.000001M, UnitTypeEnum.Scalar, 
    new HashSet<string> { "ppm", "parts per million" }),
    
new UnitDefinition("ppb", 0.000000001M, UnitTypeEnum.Scalar, 
    new HashSet<string> { "ppb", "parts per billion" }),
    
new UnitDefinition("ppt", 0.000000000001M, UnitTypeEnum.Scalar, 
    new HashSet<string> { "ppt", "parts per trillion" }),

```

### UnitDefinitions Dictionary Optimization (S-006 Option 1)

**Description:** Add internal dictionary indexes to `UnitDefinitions` for O(1) lookups while preserving the existing public API.

**Structure:**
```csharp
namespace Tare;

public static class UnitDefinitions
{
    // Existing public list (unchanged for backward compatibility)
    private static IEnumerable<UnitDefinition> Definitions = new List<UnitDefinition>() { ... };
    
    // NEW: Internal dictionary indexes for O(1) lookups
    private static readonly Dictionary<string, UnitDefinition> _aliasIndex;
    private static readonly Dictionary<string, UnitDefinition> _nameIndex;
    private static readonly Dictionary<UnitTypeEnum, List<UnitDefinition>> _typeIndex;
    
    // Static constructor builds indexes once at startup
    static UnitDefinitions()
    {
        var definitionsList = (Definitions as List<UnitDefinition>) ?? Definitions.ToList();
        
        // Build name index (exact match, case-sensitive)
        _nameIndex = definitionsList.ToDictionary(d => d.Name, StringComparer.Ordinal);
        
        // Build alias index (case-insensitive, includes all aliases)
        _aliasIndex = new Dictionary<string, UnitDefinition>(StringComparer.OrdinalIgnoreCase);
        foreach (var def in definitionsList)
        {
            foreach (var alias in def.Aliases)
            {
                // Use first definition if duplicate alias exists
                if (!_aliasIndex.ContainsKey(alias))
                    _aliasIndex[alias] = def;
            }
        }
        
        // Build type index (for categorization queries)
        _typeIndex = definitionsList.GroupBy(d => d.UnitType)
                                     .ToDictionary(g => g.Key, g => g.ToList());
    }
    
    // Optimized implementation of existing public methods (backward compatible)
    public static bool IsValidUnit(string unit)
        => _aliasIndex.ContainsKey(unit);
    
    public static UnitDefinition Parse(string unit)
    {
        if (_aliasIndex.TryGetValue(unit, out var definition))
            return definition;
        
        throw new ArgumentException("No matching unit " + unit + " was found.");
    }
    
    public static UnitTypeEnum ParseUnitType(string unit)
        => _aliasIndex.TryGetValue(unit, out var def) ? def.UnitType : UnitTypeEnum.Unknown;
    
    // Internal accessor for UnitResolver (enables index reuse)
    internal static IReadOnlyDictionary<string, UnitDefinition> AliasIndex => _aliasIndex;
}
```

**Key Design Decisions:**

1. **Preserve existing API**: Public methods (`Parse`, `IsValidUnit`, `ParseUnitType`) maintain identical signatures and behavior
2. **Internal indexes**: Dictionaries marked `private` and `readonly` for encapsulation
3. **Static initialization**: Indexes built once in static constructor (~5-10ms startup cost)
4. **Case-insensitive**: `_aliasIndex` uses `StringComparer.OrdinalIgnoreCase` matching current behavior
5. **Duplicate handling**: First definition wins if duplicate alias exists (validated in tests)
6. **Internal accessor**: `AliasIndex` property enables `UnitResolver` to reuse indexes without duplication

**Performance Improvements:**
- `Parse()`: O(n) → O(1) (100-1000x faster: 0.5-5μs → ~0.05μs)
- `IsValidUnit()`: O(n*m) → O(1) (100-1000x faster: ~2μs → ~0.05μs)
- `ParseUnitType()`: O(n*m) → O(1) (100-1000x faster)
- Memory: +150-200KB for indexes (total <500KB, acceptable)

---

## Task Breakdown

### Phase 0: UnitDefinitions Dictionary Optimization (3-4 hours)

**Implements S-006 Option 1 - Dictionary-based indexing**

- [ ] Add dimensionless (Scalar) units to `UnitDefinitions`
  - [ ] Add "percent" (%, pct) with factor 0.01
  - [ ] Add "ppm" (parts per million) with factor 0.000001
  - [ ] Add "ppb" (parts per billion) with factor 0.000000001
  - [ ] Add "ppt" (parts per trillion) with factor 0.000000000001
- [ ] Add internal dictionary fields to `UnitDefinitions`
  - [ ] `_aliasIndex` (case-insensitive)
  - [ ] `_nameIndex` (case-sensitive)
  - [ ] `_typeIndex` (by UnitTypeEnum)
- [ ] Implement static constructor to build indexes
  - [ ] Build alias index from all definitions
  - [ ] Handle duplicate aliases (first wins, log warning)
  - [ ] Validate all definitions indexed correctly
- [ ] Update existing public methods to use dictionaries
  - [ ] `IsValidUnit()` → `_aliasIndex.ContainsKey()`
  - [ ] `Parse()` → `_aliasIndex.TryGetValue()`
  - [ ] `ParseUnitType()` → `_aliasIndex.TryGetValue()` + return UnitType
  - [ ] Preserve exact error messages for backward compatibility
- [ ] Add internal accessor for UnitResolver
  - [ ] `internal static IReadOnlyDictionary<string, UnitDefinition> AliasIndex { get; }`
- [ ] Write tests for dictionary optimization
  - [ ] Test all existing definitions are indexed
  - [ ] Test dimensionless units (%, ppm, ppb, ppt)
  - [ ] Test case-insensitive lookups
  - [ ] Test duplicate alias handling
  - [ ] Performance benchmark: Parse operations <0.1μs
  - [ ] Memory profiling: Total <500KB
- [ ] Validate backward compatibility
  - [ ] All existing unit tests pass unchanged
  - [ ] Error messages unchanged
  - [ ] Public API behavior identical

**Validation**: All existing tests pass; dimensionless units added; O(1) lookup performance confirmed; memory <500KB.

### Phase 1: Value Objects and Infrastructure (3-4 hours)

- [ ] Create `src/Internal/Units/` directory structure (if not exists)
- [ ] Implement `UnitToken` value object
  - [ ] Constructor with validation
  - [ ] `IEquatable<UnitToken>` implementation
  - [ ] `GetHashCode()` and equality operators
  - [ ] `ToString()` for debugging
- [ ] Implement `NormalizedUnit` value object
  - [ ] Constructor
  - [ ] Properties (Token, FactorToBase, UnitType)
  - [ ] Placeholder for Signature (F-002 integration point)
- [ ] Create `BaseUnitMap` static configuration
  - [ ] Define base units for all existing `UnitTypeEnum` values
  - [ ] Add `UnitTypeEnum.Scalar` → "" (empty string = dimensionless base, "each" optional)
  - [ ] Validate against current UnitDefinitions catalog
- [ ] Write tests for `UnitToken`
  - [ ] Construction tests
  - [ ] Equality tests
  - [ ] Hash code tests

**Validation**: UnitToken and NormalizedUnit tests pass; base unit map is complete.

### Phase 2: UnitResolver Service Implementation (4-5 hours)

- [ ] Define `IUnitResolver` interface
- [ ] Implement `UnitResolver` class
  - [ ] Constructor: **reuse `UnitDefinitions.AliasIndex`** instead of rebuilding
  - [ ] `Normalize(string unit)` method (delegates to optimized index)
  - [ ] `Resolve(string unit)` method
  - [ ] `GetBaseUnit(UnitTypeEnum unitType)` method
  - [ ] `IsValidUnit(string unit)` method (delegates to `UnitDefinitions.IsValidUnit`)
  - [ ] Private helper: `ComputeFactorToBase()`
- [ ] Error handling for unknown units and invalid input
- [ ] Singleton pattern for stateless service
- [ ] Leverage Phase 0 optimization for O(1) performance

**Validation**: UnitResolver compiles; basic smoke tests pass; reuses UnitDefinitions indexes.

### Phase 3: Comprehensive Testing (4-5 hours)

**UnitResolver Tests:**
- [ ] Create `tests/UnitResolverTests.cs`
- [ ] Test alias resolution
  - [ ] Test "inch", "in", "inches" normalize to same token
  - [ ] Test "pound force", "lbf", "lb force" normalize to same token
  - [ ] Test case insensitivity ("IN", "In", "in")
- [ ] Test base factor computation
  - [ ] Test inch → meter factor (0.0254)
  - [ ] Test foot → meter factor (0.3048)
  - [ ] Test mile → meter factor (1609.344)
  - [ ] Test base unit → itself returns factor 1
- [ ] Test transitivity
  - [ ] Verify inch → foot via base matches direct conversion
  - [ ] Verify multiple conversions don't accumulate errors
- [ ] Test error cases
  - [ ] Unknown unit throws `ArgumentException`
  - [ ] Null/empty/whitespace throws `ArgumentException`
  - [ ] Undefined base unit throws `InvalidOperationException`
- [ ] Test all defined units
  - [ ] Iterate `UnitDefinitions.Definitions` and verify each resolves
  - [ ] Verify all have valid base units
  - [ ] Test dimensionless units (%, ppm, ppb, ppt) resolve correctly
  - [ ] Test dimensionless conversions (50% = 0.5 each, 100% = 1 each)
- [ ] Test `IsValidUnit()` method
  - [ ] Known units return true
  - [ ] Unknown units return false
  - [ ] Invalid input returns false
  - [ ] Dimensionless units recognized (%, ppm, ppb, ppt)

**UnitDefinitions Performance Tests:**
- [ ] Create `tests/UnitDefinitionsPerformanceTests.cs`
- [ ] Benchmark Parse operations
  - [ ] Common units (in, ft, m): verify <0.1μs
  - [ ] Dimensionless units (%, ppm): verify <0.1μs
  - [ ] Rare units (zeptosecond): verify <0.1μs
  - [ ] Case-insensitive (INCH): verify <0.1μs
- [ ] Benchmark IsValidUnit operations
  - [ ] Known units: verify <0.1μs
  - [ ] Unknown units: verify <0.1μs
- [ ] Memory profiling
  - [ ] Total UnitDefinitions memory <500KB
  - [ ] Validate startup time <10ms
- [ ] Regression tests
  - [ ] All existing unit tests still pass
  - [ ] Behavior unchanged from pre-optimization

**Validation**: All tests pass on both netstandard2.0 and net7.0; coverage ≥85%; performance targets met.

### Phase 4: Integration and Documentation (2 hours)

- [ ] Review integration points with existing code
  - [ ] Verify compatibility with `UnitDefinitions.Parse()`
  - [ ] Confirm factors match existing conversion behavior
  - [ ] Validate UnitResolver reuses UnitDefinitions indexes (no duplication)
- [ ] Add XML documentation comments
  - [ ] All public/internal members documented
  - [ ] Examples in remarks where helpful
  - [ ] Document performance characteristics (O(1) lookups)
- [ ] Update CHANGELOG.md
  - [ ] Note internal implementation (not public API change)
  - [ ] Document performance improvements (100-1000x faster lookups)
  - [ ] Note S-006 Option 1 integration
  - [ ] Document new dimensionless units (%, ppm, ppb, ppt)
- [ ] Code review
  - [ ] SOLID principles adherence
  - [ ] Immutability verification
  - [ ] Performance considerations
  - [ ] Error handling completeness
  - [ ] Backward compatibility validation

**Validation**: Code review approved; documentation complete; no build warnings; performance validated.

---

## Acceptance Criteria

### Functional Requirements

✅ **AC-1**: `Normalize()` resolves all aliases to correct canonical tokens  
✅ **AC-2**: Case-insensitive normalization (e.g., "IN" = "in" = "In")  
✅ **AC-3**: `Resolve()` returns correct base conversion factors for all defined units  
✅ **AC-4**: Base unit to itself resolves with factor 1.0  
✅ **AC-5**: Transitive conversions match direct factors (e.g., in→ft via m equals direct in→ft)  
✅ **AC-6**: Unknown units throw `ArgumentException` with clear message  
✅ **AC-7**: Invalid input (null, empty, whitespace) throws `ArgumentException`  
✅ **AC-8**: `IsValidUnit()` correctly identifies known and unknown units  
✅ **AC-9**: All existing `UnitDefinitions.Definitions` normalize and resolve successfully  
✅ **AC-10**: Base units defined for all `UnitTypeEnum` values  
✅ **AC-10a**: Dimensionless units (%, ppm, ppb, ppt) added and resolve correctly  
✅ **AC-10b**: Scalar base unit (empty string "") defined in BaseUnitMap (with "each" as optional alias)  
✅ **AC-10c**: Dimensionless conversions work correctly (50% = 0.5, 1000000 ppm = 1)

### Quality Requirements

✅ **AC-11**: All tests follow `MethodName_Condition_ExpectedResult()` naming convention  
✅ **AC-12**: Test coverage ≥85% for `UnitResolver` and related types  
✅ **AC-13**: No public API changes (internal implementation only)  
✅ **AC-14**: No external dependencies added  
✅ **AC-15**: Builds successfully on both `netstandard2.0` and `net7.0` TFMs  
✅ **AC-16**: No compiler warnings related to new code

### Non-Functional Requirements

✅ **AC-17**: O(1) lookup for normalization (dictionary-based)  
✅ **AC-18**: Minimal allocations (readonly structs for value objects)  
✅ **AC-19**: Thread-safe (immutable data structures, stateless service)  
✅ **AC-20**: XML documentation for all members  
✅ **AC-21**: CHANGELOG.md updated with internal implementation and performance improvements

### Integration Requirements

✅ **AC-22**: Compatible with existing `UnitDefinitions` catalog  
✅ **AC-23**: Factors match existing conversion behavior (backward compatibility)  
✅ **AC-24**: Ready for F-004 (Dimensional Math Engine) integration  
✅ **AC-25**: Signature placeholder in `NormalizedUnit` for F-002 integration

### Performance Requirements (S-006 Integration)

✅ **AC-26**: `UnitDefinitions.Parse()` completes in <0.1μs (100-1000x improvement)  
✅ **AC-27**: `UnitDefinitions.IsValidUnit()` completes in <0.1μs  
✅ **AC-28**: Total memory footprint <500KB (including indexes)  
✅ **AC-29**: Startup time (static initialization) <10ms  
✅ **AC-30**: All existing UnitDefinitions tests pass unchanged (backward compatibility)  
✅ **AC-31**: UnitResolver reuses UnitDefinitions indexes (no duplication)  
✅ **AC-32**: Performance benchmarks validate O(1) lookup characteristics

---

## Testing Plan

### Test Organization

**Test Files**:
- `tests/UnitTokenTests.cs` — UnitToken value object tests
- `tests/UnitResolverTests.cs` — UnitResolver service tests
- `tests/UnitDefinitionsPerformanceTests.cs` — Performance benchmarks and validation

**Test Framework**: xUnit (consistent with existing test structure)  
**Test Categories**: Unit tests, Performance tests

### Test Structure Template

```csharp
[Fact]
public void Normalize_InchWithVariousAliases_ResolvesToSameCanonicalToken()
{
    // Arrange
    var resolver = UnitResolver.Instance;
    var aliases = new[] { "inch", "in", "inches", "IN", "Inch" };
    
    // Act
    var tokens = aliases.Select(a => resolver.Normalize(a)).ToList();
    
    // Assert
    Assert.True(tokens.All(t => t == tokens[0]), 
        "All inch aliases should resolve to the same canonical token");
}
```

### Test Coverage Matrix

| Category | Test Count | Focus Areas |
|----------|------------|-------------|
| UnitToken | 5 | Construction, equality, hash code, validation |
| Alias Resolution | 8 | Various aliases, case insensitivity, unknown units |
| Base Factor Computation | 6 | Common conversions, base to self, precision |
| Transitivity | 3 | Chained conversions, factor consistency |
| Error Cases | 5 | Unknown units, invalid input, undefined bases |
| Integration | 3 | All definitions resolve, valid factors, IsValidUnit |
| **Dimensionless Units** | **5** | **%, ppm, ppb, ppt resolution and conversions** |
| **Performance (S-006)** | **6** | **Parse/IsValidUnit benchmarks, memory, startup time** |
| **Backward Compatibility** | **3** | **Existing tests pass, behavior unchanged, API unchanged** |
| **Total** | **44** | **Comprehensive coverage including dimensionless and performance** |

### Example Test Cases

**Test: Alias resolution for inch**
```csharp
[Fact]
public void Normalize_InchWithVariousAliases_ResolvesToSameCanonicalToken()
{
    // Arrange
    var resolver = UnitResolver.Instance;
    
    // Act
    var token1 = resolver.Normalize("inch");
    var token2 = resolver.Normalize("in");
    var token3 = resolver.Normalize("inches");
    var token4 = resolver.Normalize("IN");
    
    // Assert
    Assert.Equal(token1, token2);
    Assert.Equal(token2, token3);
    Assert.Equal(token3, token4);
}
```

**Test: Base factor computation**
```csharp
[Fact]
public void Resolve_InchToMeter_ReturnsCorrectFactor()
{
    // Arrange
    var resolver = UnitResolver.Instance;
    var expectedFactor = 0.0254m; // 1 inch = 0.0254 meters
    
    // Act
    var normalized = resolver.Resolve("in");
    
    // Assert
    Assert.Equal(expectedFactor, normalized.FactorToBase);
    Assert.Equal(UnitTypeEnum.Length, normalized.UnitType);
}
```

**Test: Unknown unit error**
```csharp
[Fact]
public void Normalize_UnknownUnit_ThrowsArgumentException()
{
    // Arrange
    var resolver = UnitResolver.Instance;
    
    // Act & Assert
    var ex = Assert.Throws<ArgumentException>(() => resolver.Normalize("unknownunit"));
    Assert.Contains("Unknown unit", ex.Message);
}
```

**Test: All definitions resolve**
```csharp
[Fact]
public void Resolve_AllDefinedUnits_ResolveSuccessfully()
{
    // Arrange
    var resolver = UnitResolver.Instance;
    var definitions = UnitDefinitions.Definitions;
    
    // Act & Assert
    foreach (var definition in definitions)
    {
        var normalized = resolver.Resolve(definition.Name);
        Assert.NotNull(normalized);
        Assert.True(normalized.FactorToBase > 0, 
            $"Unit {definition.Name} should have positive factor to base");
    }
}
```

**Test: Dimensionless unit resolution**
```csharp
[Fact]
public void Resolve_Percentage_ResolvesToCorrectFactor()
{
    // Arrange
    var resolver = UnitResolver.Instance;
    var expectedFactor = 0.01m; // 1% = 0.01 of dimensionless base (empty string = 1)
    
    // Act
    var normalized = resolver.Resolve("%");
    
    // Assert
    Assert.Equal(expectedFactor, normalized.FactorToBase);
    Assert.Equal(UnitTypeEnum.Scalar, normalized.UnitType);
}

[Fact]
public void Resolve_PartsPerMillion_ResolvesToCorrectFactor()
{
    // Arrange
    var resolver = UnitResolver.Instance;
    var expectedFactor = 0.000001m; // 1 ppm = 0.000001 of base
    
    // Act
    var normalized = resolver.Resolve("ppm");
    
    // Assert
    Assert.Equal(expectedFactor, normalized.FactorToBase);
    Assert.Equal(UnitTypeEnum.Scalar, normalized.UnitType);
}

[Fact]
public void Resolve_DimensionlessConversions_WorkCorrectly()
{
    // Arrange
    var resolver = UnitResolver.Instance;
    
    // Act - resolve different dimensionless representations
    var percent50 = resolver.Resolve("%");  // 0.01 base factor
    var ppm1M = resolver.Resolve("ppm");    // 0.000001 base factor
    var each = resolver.Resolve("each");    // 1.0 base factor
    
    // Assert - verify conversions
    // 50% = 50 * 0.01 = 0.5 (dimensionless)
    // 1,000,000 ppm = 1,000,000 * 0.000001 = 1 (dimensionless)
    // "each" is optional alias for empty string base
    Assert.Equal(0.01m, percent50.FactorToBase);
    Assert.Equal(0.000001m, ppm1M.FactorToBase);
    Assert.Equal(1.0m, each.FactorToBase);
}
```

**Test: Performance benchmark (S-006 validation)**
```csharp
[Fact]
public void Parse_CommonUnit_CompletesInLessThan100Nanoseconds()
{
    // Arrange
    var sw = System.Diagnostics.Stopwatch.StartNew();
    var iterations = 10000;
    
    // Act
    for (int i = 0; i < iterations; i++)
    {
        _ = UnitDefinitions.Parse("in");
    }
    sw.Stop();
    
    // Assert
    var averageNanoseconds = (sw.Elapsed.TotalMilliseconds * 1_000_000) / iterations;
    Assert.True(averageNanoseconds < 100, 
        $"Parse should complete in <100ns, actual: {averageNanoseconds:F2}ns");
}

[Fact]
public void IsValidUnit_CompletesInLessThan100Nanoseconds()
{
    // Arrange
    var sw = System.Diagnostics.Stopwatch.StartNew();
    var iterations = 10000;
    
    // Act
    for (int i = 0; i < iterations; i++)
    {
        _ = UnitDefinitions.IsValidUnit("meter");
    }
    sw.Stop();
    
    // Assert
    var averageNanoseconds = (sw.Elapsed.TotalMilliseconds * 1_000_000) / iterations;
    Assert.True(averageNanoseconds < 100, 
        $"IsValidUnit should complete in <100ns, actual: {averageNanoseconds:F2}ns");
}

[Fact]
public void UnitDefinitions_StaticInitialization_CompletesInLessThan10Milliseconds()
{
    // This test validates startup time by measuring a fresh AppDomain load
    // In practice, validate during manual testing or with BenchmarkDotNet
    // Placeholder for documentation purposes
    Assert.True(true, "Startup time validated manually: <10ms");
}
```

### Test Execution

- **Unit Tests**: `dotnet test --filter "FullyQualifiedName~UnitResolverTests|FullyQualifiedName~UnitTokenTests"`
- **Performance Tests**: `dotnet test --filter "FullyQualifiedName~UnitDefinitionsPerformanceTests"`
- **Success Criteria**: 100% pass rate, no warnings, performance targets met
- **Coverage Analysis**: Use `dotnet-coverage` to verify ≥85% coverage
  ```bash
  dotnet-coverage collect -f cobertura -o coverage.cobertura.xml dotnet test
  ```

---

## Technical Notes

### Design Decisions

**1. Why UnitToken as a struct?**
- **Rationale**: Small (single string reference), used frequently as dictionary keys, benefits from value semantics
- **Trade-off**: Slightly more stack allocation vs fewer heap allocations overall
- **Decision**: Use readonly struct for performance and value semantics

**2. Internal visibility for all components?**
- **Rationale**: Not yet validated as public API; allows iteration without breaking changes
- **Decision**: Keep internal for F-003; may promote to public in F-012 if needed

**3. Singleton vs instance-per-call?**
- **Rationale**: `UnitResolver` is stateless (all data in readonly dictionaries); singleton avoids repeated initialization
- **Decision**: Singleton pattern with `Instance` property; thread-safe immutable data

**4. Case sensitivity policy?**
- **Rationale**: Existing Tare behavior is case-insensitive for user friendliness
- **Decision**: Use `StringComparer.OrdinalIgnoreCase` for alias lookups

**5. Base unit selection criteria?**
- **Rationale**: Prefer SI base units; use commonly accepted derived units where no base exists (e.g., Newton for Force)
- **Decision**: Follow SI standards; document in `BaseUnitMap` comments

**6. Factor representation: decimal vs Rational?**
- **Rationale**: E-001 decided to start with `decimal` pending S-005 spike results
- **Decision**: Use `decimal` for F-003; mechanical swap to `Rational` if S-005 recommends it

**7. UnitDefinitions optimization approach (S-006)?**
- **Rationale**: Linear search O(n) is bottleneck; dictionary-based O(1) lookups provide 100-1000x improvement
- **Decision**: Implement S-006 Option 1 alongside existing structure (not replace); maintain full backward compatibility
- **Trade-off**: +150-200KB memory for 100-1000x performance improvement (acceptable)

**8. Should UnitResolver rebuild indexes or reuse UnitDefinitions indexes?**
- **Rationale**: Avoid duplication; UnitDefinitions already has optimized indexes after Phase 0
- **Decision**: UnitResolver reuses `UnitDefinitions.AliasIndex` via internal accessor; no duplication

### Integration Points

**With UnitDefinitions:**
- **Phase 0 (Optimization)**: Add internal dictionary indexes to UnitDefinitions
- **Phase 2 (Resolver)**: UnitResolver reuses optimized indexes via `UnitDefinitions.AliasIndex`
- Use `Factor` property for base conversion (currently `decimal`)
- Respect `UnitType` for dimension categorization
- Zero duplication: single source of truth for alias → definition mapping

**With F-002 (DimensionSignature):**
- Add `Signature` property to `NormalizedUnit`
- Map `UnitTypeEnum` → `DimensionSignature` in resolver
- Compute signatures during resolution (deferred to F-004 integration)

**With F-004 (Dimensional Math Engine):**
- `UnitResolver` provides normalized tokens and factors for engine input
- Engine uses signatures from `NormalizedUnit` for dimensional algebra
- Factor ratios determine value scaling in multiplication/division

**With F-007 (Quantity Operators):**
- Operators call `UnitResolver.Resolve()` on operand units
- Compare signatures to validate compatibility
- Use factors to compute result values

### Performance Characteristics

**After S-006 Optimization:**

| Operation | Before | After | Improvement | Notes |
|-----------|--------|-------|-------------|-------|
| Parse (common) | O(n) ~0.5μs | O(1) ~0.05μs | **10x faster** | Dictionary lookup |
| Parse (rare) | O(n) ~5μs | O(1) ~0.05μs | **100x faster** | Position-independent |
| IsValidUnit | O(n*m) ~2μs | O(1) ~0.05μs | **40x faster** | Dictionary containment |
| Normalize | O(n) ~1μs | O(1) ~0.05μs | **20x faster** | Reuses UnitDefinitions index |
| Resolve | O(n) ~2μs | O(1) ~0.1μs | **20x faster** | Lookup + computation |
| Initialization | O(n) ~1ms | O(n) ~5-10ms | **One-time cost** | Build indexes at startup |

**Memory footprint**:
- UnitDefinitions indexes: ~150-200KB (alias map, name map, type map)
- UnitResolver: ~0KB additional (reuses UnitDefinitions indexes)
- Token-to-definition map: ~50KB (minimal)
- **Total: ~250KB** (well under 500KB budget)

---

## Risk Assessment

### Technical Risks

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| **Ambiguous aliases** | Low | High | Validate alias uniqueness during initialization; throw if duplicate |
| **Missing base unit** | Low | Medium | Define base for all UnitTypeEnum values; throw clear exception if missing |
| **Factor precision loss** | Low | Medium | Use `decimal`; S-005 will validate sufficiency; ready to swap to `Rational` |
| **Performance regression** | Low | Low | Dictionary lookups are O(1); benchmark if needed in F-010 |

### Design Risks

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| **Incompatible base units** | Low | High | Choose SI-standard base units; document rationale |
| **Signature mismatch with F-002** | Medium | High | Coordinate mapping; validate in integration tests |
| **API stability for future public exposure** | Medium | Medium | Design as if public (clean interface); keep internal for now |

### Integration Risks

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| **UnitDefinitions schema change** | Low | Medium | Encapsulate parsing in resolver; use defensive copies |
| **F-004 needs different data structure** | Medium | Medium | Review F-004 requirements; iterate resolver API if needed |
| **Backward compatibility break** | Low | High | Validate factors match existing conversions; add regression tests |

### Testing Risks

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| **Incomplete alias coverage** | Medium | Medium | Test all definitions; manual review of aliases list |
| **Floating-point comparison issues** | Low | Low | Use appropriate tolerances; prefer exact decimal comparison |
| **Missing edge cases** | Medium | Medium | Systematic test matrix; code review checklist |

### S-006 Integration Risks

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| **Dictionary memory exceeds budget** | Low | Medium | Monitor during testing; stay under 500KB total |
| **Startup time exceeds 10ms** | Low | Low | Benchmark static initialization; optimize if needed |
| **Duplicate alias handling** | Medium | High | Validate all aliases unique; log warnings for duplicates |
| **Breaking existing API behavior** | Low | High | Comprehensive regression tests; exact error message matching |
| **Performance not meeting targets** | Low | Medium | Benchmark Parse/IsValidUnit <0.1μs; iterate if needed |
| **Index corruption or inconsistency** | Low | High | Unit tests validate all definitions indexed; no missing entries |

---

## Dependencies

### Prerequisite Features

- **None** (uses existing `UnitDefinitions`)
- **Optional**: F-001 (Rational) if S-005 determines need; F-003 designed to swap decimal→Rational easily

### Dependent Features

- **F-004 (Dimensional Math Engine)**: Primary consumer; needs normalized units and factors
- **F-005 (Known-Signature Naming Map)**: Uses normalized tokens for signature → name mapping
- **F-006 (Composite Unit Formatter)**: Uses canonical tokens for stable formatting
- **F-007 (Quantity Operators)**: Calls resolver during multiplication/division

### External Dependencies

- None (pure .NET; leverages existing `UnitDefinitions`)

---

## Quality Checklist (Mandatory Verification)

### Domain Design Validation (REQUIRED)

- [ ] **Domain Model**: I have verified that `UnitToken`, `NormalizedUnit`, and `UnitResolver` properly model unit normalization and resolution concepts.
- [ ] **Ubiquitous Language**: I have confirmed consistent terminology (Unit, Alias, Canonical Token, Base Unit, Factor, Normalize, Resolve).
- [ ] **SOLID Principles Adherence**: I have verified SRP (resolver focused on normalization) and DIP (depends on abstractions).
- [ ] **Business Rules**: I have validated alias uniqueness, factor transitivity, and case-insensitive resolution.
- [ ] **Value Semantics**: I have confirmed immutability of value objects and proper equality implementation.

### Implementation Quality Validation (REQUIRED)

- [ ] **Test Coverage**: I have written comprehensive tests following `MethodName_Condition_ExpectedResult()` naming convention.
- [ ] **Test Execution**: All tests pass on both netstandard2.0 and net7.0 target frameworks.
- [ ] **Performance**: I have considered O(1) lookups and minimal allocations.
- [ ] **Performance Benchmarks (S-006)**: I have validated Parse/IsValidUnit <0.1μs and memory <500KB.
- [ ] **Documentation**: I have documented design decisions, base unit choices, and integration points.
- [ ] **.NET Best Practices**: I have followed .NET best practices for value types, dictionaries, and singletons.

### Precision & Compliance Validation (REQUIRED)

- [ ] **Numeric Precision**: I have used `decimal` for exact factor representation.
- [ ] **Conversion Accuracy**: I have validated factors match existing Tare conversion behavior.
- [ ] **Deterministic Behavior**: I have ensured normalization is deterministic and locale-independent.
- [ ] **Backward Compatibility**: I have verified no breaking changes to existing conversion results.
- [ ] **Backward Compatibility (S-006)**: I have verified all existing UnitDefinitions tests pass unchanged.

### Integration Validation (REQUIRED)

- [ ] **UnitDefinitions Compatibility**: I have verified all definitions parse and resolve correctly.
- [ ] **UnitDefinitions Optimization (S-006)**: I have validated dictionary indexes are built correctly and reused by UnitResolver.
- [ ] **F-002 Readiness**: I have prepared `NormalizedUnit` for signature integration.
- [ ] **F-004 Readiness**: I have designed resolver API suitable for dimensional math engine consumption.
- [ ] **No Public API Changes**: I have confirmed all new types are internal.

---

## Completion Criteria

### Definition of Done

1. [ ] All code implemented, reviewed, and merged to feature branch
2. [ ] All unit tests pass on both target frameworks
3. [ ] Code coverage ≥85% for `UnitResolver` and related types
4. [ ] XML documentation complete for all members
5. [ ] Code review completed by at least one reviewer
6. [ ] CHANGELOG.md updated with internal implementation note
7. [ ] No compiler warnings related to new code
8. [ ] Integration readiness validated (F-004 developer confirms API suitability)

### Acceptance Sign-Off

- [ ] Feature owner approval: Normalization and resolution work correctly for all defined units
- [ ] Code reviewer approval: Code quality, SOLID adherence, and test coverage meet standards
- [ ] Integration validation: F-004 developer confirms resolver API is suitable for dimensional math engine

---

## Open Questions

### Resolved Decisions

1. **Q**: Should we support composite unit normalization (e.g., "kg*m/s²")?  
   **A**: No, not in F-003. Composite parsing deferred to F-009. F-003 focuses on single-unit normalization only.

2. **Q**: What if two definitions have the same canonical name but different UnitTypes?  
   **A**: Validation error during initialization. Each canonical token must be unique across all definitions.

3. **Q**: How to handle temperature offsets (°C vs K, °F vs R)?  
   **A**: Out of scope for F-003. Temperature handling requires special logic; defer to dedicated feature.

4. **Q**: Should `IsValidUnit()` return true for aliases?  
   **A**: Yes. All aliases are valid if they resolve to a known canonical token.

5. **Q**: Case sensitivity for canonical tokens internally?  
   **A**: Store canonical tokens as-is from definitions; use case-insensitive comparison for alias resolution.

### Open Questions for Review

1. **Q**: Should we expose `UnitToken` as a public type in future?  
   **Open**: Defer decision to F-012 (API Helpers). Keep internal for now; review user demand.

2. **Q**: Should we cache resolved `NormalizedUnit` instances?  
   **Open**: Defer comprehensive caching to F-010 (Performance). Start with simple dictionary caching; optimize if profiling indicates need.

3. **Q**: What if a UnitType is added to enum without a base unit defined?  
   **Open**: Throw `InvalidOperationException` during initialization; require base units for all types. Add validation test.

---

## Files to Create/Modify

### New Files

- `src/Internal/Units/UnitToken.cs` — Canonical unit identifier value object
- `src/Internal/Units/NormalizedUnit.cs` — Resolved unit with token, factor, signature
- `src/Internal/Units/IUnitResolver.cs` — Resolver service interface
- `src/Internal/Units/UnitResolver.cs` — Resolver service implementation
- `src/Internal/Units/BaseUnitMap.cs` — Static base unit configuration
- `tests/UnitTokenTests.cs` — UnitToken value object tests
- `tests/UnitResolverTests.cs` — Resolver service tests

### Modified Files

- `src/UnitDefinitions.cs` — Add internal dictionary indexes (S-006 Option 1)
- `docs/CHANGELOG.md` — Document F-003 implementation and S-006 performance improvements

### Documentation

- XML comments on all types and members
- Code comments explaining base unit choices and alias resolution logic
- Performance characteristics documented (O(1) lookups, memory footprint)

---

## Timeline

**Estimated Effort**: 2–3 days (L) — includes S-006 Option 1 integration

### Day 1 (7-8 hours)

- **Morning (3-4 hours)**: 
  - Phase 0: UnitDefinitions dictionary optimization
  - Add dimensionless units (%, ppm, ppb, ppt)
  - Build internal indexes
  - Update existing methods to use dictionaries
  - Write performance tests
- **Afternoon (4 hours)**: 
  - Phase 1: UnitToken and NormalizedUnit value objects
  - BaseUnitMap configuration
  - Unit tests for value objects

### Day 2 (8 hours)

- **Morning (4-5 hours)**: 
  - Phase 2: UnitResolver service implementation
  - Reuse UnitDefinitions indexes
  - Error handling and singleton pattern
- **Afternoon (3-4 hours)**: 
  - Phase 3: Comprehensive testing (Part 1)
  - UnitResolver tests
  - Alias resolution tests
  - Factor computation tests

### Day 3 (3-4 hours)

- **Morning (2 hours)**: 
  - Phase 3: Comprehensive testing (Part 2)
  - Performance benchmarks
  - Backward compatibility validation
- **Afternoon (2 hours)**: 
  - Phase 4: Integration and documentation
  - Code review
  - Documentation updates
  - Final validation

### Contingency

- Additional time if dictionary memory profiling reveals issues
- Additional time if performance targets not met (requires optimization)
- Additional time if duplicate aliases discovered (requires resolution strategy)

---

## References

### Internal References

- **Epic E-001**: Option A Hybrid Core (Dimension vectors + catalog naming)
- **S-006**: UnitDefinitions Architecture Analysis (integrated as Phase 0)
- **F-001**: Core rational arithmetic (optional dependency)
- **F-002**: Dimension signature model (integration point)
- **F-004**: Dimensional math engine (primary consumer)
- **S-005**: Decimal precision spike (determines decimal vs Rational choice)

### External References

- **SI Units**: https://www.nist.gov/pml/owm/metric-si/si-units
- **Unit Conversion Standards**: https://en.wikipedia.org/wiki/Conversion_of_units
- **Frink Units Database**: https://frinklang.org/frinkdata/units.txt (inspiration for alias handling)

---

## Revision History

| Version | Date | Author | Changes |
|---------|------|--------|---------|
| 1.0 | 2025-11-08 | Copilot Agent | Initial feature plan created per user request |
| 1.1 | 2025-11-08 | Copilot Agent | Integrated S-006 Option 1 (dictionary optimization) per user request |
| 1.2 | 2025-11-08 | Copilot Agent | Added dimensionless units (%, ppm, ppb, ppt) and Scalar base unit to implementation plan |
| 1.3 | 2025-11-08 | Copilot Agent | Corrected Scalar base unit to empty string "" (with "each" as optional alias) per user feedback |

---

**Ready for Review** ✅  
This feature plan integrates S-006 Option 1 (dictionary-based UnitDefinitions optimization) alongside the original F-003 scope. The combined implementation provides both unit normalization/resolution capabilities and 100-1000x performance improvements through O(1) dictionary lookups, while maintaining full backward compatibility with existing public API. Additionally, dimensionless representations (%, ppm, ppb, ppt) are included as `UnitTypeEnum.Scalar` units with proper base unit mapping (empty string "" as base, "each" as optional alias).
