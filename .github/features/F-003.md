# F-003: Unit Normalization and Alias Resolver

**Status**: Planned  
**Priority**: P1 (Must)  
**Effort**: M (1–2 days)  
**Epic**: E-001 — Option A Hybrid Core  
**Dependencies**: F-002 (Dimension Signature Model)

---

## Feature Overview

This feature delivers the unit normalization pipeline and alias resolution system for Tare's dimensional algebra engine. The normalizer leverages the existing `UnitDefinitions` catalog to convert unit strings (including aliases) into canonical tokens with their corresponding base factors and dimension signatures, enabling consistent unit handling across multiplication and division operations.

### User Story

As a Tare library maintainer, I want a normalization pipeline that resolves unit aliases to canonical representations with base factors, so that dimensional operations correctly combine and convert quantities regardless of which unit name or alias is used in construction or formatting.

### Context

F-003 is the third feature in the E-001 epic implementing Option A (Hybrid Core). It bridges F-002's dimension signature model with the existing `UnitDefinitions` catalog, providing the critical infrastructure for F-004's dimensional math engine to perform accurate cross-unit operations with proper factor resolution.

---

## Mandatory Thinking Process (DDD/.NET Guidelines)

### 1. Domain Analysis (REQUIRED)

#### Domain Concepts Involved

- **Unit**: A named measurement standard (e.g., "meter", "inch", "pound force")
- **Alias**: Alternative names for the same unit (e.g., "in", "inches" → "inch"; "lbf", "pound force" → "lbf")
- **Canonical Token**: The normalized, standard representation of a unit for internal processing
- **Base Factor**: The conversion multiplier from a unit to its base unit (e.g., inch → meter: 0.0254)
- **Normalization**: The process of converting any valid unit string (including aliases) to its canonical form
- **Unit Family**: Related units within the same dimensional type (Length, Mass, Time, etc.)

#### Aggregate Boundaries and Consistency Requirements

- **No Aggregates**: This feature operates on value objects and stateless services
- **UnitDefinition**: Remains the authoritative source for unit metadata (name, aliases, factor, dimension type)
- **Immutability**: All normalization operations are pure functions returning new values
- **Consistency**: Normalization must be deterministic—same input always produces same output

#### Ubiquitous Language Terms

- Unit, Alias, Canonical Name, Token, Factor, Base Unit, Normalize, Resolve, Unit Family, Unit Type, Dimension Signature, Compatible Units

#### Business Rules and Invariants

1. **Alias Resolution**: All aliases for a unit must resolve to the same canonical token
2. **Factor Consistency**: The factor for a unit must match across all aliases
3. **Case Insensitivity**: Unit and alias matching is case-insensitive (e.g., "IN", "In", "in" all resolve to "inch")
4. **Whitespace Tolerance**: Leading/trailing whitespace is trimmed during normalization
5. **Unknown Units**: Attempting to normalize an unknown unit throws a clear exception
6. **Dimension Type Preservation**: Normalization preserves the UnitType (Length, Mass, etc.)

### 2. Architecture Review (REQUIRED)

#### Layer Responsibilities

- **Domain Layer**: 
  - `UnitNormalizer` (internal): Stateless service for normalization operations
  - `NormalizedUnit` (internal): Value object holding canonical token, factor, signature, and unit type
  - Uses existing `UnitDefinitions` catalog as the source of truth
- **Application Layer**: N/A (this is a library)
- **Infrastructure Layer**: N/A (no persistence or external dependencies)

#### SOLID Principles Adherence

- **SRP**: `UnitNormalizer` has a single responsibility—resolving and normalizing units
- **OCP**: New units/aliases added via `UnitDefinitions` without modifying normalizer logic
- **LSP**: N/A (no inheritance hierarchy)
- **ISP**: Focused interface with minimal methods (`Normalize`, `IsKnownUnit`)
- **DIP**: Depends on `UnitDefinitions` abstraction, not specific implementations

#### Domain Events

- N/A — Normalization is a stateless, side-effect-free operation

#### Security Implications

- No user input directly processed (units come from controlled `Quantity` construction)
- No SQL, file I/O, or network operations
- Deterministic behavior prevents timing attacks
- No secrets or sensitive data involved

### 3. Implementation Planning (REQUIRED)

#### Value Objects to Create

**NormalizedUnit** (internal readonly struct):
```csharp
internal readonly struct NormalizedUnit
{
    public string CanonicalToken { get; }
    public decimal Factor { get; }
    public DimensionSignature Signature { get; }
    public UnitTypeEnum UnitType { get; }
}
```

#### Domain Services to Create

**UnitNormalizer** (internal static class):
```csharp
internal static class UnitNormalizer
{
    public static NormalizedUnit Normalize(string unit);
    public static bool IsKnownUnit(string unit);
    public static string GetCanonicalName(string unit);
}
```

#### Files to be Created/Modified

| File | Type | Justification |
|------|------|---------------|
| `src/Internal/Units/NormalizedUnit.cs` | New | Value object for normalized unit data |
| `src/Internal/Units/UnitNormalizer.cs` | New | Stateless service for normalization logic |
| `src/Internal/Units/UnitSignatureMap.cs` | New | Mapping from UnitDefinition to DimensionSignature |
| `tests/UnitNormalizerTests.cs` | New | Comprehensive tests for normalization |
| `src/UnitDefinitions.cs` | Modified | May need minor adjustments for internal access |
| `docs/CHANGELOG.md` | Modified | Document internal implementation note |

#### Test Cases (Following `MethodName_Condition_ExpectedResult()` Pattern)

**Normalization Tests:**
- `Normalize_InchAlias_ReturnsCanonicalInch()`
- `Normalize_PoundForceAlias_ReturnsCanonicalLbf()`
- `Normalize_MixedCaseUnit_NormalizesCorrectly()`
- `Normalize_WithWhitespace_TrimsAndNormalizes()`
- `Normalize_UnknownUnit_ThrowsArgumentException()`

**Alias Resolution Tests:**
- `ParseAliases_InchVariants_NormalizeToSameToken()`
- `ParseAliases_PoundForceVariants_NormalizeToSameToken()`
- `ParseAliases_MetricPrefixes_ResolveCorrectly()`

**Factor Tests:**
- `Normalize_Inch_ReturnsCorrectFactor()`
- `Normalize_Mile_ReturnsCorrectFactor()`
- `Normalize_AllAliases_ReturnSameFactorForUnit()`

**Signature Tests:**
- `Normalize_LengthUnit_ReturnsLengthSignature()`
- `Normalize_ForceUnit_ReturnsForceSignature()`
- `Normalize_TimeUnit_ReturnsTimeSignature()`

**Known Unit Tests:**
- `IsKnownUnit_ValidUnit_ReturnsTrue()`
- `IsKnownUnit_ValidAlias_ReturnsTrue()`
- `IsKnownUnit_UnknownUnit_ReturnsFalse()`
- `IsKnownUnit_CaseInsensitive_WorksCorrectly()`

**GetCanonicalName Tests:**
- `GetCanonicalName_Alias_ReturnsCanonicalName()`
- `GetCanonicalName_CanonicalName_ReturnsSelf()`
- `GetCanonicalName_UnknownUnit_ThrowsException()`

#### Error Handling and Validation Strategy

- **Unknown Units**: Throw `ArgumentException` with message "Unknown unit: '{unit}'. Use UnitDefinitions.IsValidUnit() to check validity."
- **Null/Empty Units**: Throw `ArgumentNullException` or `ArgumentException` with clear message
- **Internal Consistency**: Assert that all aliases for a unit return identical factor and signature values
- **Clear Messages**: All exception messages include the problematic unit string for debugging

#### Performance and Scalability Considerations

- **Caching**: Consider caching normalized results (defer to F-010 if performance measurements warrant)
- **Case-Insensitive Lookups**: Use `StringComparer.OrdinalIgnoreCase` for dictionary keys
- **Zero Allocations**: `NormalizedUnit` as readonly struct minimizes heap allocations
- **Lookup Efficiency**: O(1) dictionary lookup in `UnitDefinitions`
- **Lazy Initialization**: Build signature map lazily on first access

---

## Implementation Details

### UnitSignatureMap Design

The `UnitSignatureMap` provides the mapping from unit names to their dimension signatures. This mapping is derived from the `UnitTypeEnum` and dimensional analysis of each unit.

**Initial Signature Mapping Strategy:**

```csharp
internal static class UnitSignatureMap
{
    // Map UnitTypeEnum to base dimension signatures
    private static readonly Dictionary<UnitTypeEnum, DimensionSignature> _baseSignatures = new()
    {
        [UnitTypeEnum.Length] = DimensionSignature.Length,
        [UnitTypeEnum.Mass] = DimensionSignature.Mass,
        [UnitTypeEnum.Time] = DimensionSignature.Time,
        [UnitTypeEnum.Temperature] = DimensionSignature.Temperature,
        [UnitTypeEnum.Area] = DimensionSignature.Area,
        [UnitTypeEnum.Volume] = DimensionSignature.Volume,
        [UnitTypeEnum.Velocity] = DimensionSignature.Velocity,
        [UnitTypeEnum.Acceleration] = DimensionSignature.Acceleration,
        [UnitTypeEnum.Force] = DimensionSignature.Force,
        [UnitTypeEnum.Pressure] = DimensionSignature.Pressure,
        [UnitTypeEnum.Energy] = DimensionSignature.Energy,
        [UnitTypeEnum.Power] = DimensionSignature.Power,
        [UnitTypeEnum.Torque] = DimensionSignature.Energy, // Same as Energy
        // ... additional mappings
    };
    
    public static DimensionSignature GetSignature(UnitTypeEnum unitType);
    public static DimensionSignature GetSignature(string unitName);
}
```

### Normalization Algorithm

```
1. Input: unit string (e.g., "IN", " inch ", "inches", "lbf")
2. Trim whitespace: "IN" → "IN", " inch " → "inch"
3. Case-insensitive lookup in UnitDefinitions:
   a. Check if unit is a defined unit name
   b. If not, check if unit is in any alias set
4. If found:
   a. Extract UnitDefinition (Name, Factor, UnitType, Aliases)
   b. Look up DimensionSignature from UnitSignatureMap based on UnitType
   c. Construct NormalizedUnit with:
      - CanonicalToken = UnitDefinition.Name
      - Factor = UnitDefinition.Factor
      - Signature = from UnitSignatureMap
      - UnitType = UnitDefinition.UnitType
5. If not found:
   a. Throw ArgumentException with clear message
6. Return NormalizedUnit
```

### Design Decisions

1. **Readonly Struct for NormalizedUnit**: Value semantics, stack allocation, immutability
2. **Static Class for UnitNormalizer**: No state, pure functions, simple API
3. **Case-Insensitive Matching**: Enhances usability; users expect "M", "m", "Meter", "meter" to work
4. **Whitespace Trimming**: Defensive programming; handles user input quirks
5. **UnitTypeEnum as Signature Source**: Leverages existing type classification; single source of truth
6. **Lazy Map Initialization**: Defer dictionary construction until first use (performance optimization)
7. **Internal Visibility**: Not part of public API; implementation detail for F-004

---

## Specific Tasks

### Task 1: Create NormalizedUnit Value Object (1 hour)

- [ ] Create `src/Internal/Units/NormalizedUnit.cs` file
- [ ] Define readonly struct with four properties (CanonicalToken, Factor, Signature, UnitType)
- [ ] Implement constructor with validation
- [ ] Implement equality (`IEquatable<NormalizedUnit>`)
- [ ] Implement `GetHashCode()` and `ToString()` for debugging
- [ ] Add XML documentation

### Task 2: Create UnitSignatureMap (1.5 hours)

- [ ] Create `src/Internal/Units/UnitSignatureMap.cs` file
- [ ] Define static dictionary mapping `UnitTypeEnum` → `DimensionSignature`
- [ ] Populate initial mappings for common unit types:
  - Base dimensions: Length, Mass, Time, Temperature, ElectricCurrent, AmountOfSubstance, LuminousIntensity
  - Derived: Area, Volume, Velocity, Acceleration, Force, Pressure, Energy, Power, Torque
- [ ] Implement `GetSignature(UnitTypeEnum)` method
- [ ] Implement `GetSignature(string unitName)` method (lookup via UnitDefinitions)
- [ ] Add XML documentation
- [ ] Handle edge cases (unknown unit types, null inputs)

### Task 3: Implement UnitNormalizer Service (2 hours)

- [ ] Create `src/Internal/Units/UnitNormalizer.cs` file
- [ ] Implement `Normalize(string unit)` method:
  - Trim whitespace
  - Case-insensitive lookup in UnitDefinitions
  - Resolve aliases to canonical names
  - Build NormalizedUnit with factor and signature
  - Throw clear exception for unknown units
- [ ] Implement `IsKnownUnit(string unit)` method:
  - Return true if unit or alias exists in UnitDefinitions
  - Case-insensitive comparison
- [ ] Implement `GetCanonicalName(string unit)` method:
  - Return canonical name for unit or alias
  - Throw exception if unknown
- [ ] Add XML documentation
- [ ] Consider caching strategy (document decision; implement in F-010 if needed)

### Task 4: Write Comprehensive Unit Tests (3 hours)

- [ ] Create `tests/UnitNormalizerTests.cs` file
- [ ] **Normalization Tests** (6 tests):
  - Test inch normalization with various aliases
  - Test pound force normalization with aliases
  - Test mixed case handling
  - Test whitespace trimming
  - Test unknown unit exception
  - Test null/empty unit exception
- [ ] **Alias Resolution Tests** (4 tests):
  - Verify all inch aliases normalize identically
  - Verify all pound force aliases normalize identically
  - Test metric prefix aliases (km, mm, etc.)
  - Test US Customary aliases
- [ ] **Factor Tests** (3 tests):
  - Verify inch factor is correct
  - Verify mile factor is correct
  - Verify all aliases return same factor for their unit
- [ ] **Signature Tests** (5 tests):
  - Length units return Length signature
  - Force units return Force signature
  - Time units return Time signature
  - Energy units return Energy signature
  - Torque units return Energy signature (same dimensional composition)
- [ ] **Known Unit Tests** (4 tests):
  - Valid unit returns true
  - Valid alias returns true
  - Unknown unit returns false
  - Case insensitivity works
- [ ] **GetCanonicalName Tests** (3 tests):
  - Alias returns canonical name
  - Canonical name returns itself
  - Unknown unit throws exception
- [ ] Run tests and verify 100% pass rate

### Task 5: Integration with Existing UnitDefinitions (1 hour)

- [ ] Review `UnitDefinitions.cs` for internal access requirements
- [ ] Add internal accessor methods if needed for normalization
- [ ] Ensure all existing units in catalog have correct factors
- [ ] Verify consistency between `UnitTypeEnum` and actual dimensional composition
- [ ] Test edge cases (temperature, dimensionless quantities, etc.)

### Task 6: Documentation and Code Review (0.5 hour)

- [ ] Ensure all public/internal members have XML documentation
- [ ] Review code for SOLID principles and repository conventions
- [ ] Update `docs/CHANGELOG.md` with internal implementation note
- [ ] Add design decision notes to code comments where appropriate
- [ ] Verify no compiler warnings introduced

---

## Acceptance Criteria

### Functional Requirements

1. **Alias Resolution**: All defined aliases for a unit resolve to the same canonical token
2. **Factor Accuracy**: Normalized units return the correct conversion factor from `UnitDefinitions`
3. **Signature Correctness**: Each unit type maps to the correct dimension signature
4. **Case Insensitivity**: "INCH", "Inch", "inch", "IN", "in" all normalize identically
5. **Whitespace Handling**: Leading/trailing whitespace is trimmed during normalization
6. **Known Unit Detection**: `IsKnownUnit()` correctly identifies valid units and aliases
7. **Canonical Name Retrieval**: `GetCanonicalName()` returns the standard name for any valid unit or alias
8. **Unknown Unit Handling**: Attempting to normalize an unknown unit throws `ArgumentException` with clear message
9. **Null/Empty Handling**: Null or empty unit strings throw appropriate exceptions

### Non-Functional Requirements

10. **Immutability**: `NormalizedUnit` is immutable; all fields readonly
11. **Performance**: Normalization completes in O(1) time via dictionary lookup
12. **Thread-Safety**: Stateless design ensures thread-safe usage
13. **Internal Visibility**: All types marked internal; not exposed in public API
14. **Zero External Dependencies**: No new packages required

### Quality Requirements

15. **Test Coverage**: Minimum 85% code coverage for normalization logic
16. **Test Naming**: All tests follow `MethodName_Condition_ExpectedResult()` convention
17. **Documentation**: All members have clear XML documentation
18. **SOLID Compliance**: Design adheres to Single Responsibility Principle
19. **Consistency**: Normalization is deterministic and consistent across all calls

### Integration Requirements

20. **UnitDefinitions Compatibility**: Works seamlessly with existing unit catalog
21. **F-002 Integration**: Uses `DimensionSignature` from F-002 correctly
22. **F-004 Readiness**: API suitable for consumption by dimensional math engine

---

## Test Methodology

### Unit Test Strategy

**Framework**: NUnit (existing in repository)  
**Test File**: `tests/UnitNormalizerTests.cs`  
**Coverage Target**: ≥85% for normalization logic

### Test Categories

#### 1. Basic Normalization Tests

```csharp
[Test]
public void Normalize_InchAlias_ReturnsCanonicalInch()
{
    // Arrange
    var aliases = new[] { "in", "IN", "inch", "inches" };
    
    // Act & Assert
    foreach (var alias in aliases)
    {
        var normalized = UnitNormalizer.Normalize(alias);
        Assert.That(normalized.CanonicalToken, Is.EqualTo("inch"));
        Assert.That(normalized.UnitType, Is.EqualTo(UnitTypeEnum.Length));
    }
}

[Test]
public void Normalize_PoundForceAlias_ReturnsCanonicalLbf()
{
    // Arrange
    var aliases = new[] { "lbf", "LBF", "pound force", "pounds force" };
    
    // Act & Assert
    foreach (var alias in aliases)
    {
        var normalized = UnitNormalizer.Normalize(alias);
        Assert.That(normalized.CanonicalToken, Is.EqualTo("lbf"));
        Assert.That(normalized.UnitType, Is.EqualTo(UnitTypeEnum.Force));
    }
}

[Test]
public void Normalize_UnknownUnit_ThrowsArgumentException()
{
    // Arrange
    var unknownUnit = "furlongs_per_fortnight";
    
    // Act & Assert
    var ex = Assert.Throws<ArgumentException>(() => UnitNormalizer.Normalize(unknownUnit));
    Assert.That(ex.Message, Does.Contain(unknownUnit));
}
```

#### 2. Factor Consistency Tests

```csharp
[Test]
public void Normalize_InchAndAliases_ReturnSameFactor()
{
    // Arrange
    var aliases = new[] { "in", "inch", "inches" };
    
    // Act
    var factors = aliases.Select(a => UnitNormalizer.Normalize(a).Factor).Distinct().ToList();
    
    // Assert
    Assert.That(factors, Has.Count.EqualTo(1));
    Assert.That(factors[0], Is.EqualTo(0.0254m)); // inch to meter
}

[Test]
public void Normalize_MileToInch_ReturnsCorrectFactor()
{
    // Arrange
    var mile = UnitNormalizer.Normalize("mile");
    var inch = UnitNormalizer.Normalize("inch");
    
    // Act
    var ratio = mile.Factor / inch.Factor;
    
    // Assert
    Assert.That(ratio, Is.EqualTo(63360m)); // 1 mile = 63360 inches
}
```

#### 3. Signature Mapping Tests

```csharp
[Test]
public void Normalize_LengthUnits_ReturnLengthSignature()
{
    // Arrange
    var lengthUnits = new[] { "meter", "inch", "foot", "mile", "kilometer" };
    var expectedSignature = DimensionSignature.Length;
    
    // Act & Assert
    foreach (var unit in lengthUnits)
    {
        var normalized = UnitNormalizer.Normalize(unit);
        Assert.That(normalized.Signature, Is.EqualTo(expectedSignature));
    }
}

[Test]
public void Normalize_ForceUnits_ReturnForceSignature()
{
    // Arrange
    var forceUnits = new[] { "newton", "lbf", "pound force" };
    var expectedSignature = DimensionSignature.Force; // L¹M¹T⁻²
    
    // Act & Assert
    foreach (var unit in forceUnits)
    {
        var normalized = UnitNormalizer.Normalize(unit);
        Assert.That(normalized.Signature, Is.EqualTo(expectedSignature));
    }
}
```

#### 4. Known Unit Detection Tests

```csharp
[Test]
public void IsKnownUnit_ValidUnit_ReturnsTrue()
{
    // Arrange & Act & Assert
    Assert.That(UnitNormalizer.IsKnownUnit("meter"), Is.True);
    Assert.That(UnitNormalizer.IsKnownUnit("inch"), Is.True);
    Assert.That(UnitNormalizer.IsKnownUnit("lbf"), Is.True);
}

[Test]
public void IsKnownUnit_ValidAlias_ReturnsTrue()
{
    // Arrange & Act & Assert
    Assert.That(UnitNormalizer.IsKnownUnit("in"), Is.True);
    Assert.That(UnitNormalizer.IsKnownUnit("m"), Is.True);
    Assert.That(UnitNormalizer.IsKnownUnit("kg"), Is.True);
}

[Test]
public void IsKnownUnit_UnknownUnit_ReturnsFalse()
{
    // Arrange & Act & Assert
    Assert.That(UnitNormalizer.IsKnownUnit("flerg"), Is.False);
    Assert.That(UnitNormalizer.IsKnownUnit("unknown_unit"), Is.False);
}

[Test]
public void IsKnownUnit_CaseInsensitive_WorksCorrectly()
{
    // Arrange & Act & Assert
    Assert.That(UnitNormalizer.IsKnownUnit("METER"), Is.True);
    Assert.That(UnitNormalizer.IsKnownUnit("Meter"), Is.True);
    Assert.That(UnitNormalizer.IsKnownUnit("mEtEr"), Is.True);
}
```

#### 5. Edge Case Tests

```csharp
[Test]
public void Normalize_WithWhitespace_TrimsAndNormalizes()
{
    // Arrange & Act
    var normalized1 = UnitNormalizer.Normalize("  inch  ");
    var normalized2 = UnitNormalizer.Normalize("inch");
    
    // Assert
    Assert.That(normalized1, Is.EqualTo(normalized2));
}

[Test]
public void Normalize_NullUnit_ThrowsArgumentNullException()
{
    // Arrange & Act & Assert
    Assert.Throws<ArgumentNullException>(() => UnitNormalizer.Normalize(null));
}

[Test]
public void Normalize_EmptyUnit_ThrowsArgumentException()
{
    // Arrange & Act & Assert
    Assert.Throws<ArgumentException>(() => UnitNormalizer.Normalize(""));
    Assert.Throws<ArgumentException>(() => UnitNormalizer.Normalize("   "));
}
```

### Test Execution

1. **Local Development**: Run tests after each implementation step
   ```bash
   dotnet test --filter "FullyQualifiedName~UnitNormalizerTests"
   ```

2. **CI Pipeline**: Tests run automatically on PR creation and updates

3. **Coverage Analysis**: Use `dotnet-coverage` to verify ≥85% coverage
   ```bash
   dotnet-coverage collect -f cobertura -o coverage.cobertura.xml dotnet test
   ```

### Representative Test Data

#### Length Units (Sample)
- meter (m) → Factor: 1.0, Type: Length, Signature: L¹
- inch (in, inches) → Factor: 0.0254, Type: Length, Signature: L¹
- foot (ft, feet) → Factor: 0.3048, Type: Length, Signature: L¹
- mile (mi, miles) → Factor: 1609.344, Type: Length, Signature: L¹

#### Force Units (Sample)
- newton (N) → Factor: 1.0, Type: Force, Signature: L¹M¹T⁻²
- lbf (pound force, pounds force) → Factor: 4.4482216152605, Type: Force, Signature: L¹M¹T⁻²

#### Energy Units (Sample)
- joule (J) → Factor: 1.0, Type: Energy, Signature: L²M¹T⁻²
- Nm (newton meter) → Factor: 1.0, Type: Torque, Signature: L²M¹T⁻² (same as Energy)

---

## Risk Assessment

### Technical Risks

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| **Inconsistent UnitDefinitions data** | Medium | High | Validate all units have correct factors; add consistency tests |
| **Missing dimension signatures** | Low | Medium | Populate all UnitTypeEnum values in signature map; assert exhaustiveness |
| **Performance degradation** | Low | Medium | Use O(1) dictionary lookups; defer caching to F-010 unless measured |
| **Alias collision** | Low | High | Validate no alias appears for multiple units; add uniqueness test |

### Design Risks

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| **UnitTypeEnum doesn't match actual dimensions** | Medium | High | Review all UnitDefinitions; cross-reference with physics standards |
| **Future composite units not supported** | Medium | Low | Design allows extension; composite parsing deferred to F-009 |
| **Signature map incomplete** | Low | Medium | Start with common units; expand iteratively; document coverage |

### Integration Risks

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| **Mismatch with F-002 signatures** | Low | High | Coordinate closely; validate signature values match expected dimensions |
| **Breaking changes to UnitDefinitions** | Low | High | Maintain backward compatibility; add internal accessors without changing public API |
| **F-004 integration issues** | Medium | Medium | Document API contract clearly; provide usage examples |

### Testing Risks

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| **Incomplete alias coverage** | Medium | Medium | Systematic test of all defined aliases; automated generation from catalog |
| **Missing edge cases** | Medium | Low | Include null, empty, whitespace, mixed case, unknown units |
| **Test data staleness** | Low | Low | Tests reference actual UnitDefinitions; fail if catalog changes unexpectedly |

---

## Dependencies

### Prerequisite Features

- **F-002 (Dimension Signature Model)**: Required for signature assignment in `NormalizedUnit`

### Dependent Features

- **F-004 (Dimensional Math Engine)**: Primary consumer of normalization pipeline
- **F-005 (Known-signature naming map)**: Uses normalized units for reverse mapping
- **F-006 (Composite unit formatter)**: Relies on normalized units for token handling

### External Dependencies

- None (pure .NET implementation using existing `UnitDefinitions`)

---

## Quality Checklist

### Domain Design Validation (REQUIRED)

- [ ] **Domain Model**: I have verified that `NormalizedUnit` and `UnitNormalizer` properly model the normalization domain concept
- [ ] **Ubiquitous Language**: I have confirmed consistent terminology (Unit, Alias, Canonical Token, Factor, Normalize, Signature)
- [ ] **SOLID Principles Adherence**: I have verified the design follows SRP (normalization is a single, focused responsibility)
- [ ] **Business Rules**: I have validated that alias resolution, case insensitivity, and factor consistency rules are correctly encapsulated
- [ ] **Value Semantics**: I have confirmed `NormalizedUnit` immutability and proper equality implementation

### Implementation Quality Validation (REQUIRED)

- [ ] **Test Coverage**: I have written comprehensive tests following `MethodName_Condition_ExpectedResult()` naming convention
- [ ] **Test Execution**: All tests pass on both netstandard2.0 and net7.0 target frameworks
- [ ] **Performance**: I have considered performance implications; O(1) dictionary lookups ensure efficiency
- [ ] **Documentation**: I have documented design decisions, normalization algorithm, and signature mapping strategy
- [ ] **.NET Best Practices**: I have followed .NET best practices for value types, static services, and exception handling

### Code Quality Validation (REQUIRED)

- [ ] **Immutability**: `NormalizedUnit` fields are readonly; no mutable state
- [ ] **Thread-Safety**: Stateless design ensures thread-safe usage
- [ ] **Error Handling**: Clear exceptions for unknown units, null inputs, and edge cases
- [ ] **Internal Visibility**: All types marked internal; not exposed in public API
- [ ] **Deterministic Behavior**: Same input always produces same output; no randomness or timing dependencies

### Integration Validation (REQUIRED)

- [ ] **UnitDefinitions Compatibility**: Normalization works correctly with existing unit catalog
- [ ] **F-002 Integration**: Dimension signatures from F-002 used correctly in normalized units
- [ ] **F-004 Readiness**: API suitable for consumption by dimensional math engine
- [ ] **No Breaking Changes**: No modifications to existing public API surface

---

## Completion Criteria

### Definition of Done

1. [ ] All code implemented, reviewed, and merged to feature branch
2. [ ] All unit tests pass on both target frameworks
3. [ ] Code coverage ≥85% for normalization logic
4. [ ] XML documentation complete for all internal members
5. [ ] Code review completed by at least one reviewer
6. [ ] `docs/CHANGELOG.md` updated with internal implementation note
7. [ ] No compiler warnings related to new code
8. [ ] Integration readiness validated (F-004 can consume normalization API)

### Acceptance Sign-Off

- [ ] Feature owner approval: Normalization correctly resolves all defined units and aliases
- [ ] Code reviewer approval: Code quality and test coverage meet standards
- [ ] Integration validation: F-004 developer confirms normalization API is suitable

---

## Notes and Open Questions

### Design Decisions Recorded

1. **Case-Insensitive Matching**: Decided to implement case-insensitive alias resolution for usability. Rationale: Users expect "M", "m", "Meter", "meter" to work identically; reduces friction.

2. **Whitespace Trimming**: Decided to trim leading/trailing whitespace during normalization. Rationale: Defensive programming; handles copy-paste errors and user input quirks.

3. **Static Service**: `UnitNormalizer` implemented as static class with pure functions. Rationale: No state needed; simple API; avoids unnecessary instantiation.

4. **Readonly Struct for NormalizedUnit**: Decided on readonly struct for value semantics and performance. Rationale: Small object (string + decimal + struct + enum); stack allocation; suitable for temporary values.

5. **UnitTypeEnum as Signature Source**: Decided to derive signatures from existing `UnitTypeEnum`. Rationale: Leverages existing classification; single source of truth; avoids duplication.

6. **Internal Visibility**: All types marked internal. Rationale: Implementation detail for F-004; premature API exposure avoided; can be promoted later if needed.

7. **Deferred Caching**: Decided not to implement caching in F-003. Rationale: Premature optimization; dictionary lookup is already O(1); defer to F-010 if measurements warrant.

### Open Questions

1. **Should we support temperature offset conversions (Celsius/Fahrenheit)?**
   - Concern: Temperature conversions require both factor and offset (e.g., C = (F - 32) * 5/9)
   - Current plan: F-003 handles only factor-based conversions; temperature conversion policy TBD
   - Decision: Document limitation; revisit in F-004 or later

2. **Should normalization cache results?**
   - Concern: Repeated normalization of common units (e.g., "inch") may cause performance overhead
   - Current plan: No caching in F-003; measure performance in F-010
   - Decision: Start without caching; add if benchmarks demonstrate need

3. **How to handle compound units (e.g., "lbf*in")?**
   - Concern: Composite units not supported in F-003
   - Current plan: F-003 normalizes single units only; composite parsing in F-009
   - Decision: Throw `ArgumentException` for composite units in F-003; document limitation

4. **Should we validate signature-to-UnitType consistency?**
   - Concern: UnitTypeEnum may not perfectly align with dimensional analysis
   - Current plan: Start with UnitTypeEnum mapping; validate with physics expert review
   - Decision: Add consistency tests; review all mappings; document any special cases

5. **What about dimensionless quantities (scalars)?**
   - Concern: Scalars have no units but need representation
   - Current plan: Define a "dimensionless" or "scalar" unit type with zero signature
   - Decision: Address in F-004 when implementing scalar operations

---

## Files to Create/Modify

### New Files

- `src/Internal/Units/NormalizedUnit.cs` — Value object for normalized unit data
- `src/Internal/Units/UnitNormalizer.cs` — Stateless service for normalization logic
- `src/Internal/Units/UnitSignatureMap.cs` — Mapping from UnitTypeEnum to DimensionSignature
- `tests/UnitNormalizerTests.cs` — Comprehensive unit tests

### Modified Files

- `src/UnitDefinitions.cs` — May need internal accessor methods (minimal changes)
- `docs/CHANGELOG.md` — Add internal implementation note for F-003

### Documentation

- `docs/CHANGELOG.md` — Internal note on normalization pipeline
- (Optional) `docs/internal/Normalization.md` — Design notes on alias resolution (defer to F-013)

---

## Timeline

**Estimated Effort**: 1–2 days (M)

### Day 1 (4-5 hours)

- **Morning (2-2.5 hours)**: 
  - Create `NormalizedUnit` value object (Task 1)
  - Create `UnitSignatureMap` and populate initial mappings (Task 2)
- **Afternoon (2-2.5 hours)**:
  - Implement `UnitNormalizer.Normalize()` method (Task 3)
  - Implement `IsKnownUnit()` and `GetCanonicalName()` helpers (Task 3)

### Day 2 (3-4 hours)

- **Morning (2-2.5 hours)**:
  - Write comprehensive unit tests (Task 4)
  - Test normalization, aliases, factors, signatures
- **Afternoon (1-1.5 hours)**:
  - Integration with `UnitDefinitions` (Task 5)
  - Documentation and code review (Task 6)
  - Run full test suite and validate coverage

### Contingency

- Additional time if `UnitDefinitions` requires structural changes for internal access
- Additional time if signature map reveals inconsistencies in `UnitTypeEnum` classification
- Additional time if test coverage below 85% requires additional test cases

---

## References

- **Epic E-001**: Option A Hybrid Core (Dimension vectors + catalog naming)
- **F-001**: Core rational arithmetic (provides pattern for value objects)
- **F-002**: Dimension signature model (prerequisite for signature assignment)
- **F-004**: Dimensional math engine (primary consumer of normalization)
- **SI Units Reference**: https://www.nist.gov/pml/owm/metric-si/si-units
- **UnitDefinitions**: Existing unit catalog (source of truth for units, aliases, factors)

---

## Revision History

| Version | Date | Author | Changes |
|---------|------|--------|---------|
| 1.0 | 2025-11-08 | Copilot Agent | Initial feature plan created per user request |

---

**Ready for Review** ✅  
This feature plan is complete and awaits user review and approval before implementation begins.
