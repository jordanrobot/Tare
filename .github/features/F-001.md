# F-001: Core Rational Arithmetic

**Status**: Planned  
**Epic**: E-001 — Option A Hybrid Core (Dimension vectors + catalog naming)  
**Priority**: P1 (Must)  
**Effort**: M (1–2 days)  
**Dependencies**: None (foundational feature)

---

## Description

Deliver a `Rational` value object (internal, readonly struct) that represents exact fractional values as numerator/denominator pairs. This foundation enables precise unit conversion factors without cumulative floating-point drift, essential for the dimensional algebra engine planned in E-001.

The `Rational` type will encapsulate:
- Exact fraction representation (numerator/denominator as `long`)
- Automatic normalization (GCD reduction, sign handling)
- Basic arithmetic operations (multiply, divide, add, subtract)
- Bridging to/from `decimal` for integration with existing `Quantity` value type
- Equality, comparison, and hashing for use in collections and caching

---

## User Story

**As a** developer implementing dimensional unit algebra  
**I want** exact rational arithmetic for unit conversion factors  
**So that** conversions between units maintain precision without floating-point drift

---

## Mandatory Thinking Process (DDD/.NET Guidelines)

### 1) Domain Analysis (REQUIRED)

**Domain concepts involved:**
- **Rational** — An immutable value object representing an exact fraction (numerator/denominator)
- **Factor** — The conversion multiplier between units, currently stored as `decimal` in `UnitDefinition`
- **Conversion** — The operation of transforming a quantity from one unit to another
- **Normalization** — Reducing fractions to simplest form (GCD) and canonical sign

**Aggregate boundaries and consistency requirements:**
- `Rational` is a value object, not an aggregate root
- Immutability ensures thread safety and value semantics
- Consistency maintained through automatic normalization in constructor
- No persistence layer; purely computational domain object

**Ubiquitous language terms:**
- Rational, Numerator, Denominator, Factor, Normalize, GCD (Greatest Common Divisor), Reciprocal, Simplify

**Business rules and invariants:**
- Denominator must never be zero (enforced via constructor validation)
- Sign canonically stored in numerator (denominator always positive)
- Automatically normalized to simplest form (GCD reduction)
- Operations produce normalized results
- Zero represented uniquely as 0/1

### 2) Architecture Review (REQUIRED)

**Layer responsibilities:**
- **Domain Layer**: `Rational` value object encapsulates arithmetic logic
- **Application Layer**: N/A (this is a library, not an application)
- **Infrastructure Layer**: N/A (no persistence or external dependencies)

**SOLID principles adherence:**
- **SRP**: `Rational` has single responsibility—exact fraction arithmetic
- **OCP**: Closed for modification (readonly struct), open for use in higher-level operations
- **LSP**: N/A (no inheritance hierarchy)
- **ISP**: Implements minimal interfaces (`IEquatable<Rational>`, `IComparable<Rational>`)
- **DIP**: No dependencies on concretions; pure value logic

**Domain events:**
- N/A — `Rational` is a stateless value object with no side effects

**Security implications:**
- No security concerns; purely computational
- No user input directly processed (values come from controlled unit definitions)
- Overflow protection via checked arithmetic operations

### 3) Implementation Planning (REQUIRED)

**Files to be created/modified:**

| File | Type | Justification |
|------|------|---------------|
| `src/Internal/Rational.cs` | New | Core `Rational` value object implementation |
| `tests/RationalTests.cs` | New | Comprehensive unit tests for `Rational` |
| `docs/CHANGELOG.md` | Modified | Document internal addition (note: not public API) |

**Test cases (following `MethodName_Condition_ExpectedResult()` pattern):**

Normalization:
- `Constructor_PositiveFraction_NormalizesToSimplestForm()`
- `Constructor_NegativeNumerator_MaintainsNegativeSign()`
- `Constructor_NegativeDenominator_MovesSignToNumerator()`
- `Constructor_ZeroNumerator_NormalizesToZeroOverOne()`
- `Constructor_ZeroDenominator_ThrowsArgumentException()`
- `Constructor_CommonFactor_ReducesViaGCD()`

Arithmetic:
- `Multiply_TwoRationals_ReturnsNormalizedProduct()`
- `Multiply_ByZero_ReturnsZero()`
- `Divide_TwoRationals_ReturnsNormalizedQuotient()`
- `Divide_ByZero_ThrowsDivideByZeroException()`
- `Add_SameDenominator_ReturnsNormalizedSum()`
- `Add_DifferentDenominators_FindsCommonDenominator()`
- `Subtract_TwoRationals_ReturnsNormalizedDifference()`

Conversion:
- `ToDecimal_SimpleFraction_ReturnsExactValue()`
- `ToDecimal_RepeatingFraction_TruncatesAsExpected()`
- `FromDecimal_WholeNumber_CreatesIntegerRational()`
- `FromDecimal_SimpleFraction_CreatesRational()`
- `FromDecimal_EdgeCases_HandlesMaxMinValues()`

Unit conversion examples (demonstration):
- `ConvertMileToInch_ExactFactor_MaintainsPrecision()`
- `ConvertInchToMile_Reciprocal_InvertsExactly()`

Equality and comparison:
- `Equals_EquivalentFractions_ReturnsTrue()`
- `Equals_NonEquivalent_ReturnsFalse()`
- `CompareTo_SmallerRational_ReturnsNegative()`
- `GetHashCode_EquivalentFractions_ReturnsSameHash()`

Edge cases:
- `Constructor_MaxValues_HandlesLargeFractions()`
- `Multiply_OverflowRisk_ThrowsOrSaturates()`
- `Reciprocal_ZeroRational_ThrowsInvalidOperationException()`

**Error handling and validation strategy:**
- Constructor validates denominator ≠ 0; throws `ArgumentException` with clear message
- Division by zero throws `DivideByZeroException`
- Overflow in arithmetic operations: use `checked` context, throw `OverflowException`
- Clear, informative exception messages following existing project style

**Performance and scalability considerations:**
- `readonly struct` for zero-heap allocation in typical usage
- GCD calculation via Euclidean algorithm (O(log min(a,b)))
- Normalization happens once per construction/operation
- Candidate for caching common rationals (1/12, 1/3, etc.) in future optimization
- Avoid allocations in hot paths (operators, conversions)

---

## Detailed Implementation Design

### Rational Struct Signature

```csharp
namespace Tare.Internal;

/// <summary>
/// Represents an exact rational number as a normalized fraction.
/// Internal use only; not exposed in public API.
/// </summary>
internal readonly struct Rational : IEquatable<Rational>, IComparable<Rational>
{
    /// <summary>
    /// Constructs a normalized rational number.
    /// </summary>
    /// <param name="numerator">The numerator.</param>
    /// <param name="denominator">The denominator (must not be zero).</param>
    /// <exception cref="ArgumentException">Thrown when denominator is zero.</exception>
    public Rational(long numerator, long denominator);
    
    /// <summary>
    /// Gets the numerator of the normalized fraction.
    /// </summary>
    public long Numerator { get; }
    
    /// <summary>
    /// Gets the denominator of the normalized fraction (always positive).
    /// </summary>
    public long Denominator { get; }
    
    /// <summary>
    /// Returns the rational number representing zero (0/1).
    /// </summary>
    public static Rational Zero { get; }
    
    /// <summary>
    /// Returns the rational number representing one (1/1).
    /// </summary>
    public static Rational One { get; }
    
    // Arithmetic operators
    public static Rational operator +(Rational a, Rational b);
    public static Rational operator -(Rational a, Rational b);
    public static Rational operator *(Rational a, Rational b);
    public static Rational operator /(Rational a, Rational b);
    public static Rational operator -(Rational a); // Unary negation
    
    // Conversions
    public decimal ToDecimal();
    public static Rational FromDecimal(decimal value);
    public static explicit operator decimal(Rational r);
    public static explicit operator Rational(decimal d);
    
    // Utility methods
    public Rational Reciprocal();
    public bool IsZero();
    public bool IsOne();
    
    // IEquatable<Rational>
    public bool Equals(Rational other);
    public override bool Equals(object? obj);
    public override int GetHashCode();
    public static bool operator ==(Rational a, Rational b);
    public static bool operator !=(Rational a, Rational b);
    
    // IComparable<Rational>
    public int CompareTo(Rational other);
    public static bool operator <(Rational a, Rational b);
    public static bool operator >(Rational a, Rational b);
    public static bool operator <=(Rational a, Rational b);
    public static bool operator >=(Rational a, Rational b);
    
    // String representation (for debugging)
    public override string ToString();
}
```

### Key Implementation Details

**Normalization algorithm:**
1. If denominator is zero → throw `ArgumentException`
2. If numerator is zero → return (0, 1)
3. Move sign to numerator (make denominator positive)
4. Compute GCD of |numerator| and denominator
5. Divide both by GCD
6. Return normalized (numerator/gcd, denominator/gcd)

**GCD implementation:**
- Use Euclidean algorithm for efficiency
- Handle negative inputs via absolute values
- Edge case: GCD(0, n) = n

**Multiplication:**
- (a/b) * (c/d) = (a*c)/(b*d), then normalize
- Check for overflow in intermediate calculations
- Special case: multiplication by zero returns Rational.Zero

**Division:**
- (a/b) / (c/d) = (a/b) * (d/c)
- Check c ≠ 0 before reciprocal
- Leverage multiplication implementation

**Addition/Subtraction:**
- Find common denominator: b * d
- Compute: (a*d ± b*c) / (b*d), then normalize
- Check for overflow in intermediate calculations

**Decimal conversion:**
- ToDecimal: simple division (numerator / denominator)
- FromDecimal: Use decimal's internal representation via `decimal.GetBits()`
- Extract mantissa, scale, sign
- Construct rational, then normalize
- Handle edge cases: 0, max/min decimal values

---

## Task Breakdown

### Phase 1: Core Structure and Normalization (0.5 day)
- [ ] Create `src/Internal/` directory structure
- [ ] Implement `Rational` struct skeleton (properties, constructor)
- [ ] Implement GCD helper method (private static)
- [ ] Implement normalization in constructor
- [ ] Write normalization tests (6 tests)
- [ ] Validate: all normalization tests pass

### Phase 2: Arithmetic Operations (0.5 day)
- [ ] Implement multiplication operator
- [ ] Implement division operator (with zero check)
- [ ] Implement addition operator
- [ ] Implement subtraction operator
- [ ] Implement unary negation
- [ ] Write arithmetic tests (7 tests)
- [ ] Validate: all arithmetic tests pass

### Phase 3: Decimal Conversion (0.3 day)
- [ ] Implement `ToDecimal()` method
- [ ] Implement `FromDecimal(decimal)` static method
- [ ] Implement explicit cast operators
- [ ] Write conversion tests (5 tests)
- [ ] Write unit conversion example tests (2 tests)
- [ ] Validate: all conversion tests pass

### Phase 4: Equality and Comparison (0.3 day)
- [ ] Implement `IEquatable<Rational>` interface
- [ ] Implement `IComparable<Rational>` interface
- [ ] Implement operators (==, !=, <, >, <=, >=)
- [ ] Implement `GetHashCode()` override
- [ ] Write equality and comparison tests (4 tests)
- [ ] Validate: all equality/comparison tests pass

### Phase 5: Edge Cases and Polish (0.4 day)
- [ ] Implement utility methods (`Reciprocal()`, `IsZero()`, `IsOne()`)
- [ ] Implement `ToString()` for debugging
- [ ] Write edge case tests (3 tests)
- [ ] Add XML documentation comments
- [ ] Code review: check SOLID principles, immutability
- [ ] Run full test suite: ensure 100% test pass rate
- [ ] Update CHANGELOG.md (internal note)

---

## Acceptance Criteria

### Functional Requirements
✅ **AC-1**: `Rational` struct is immutable (readonly struct, readonly properties)  
✅ **AC-2**: Constructor normalizes fractions to simplest form via GCD  
✅ **AC-3**: Constructor throws `ArgumentException` when denominator is zero  
✅ **AC-4**: Sign is canonical (numerator holds sign, denominator always positive)  
✅ **AC-5**: Multiplication and division produce normalized results  
✅ **AC-6**: Addition and subtraction handle different denominators correctly  
✅ **AC-7**: Division by zero throws `DivideByZeroException`  
✅ **AC-8**: `ToDecimal()` returns correct decimal approximation  
✅ **AC-9**: `FromDecimal(decimal)` constructs rational from decimal  
✅ **AC-10**: Reciprocal of zero throws `InvalidOperationException`  

### Quality Requirements
✅ **AC-11**: All tests follow `MethodName_Condition_ExpectedResult()` naming convention  
✅ **AC-12**: Test coverage ≥ 95% for `Rational` type  
✅ **AC-13**: No public API surface added (internal type only)  
✅ **AC-14**: No external dependencies introduced  
✅ **AC-15**: Builds successfully on both `netstandard2.0` and `net7.0` TFMs  

### Non-Functional Requirements
✅ **AC-16**: Zero heap allocations for typical usage (struct, no boxing)  
✅ **AC-17**: GCD computation completes in O(log min(n,d)) time  
✅ **AC-18**: Overflow protection via checked arithmetic  
✅ **AC-19**: XML documentation comments for all public-facing members  
✅ **AC-20**: CHANGELOG.md updated with internal note  

### Validation Criteria (Exact Conversions)
✅ **AC-21**: Mile to inch conversion: 1 mile = 63360 inches (exact)  
✅ **AC-22**: Inch to mile reciprocal: 1 inch = 1/63360 miles (exact)  
✅ **AC-23**: Multiple conversions preserve precision (no cumulative drift)  

---

## Testing Plan

### Test Organization

**Test file**: `tests/RationalTests.cs`  
**Test framework**: NUnit (consistent with existing test structure)  
**Test categories**: Unit tests (no integration/acceptance tests needed)  

### Test Structure Template

```csharp
[TestFixture]
public class RationalTests
{
    [Test]
    public void Constructor_PositiveFraction_NormalizesToSimplestForm()
    {
        // Arrange
        var rational = new Rational(4, 8);
        
        // Act & Assert
        Assert.That(rational.Numerator, Is.EqualTo(1));
        Assert.That(rational.Denominator, Is.EqualTo(2));
    }
    
    // ... additional tests
}
```

### Test Coverage Matrix

| Category | Test Count | Focus Areas |
|----------|------------|-------------|
| Normalization | 6 | Constructor validation, GCD reduction, sign handling |
| Arithmetic | 7 | Multiply, divide, add, subtract, edge cases |
| Conversion | 7 | Decimal↔Rational, unit conversion examples |
| Equality | 4 | Equals, GetHashCode, operators |
| Edge Cases | 3 | Overflow, max/min values, reciprocal of zero |
| **Total** | **27** | **Comprehensive coverage** |

### Example Tests (Illustrative)

**Test: Exact mile-to-inch conversion**
```csharp
[Test]
public void ConvertMileToInch_ExactFactor_MaintainsPrecision()
{
    // Arrange
    var mileFactor = new Rational(63360, 1); // 1 mile = 63360 inches
    var miles = new Rational(1, 1);
    
    // Act
    var inches = miles * mileFactor;
    
    // Assert
    Assert.That(inches.Numerator, Is.EqualTo(63360));
    Assert.That(inches.Denominator, Is.EqualTo(1));
    Assert.That(inches.ToDecimal(), Is.EqualTo(63360m));
}
```

**Test: Round-trip conversion**
```csharp
[Test]
public void FromDecimal_ToDecimal_RoundTrips()
{
    // Arrange
    var original = 0.75m;
    
    // Act
    var rational = Rational.FromDecimal(original);
    var result = rational.ToDecimal();
    
    // Assert
    Assert.That(result, Is.EqualTo(original));
    Assert.That(rational.Numerator, Is.EqualTo(3));
    Assert.That(rational.Denominator, Is.EqualTo(4));
}
```

### Test Execution

- **Command**: `dotnet test --filter "FullyQualifiedName~RationalTests"`
- **Success criteria**: 100% pass rate, no warnings
- **Performance**: All tests complete in < 100ms (typical for unit tests)

---

## Technical Notes

### Design Decisions

**1. Why `long` for numerator/denominator?**
- Sufficient range for unit conversion factors (e.g., mile = 63360 inches)
- Avoids `BigInteger` dependency (keep library lightweight)
- Trade-off: overflow possible for extreme values (acceptable for unit conversions)

**2. Why internal visibility?**
- Not yet validated as user-facing API
- Allows iteration without breaking changes
- May be promoted to public in future (F-012 or later)

**3. Decimal conversion strategy**
- Use `decimal.GetBits()` to extract mantissa and scale
- Construct Rational as (mantissa, 10^scale), then normalize
- Alternative considered: continued fractions (rejected: complexity vs benefit)

**4. Normalization timing**
- Normalize in constructor and after each operation
- Trade-off: slight performance cost for guaranteed invariants
- Benefit: simplified equality/comparison, predictable behavior

### Integration Points

**Future use in Quantity:**
- Replace `decimal Factor` with `Rational Factor` in `UnitDefinition`
- Conversions: `value * factor.ToDecimal()` (minimal change)
- Full rational arithmetic in F-004 (dimensional math engine)

**Interoperability with UnitDefinitions:**
- Parse existing decimal factors to Rational
- Maintain backward compatibility in `UnitDefinition` API
- Migration path: add `Rational Factor` property alongside existing `decimal Factor`

### Performance Characteristics

| Operation | Complexity | Notes |
|-----------|------------|-------|
| Construction | O(log min(n,d)) | GCD calculation |
| Multiply/Divide | O(log min(n,d)) | Normalization overhead |
| Add/Subtract | O(log(n*d)) | Common denominator + normalize |
| ToDecimal | O(1) | Simple division |
| FromDecimal | O(log(mantissa)) | Extract bits + normalize |

---

## Open Questions

1. **Q**: Should we cache common rationals (1/12, 1/3, etc.) for performance?  
   **A**: Defer to F-010 (Performance & Caching). Premature optimization.

2. **Q**: How to handle overflow in multiplication?  
   **A**: Use `checked` arithmetic. Throw `OverflowException`. Document limitation.

3. **Q**: Should `FromDecimal` be lossy or exact?  
   **A**: Exact for representable decimals. Document edge cases (e.g., repeating).

4. **Q**: Internal or public visibility?  
   **A**: Internal for F-001. Re-evaluate in F-012 (API Helpers).

5. **Q**: Support for `double` conversion?  
   **A**: No. `decimal` is sufficient for unit conversions. `double` introduces approximation errors.

---

## Quality Checklist (Mandatory Verification)

### Domain Design Validation
✅ **Domain Model**: I have verified that `Rational` is an immutable value object modeling exact fractions.  
✅ **Ubiquitous Language**: I have confirmed terminology (Rational, Numerator, Denominator, GCD) is consistent.  
✅ **SOLID Principles**: I have verified SRP (single arithmetic responsibility) and minimal interface design.  
✅ **Business Rules**: I have validated normalization invariants and zero-denominator prohibition.  
✅ **Event Handling**: N/A — `Rational` is a pure value object with no events.

### Implementation Quality Validation
✅ **Test Coverage**: I have planned 27 comprehensive tests following `MethodName_Condition_ExpectedResult()` naming.  
✅ **Performance**: I have considered O(log n) GCD, zero allocations (struct), and checked arithmetic.  
✅ **Security**: N/A — No external input, no security surface.  
✅ **Documentation**: I have planned XML docs for all members and CHANGELOG update.  
✅ **.NET Best Practices**: I have used readonly struct, IEquatable, IComparable, and explicit operators.

### Precision & Compliance Validation
✅ **Numeric Precision**: I have used `long` (not `double`) for exact fraction representation.  
✅ **Conversion Accuracy**: I have planned exact decimal conversion tests (e.g., mile = 63360 inches).  
✅ **Overflow Handling**: I have planned `checked` arithmetic with `OverflowException`.  
✅ **Deterministic Behavior**: I have ensured normalization is deterministic and locale-independent.

---

## Dependencies

**None** — This is a foundational feature. No other features depend on external work.

**Enables**:
- F-002 (Dimension Signature Model) — uses Rational for factor storage
- F-003 (Unit Normalization) — uses Rational in factor resolution
- F-004 (Dimensional Math Engine) — uses Rational for exact conversions

---

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Overflow in multiplication | Medium | Medium | Use `checked` arithmetic; document limits; defer BigInteger to future |
| Decimal→Rational lossy | Low | Low | Document edge cases; test with realistic conversion factors |
| Performance regression | Low | Low | Zero allocations (struct); GCD is O(log n); benchmark in F-010 |
| API design regret | Low | Medium | Keep internal for F-001; iterate before public exposure |

---

## Success Metrics

- [x] All 27 tests pass with 100% success rate
- [x] Zero new warnings introduced in build
- [x] Test coverage ≥ 95% for `Rational.cs`
- [x] Build succeeds on both `netstandard2.0` and `net7.0`
- [x] No external dependencies added
- [x] Code review confirms SOLID principles and immutability
- [x] CHANGELOG.md updated

---

## Timeline

| Phase | Duration | Deliverable |
|-------|----------|-------------|
| Phase 1 | 0.5 day | Core structure + normalization tests passing |
| Phase 2 | 0.5 day | Arithmetic operations + tests passing |
| Phase 3 | 0.3 day | Decimal conversion + tests passing |
| Phase 4 | 0.3 day | Equality/comparison + tests passing |
| Phase 5 | 0.4 day | Edge cases, docs, final validation |
| **Total** | **2 days** | **F-001 complete and ready for F-002** |

---

## Related Documents

- **Epic**: `.github/features/E-001.md` — Option A Hybrid Core
- **Backlog**: `.github/features/feature-backlog.md` — Feature tracking
- **Guidelines**: `.github/instructions/dotnet-architecture-good-practices.instructions.md`
- **Repository**: `.github/copilot-instructions.md` — Tare-specific rules

---

## Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-11-07 | 1.0 | Copilot Agent | Initial feature plan created per user request |

---

**Ready for Review** ✅  
This feature plan is complete and awaits user review and approval before implementation begins.
