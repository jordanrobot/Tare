# F-001: Core Rational Arithmetic

**Status**: ‚ö†Ô∏è READY FOR IMPLEMENTATION (Precision Issues Confirmed)  
**Epic**: E-001 ‚Äî Option A Hybrid Core (Dimension vectors + catalog naming)  
**Priority**: P1 (Must - precision errors exceed acceptable tolerance)  
**Effort**: M (2‚Äì3 days)  
**Dependencies**: F-002 through F-009 complete (dimensional algebra operational)

---

## Status Update (November 2025)

**‚úÖ DIMENSIONAL ALGEBRA COMPLETE**: F-002 through F-009 have been successfully implemented using `decimal` type for factors.

**‚ö†Ô∏è PRECISION ISSUES CONFIRMED**: Post-implementation testing reveals unacceptable precision loss in dimensional operations:
- **Dimensional algebra conversions**: ~0.015% error (e.g., 60 in¬∑lbf ‚Üí Nm ‚Üí in¬∑lbf = 59.9999092)
- **Root cause**: `decimal` division in factor combinations during dimensional multiplication/division
- **Impact**: Visible errors in engineering calculations, exceeds 0.001% tolerance threshold

**üìä TEST RESULTS**:
```
Test Case                          | Expected | Actual              | Error
-----------------------------------|----------|---------------------|------------
60 in¬∑lbf ‚Üí Nm ‚Üí in¬∑lbf           | 60.0     | 59.9999092...      | 9.08e-5 (0.015%)
48 in¬∑lbf ‚Üí Nm ‚Üí in¬∑lbf           | 48.0     | 47.9999273...      | 7.26e-5 (0.015%)
Simple conversions (no dim. ops)  | 1.0      | 1.0 (exact)        | 0.0
20-step conversion chain          | 1.0      | 1.0000...0252      | 2.52e-26 (negligible)
```

**‚úÖ DECISION**: Implement `Rational` type to eliminate precision drift in dimensional algebra operations.

---

## Description

Deliver a `Rational` value object (internal, readonly struct) that represents exact fractional values as numerator/denominator pairs. This eliminates cumulative floating-point drift in the dimensional algebra engine (F-002 through F-007), specifically addressing the ~0.015% precision loss observed in cross-unit dimensional operations.

The `Rational` type will encapsulate:
- Exact fraction representation (numerator/denominator as `long`)
- Automatic normalization (GCD reduction, sign handling)
- Basic arithmetic operations (multiply, divide, add, subtract)
- Bridging to/from `decimal` for integration with existing `Quantity` value type
- Equality, comparison, and hashing for use in collections and caching

### Why Now? (Post-MVP Implementation)

**‚úÖ MVP Delivered First (Correct Decision)**:
- F-002 through F-009 implemented using `decimal` (faster delivery)
- Architecture validated with real code
- Precision issues identified through actual usage
- Data-driven decision (not premature optimization)

**‚ö†Ô∏è Precision Issues Exceed Tolerance**:
- Engineering standard: 0.001% (1 part in 100,000) for precision work
- Observed errors: ~0.015% (15 parts in 100,000) ‚Äî **15√ó over tolerance**
- Errors visible in typical 4-6 decimal place displays
- Impact: Dimensional operations with imperial units (in¬∑lbf, ft¬∑lbf) most affected

**üéØ Surgical Fix Possible**:
- Replace `decimal Factor` with `Rational Factor` in `UnitDefinition`
- Update factor arithmetic in `DimensionalMath` operations
- Minimal surface area changes (~50 LOC modifications + 300 LOC new code)
- All 405 existing tests remain valid (behavioral compatibility)

---

## Precision Testing Results (Validation Data)

**Test Environment**: Post-MVP dimensional algebra implementation (F-002 through F-009 complete)

### Test 1: Simple Conversion Chains ‚úÖ PASS
```
Mile ‚Üí km ‚Üí m ‚Üí ft ‚Üí in ‚Üí mile
Expected: 1.0000000000000000000000000000 mile
Actual:   1.0000000000000000000000000000 mile
Error:    0.0E+000 (0.00%)
```
**Verdict**: Simple catalog conversions are exact with `decimal`.

### Test 2: Dimensional Operations ‚ùå FAIL
```
10 lbf √ó 6 in = 60 in¬∑lbf (construct)
‚Üí Convert to Nm: 6.7790897416570020000 Nm
‚Üí Convert back to in¬∑lbf: 59.9999092061512767181484267820 in¬∑lbf
Expected: 60.0
Actual:   59.9999092...
Error:    9.079385E-005 (0.0151%)
```
**Verdict**: Dimensional conversions exceed tolerance by 15√ó.

### Test 3: Complex Dimensional Chain ‚ùå FAIL
```
((12in √ó 8in) √∑ 4in) √ó 2lbf = 48 in¬∑lbf (expected)
‚Üí Convert to Nm: 5.4232717933256016000 Nm
‚Üí Convert back to in¬∑lbf: 47.9999273649210213745187414260 in¬∑lbf
Expected: 48.0
Actual:   47.9999273...
Error:    7.263508E-005 (0.0151%)
```
**Verdict**: Error consistent across dimensional operations.

### Test 4: Reciprocal Conversions ‚úÖ PASS
```
1 mile = 63360.0000000000000000000000000000 inches (exact)
63360 inches = 1.0000000000000000000000000000 miles (exact)
Error: 0.0E+000
```
**Verdict**: Catalog factor lookups are exact.

### Test 5: Long Conversion Chains ‚úÖ PASS (negligible)
```
20 conversions: m ‚Üí ft ‚Üí in ‚Üí mm ‚Üí cm ‚Üí m ‚Üí km ‚Üí mile ‚Üí ...
Expected: 1.0 m
Actual:   1.0000000000000000000000000252 m
Error:    2.52E-026 (2.52E-024%)
```
**Verdict**: Accumulation negligible for catalog-only conversions.

### Test 6: Fractional Precision (Inherent Decimal Limit)
```
(1/3 m) √ó 3
Expected: 1.0 m
Actual:   0.9999999999999999999999999999 m
Error:    1.0E-028
```
**Verdict**: Inherent `decimal` precision limit (acceptable).

### Test 7: Dimensional Algebra Round-Trip ‚úÖ PASS
```
(100 m √∑ 5 s) √ó 5 s
Expected: 100.0 m
Actual:   100.0000 m
Error:    0.0E+000
```
**Verdict**: Same-dimension round-trips are exact.

### Root Cause Analysis

**Why Dimensional Operations Fail**:
1. `DimensionalMath.Multiply()` computes: `resultFactor = leftFactor * rightFactor`
2. `DimensionalMath.Divide()` computes: `resultFactor = numeratorFactor / denominatorFactor`
3. Cross-unit conversions involve: `value * sourceFactor / targetFactor`
4. Each division introduces rounding: `decimal` has 28-29 significant digits, but division truncates
5. Example: `lbf ‚Üí N` factor is `4.4482216152605`, conversion loses precision in trailing digits

**Why Simple Conversions Pass**:
- Catalog conversions use stored factors (no arithmetic)
- Direct lookup: `1 mile * 1609.344 / 0.0254 = 63360 in` (exact representation)

**Conclusion**: `decimal` is insufficient for **factor arithmetic** in dimensional operations. Need exact fraction arithmetic (`Rational`).

---

## User Story

**As a** developer implementing dimensional unit algebra  
**I want** exact rational arithmetic for unit conversion factors  
**So that** conversions between units maintain precision without floating-point drift

---

## Mandatory Thinking Process (DDD/.NET Guidelines)

### 1) Domain Analysis (REQUIRED)

**Domain concepts involved:**
- **Rational** ‚Äî An immutable value object representing an exact fraction (numerator/denominator)
- **Factor** ‚Äî The conversion multiplier between units, currently stored as `decimal` in `UnitDefinition`
- **Conversion** ‚Äî The operation of transforming a quantity from one unit to another
- **Normalization** ‚Äî Reducing fractions to simplest form (GCD) and canonical sign

**Aggregate boundaries and consistency requirements:**
- `Rational` is a value object, not an aggregate root
- Immutability ensures thread safety and value semantics
- Consistency maintained through automatic normalization in constructor
- No persistence layer; purely computational domain object

**Ubiquitous language terms:**
- Rational, Numerator, Denominator, Factor, Normalize, GCD (Greatest Common Divisor), Reciprocal, Simplify

**Business rules and invariants:**
- Denominator must never be zero (enforced via constructor validation)
- Sign canonically stored in numerator (denominator always positive)
- Automatically normalized to simplest form (GCD reduction)
- Operations produce normalized results
- Zero represented uniquely as 0/1

### 2) Architecture Review (REQUIRED)

**Layer responsibilities:**
- **Domain Layer**: `Rational` value object encapsulates arithmetic logic
- **Application Layer**: N/A (this is a library, not an application)
- **Infrastructure Layer**: N/A (no persistence or external dependencies)

**SOLID principles adherence:**
- **SRP**: `Rational` has single responsibility‚Äîexact fraction arithmetic
- **OCP**: Closed for modification (readonly struct), open for use in higher-level operations
- **LSP**: N/A (no inheritance hierarchy)
- **ISP**: Implements minimal interfaces (`IEquatable<Rational>`, `IComparable<Rational>`)
- **DIP**: No dependencies on concretions; pure value logic

**Domain events:**
- N/A ‚Äî `Rational` is a stateless value object with no side effects

**Security implications:**
- No security concerns; purely computational
- No user input directly processed (values come from controlled unit definitions)
- Overflow protection via checked arithmetic operations

### 3) Implementation Planning (REQUIRED)

**Files to be created/modified:**

| File | Type | Justification |
|------|------|---------------|
| `src/Internal/Rational.cs` | New | Core `Rational` value object implementation |
| `tests/RationalTests.cs` | New | Comprehensive unit tests for `Rational` |
| `docs/CHANGELOG.md` | Modified | Document internal addition (note: not public API) |

**Test cases (following `MethodName_Condition_ExpectedResult()` pattern):**

Normalization:
- `Constructor_PositiveFraction_NormalizesToSimplestForm()`
- `Constructor_NegativeNumerator_MaintainsNegativeSign()`
- `Constructor_NegativeDenominator_MovesSignToNumerator()`
- `Constructor_ZeroNumerator_NormalizesToZeroOverOne()`
- `Constructor_ZeroDenominator_ThrowsArgumentException()`
- `Constructor_CommonFactor_ReducesViaGCD()`

Arithmetic:
- `Multiply_TwoRationals_ReturnsNormalizedProduct()`
- `Multiply_ByZero_ReturnsZero()`
- `Divide_TwoRationals_ReturnsNormalizedQuotient()`
- `Divide_ByZero_ThrowsDivideByZeroException()`
- `Add_SameDenominator_ReturnsNormalizedSum()`
- `Add_DifferentDenominators_FindsCommonDenominator()`
- `Subtract_TwoRationals_ReturnsNormalizedDifference()`

Conversion:
- `ToDecimal_SimpleFraction_ReturnsExactValue()`
- `ToDecimal_RepeatingFraction_TruncatesAsExpected()`
- `FromDecimal_WholeNumber_CreatesIntegerRational()`
- `FromDecimal_SimpleFraction_CreatesRational()`
- `FromDecimal_EdgeCases_HandlesMaxMinValues()`

Unit conversion examples (demonstration):
- `ConvertMileToInch_ExactFactor_MaintainsPrecision()`
- `ConvertInchToMile_Reciprocal_InvertsExactly()`

Equality and comparison:
- `Equals_EquivalentFractions_ReturnsTrue()`
- `Equals_NonEquivalent_ReturnsFalse()`
- `CompareTo_SmallerRational_ReturnsNegative()`
- `GetHashCode_EquivalentFractions_ReturnsSameHash()`

Edge cases:
- `Constructor_MaxValues_HandlesLargeFractions()`
- `Multiply_OverflowRisk_ThrowsOrSaturates()`
- `Reciprocal_ZeroRational_ThrowsInvalidOperationException()`

**Error handling and validation strategy:**
- Constructor validates denominator ‚â† 0; throws `ArgumentException` with clear message
- Division by zero throws `DivideByZeroException`
- Overflow in arithmetic operations: use `checked` context, throw `OverflowException`
- Clear, informative exception messages following existing project style

**Performance and scalability considerations:**
- `readonly struct` for zero-heap allocation in typical usage
- GCD calculation via Euclidean algorithm (O(log min(a,b)))
- Normalization happens once per construction/operation
- Candidate for caching common rationals (1/12, 1/3, etc.) in future optimization
- Avoid allocations in hot paths (operators, conversions)

---

## Detailed Implementation Design

### Rational Struct Signature

```csharp
namespace Tare.Internal;

/// <summary>
/// Represents an exact rational number as a normalized fraction.
/// Internal use only; not exposed in public API.
/// </summary>
internal readonly struct Rational : IEquatable<Rational>, IComparable<Rational>
{
    /// <summary>
    /// Constructs a normalized rational number.
    /// </summary>
    /// <param name="numerator">The numerator.</param>
    /// <param name="denominator">The denominator (must not be zero).</param>
    /// <exception cref="ArgumentException">Thrown when denominator is zero.</exception>
    public Rational(long numerator, long denominator);
    
    /// <summary>
    /// Gets the numerator of the normalized fraction.
    /// </summary>
    public long Numerator { get; }
    
    /// <summary>
    /// Gets the denominator of the normalized fraction (always positive).
    /// </summary>
    public long Denominator { get; }
    
    /// <summary>
    /// Returns the rational number representing zero (0/1).
    /// </summary>
    public static Rational Zero { get; }
    
    /// <summary>
    /// Returns the rational number representing one (1/1).
    /// </summary>
    public static Rational One { get; }
    
    // Arithmetic operators
    public static Rational operator +(Rational a, Rational b);
    public static Rational operator -(Rational a, Rational b);
    public static Rational operator *(Rational a, Rational b);
    public static Rational operator /(Rational a, Rational b);
    public static Rational operator -(Rational a); // Unary negation
    
    // Conversions
    public decimal ToDecimal();
    public static Rational FromDecimal(decimal value);
    public static explicit operator decimal(Rational r);
    public static explicit operator Rational(decimal d);
    
    // Utility methods
    public Rational Reciprocal();
    public bool IsZero();
    public bool IsOne();
    
    // IEquatable<Rational>
    public bool Equals(Rational other);
    public override bool Equals(object? obj);
    public override int GetHashCode();
    public static bool operator ==(Rational a, Rational b);
    public static bool operator !=(Rational a, Rational b);
    
    // IComparable<Rational>
    public int CompareTo(Rational other);
    public static bool operator <(Rational a, Rational b);
    public static bool operator >(Rational a, Rational b);
    public static bool operator <=(Rational a, Rational b);
    public static bool operator >=(Rational a, Rational b);
    
    // String representation (for debugging)
    public override string ToString();
}
```

### Key Implementation Details

**Normalization algorithm:**
1. If denominator is zero ‚Üí throw `ArgumentException`
2. If numerator is zero ‚Üí return (0, 1)
3. Move sign to numerator (make denominator positive)
4. Compute GCD of |numerator| and denominator
5. Divide both by GCD
6. Return normalized (numerator/gcd, denominator/gcd)

**GCD implementation:**
- Use Euclidean algorithm for efficiency
- Handle negative inputs via absolute values
- Edge case: GCD(0, n) = n

**Multiplication:**
- (a/b) * (c/d) = (a*c)/(b*d), then normalize
- Check for overflow in intermediate calculations
- Special case: multiplication by zero returns Rational.Zero

**Division:**
- (a/b) / (c/d) = (a/b) * (d/c)
- Check c ‚â† 0 before reciprocal
- Leverage multiplication implementation

**Addition/Subtraction:**
- Find common denominator: b * d
- Compute: (a*d ¬± b*c) / (b*d), then normalize
- Check for overflow in intermediate calculations

**Decimal conversion:**
- ToDecimal: simple division (numerator / denominator)
- FromDecimal: Use decimal's internal representation via `decimal.GetBits()`
- Extract mantissa, scale, sign
- Construct rational, then normalize
- Handle edge cases: 0, max/min decimal values

---

## Task Breakdown (Updated for Post-MVP Integration)

### Phase 1: Core Rational Structure (0.5 day)
- [ ] Create `src/Internal/Rational.cs` file
- [ ] Implement `Rational` readonly struct with Numerator, Denominator properties
- [ ] Implement GCD helper method (Euclidean algorithm)
- [ ] Implement constructor with normalization (GCD reduction, sign handling)
- [ ] Implement Zero and One static properties
- [ ] Create `tests/RationalTests.cs` file
- [ ] Write normalization tests (6 tests: positive, negative, zero, GCD, overflow)
- [ ] Validate: all normalization tests pass, builds on both TFMs

### Phase 2: Arithmetic Operations (0.5 day)
- [ ] Implement multiplication operator (a/b * c/d)
- [ ] Implement division operator with zero check (a/b / c/d)
- [ ] Implement addition operator with common denominator
- [ ] Implement subtraction operator
- [ ] Implement unary negation operator
- [ ] Implement Reciprocal() method
- [ ] Write arithmetic tests (7 tests: all operators + edge cases)
- [ ] Validate: all arithmetic tests pass with correct normalization

### Phase 3: Decimal Conversion (0.3 day)
- [ ] Implement ToDecimal() method (numerator / denominator)
- [ ] Implement FromDecimal(decimal) static method using GetBits()
- [ ] Implement explicit cast operators (decimal ‚Üî Rational)
- [ ] Write conversion tests (5 tests: round-trip, edge cases)
- [ ] Write precision validation tests (exact mile/inch conversions)
- [ ] Validate: all conversion tests pass, exact values maintained

### Phase 4: Equality and Comparison (0.3 day)
- [ ] Implement IEquatable<Rational> interface
- [ ] Implement IComparable<Rational> interface  
- [ ] Implement equality operators (==, !=)
- [ ] Implement comparison operators (<, >, <=, >=)
- [ ] Implement GetHashCode() override (combine normalized values)
- [ ] Implement ToString() for debugging
- [ ] Write equality/comparison tests (4 tests: equivalence, ordering, hash)
- [ ] Validate: all equality tests pass, hash collisions minimal

### Phase 5: UnitDefinition Integration (0.5 day)
- [ ] Add `public Rational FactorRational { get; }` property to UnitDefinition
- [ ] Update `public decimal Factor { get; }` to compute from FactorRational
- [ ] Add constructor overload: `UnitDefinition(..., Rational factor, ...)`
- [ ] Maintain existing decimal constructor for backward compatibility
- [ ] Update internal initialization to prefer Rational
- [ ] Write integration tests: verify Factor returns correct decimal value
- [ ] Validate: all existing UnitDefinition tests pass unchanged

### Phase 6: DimensionalMath Integration (0.5 day)
- [ ] Update `DimensionalMath.Multiply()` to use Rational factor arithmetic
- [ ] Update `DimensionalMath.Divide()` to use Rational factor arithmetic
- [ ] Keep final result conversion to decimal for Quantity.Value
- [ ] Update `UnitResolver.ResolvedUnit` to include Rational FactorToBase
- [ ] Write precision tests: 60 in¬∑lbf ‚Üí Nm ‚Üí in¬∑lbf should be exact
- [ ] Validate: dimensional operations now exact, all 405 tests pass

### Phase 7: Unit Catalog Migration (0.3 day)
- [ ] Convert length unit factors to Rational (mile, inch, foot, meter, etc.)
- [ ] Convert force unit factors to Rational (lbf, N, etc.)
- [ ] Convert commonly-used factors to exact representations
- [ ] Document any factors that require decimal approximation
- [ ] Write catalog validation tests: verify exact factors
- [ ] Validate: catalog lookups work, conversions exact

### Phase 8: Integration Testing and Validation (0.4 day)
- [ ] Run all 405 existing tests: verify 100% pass rate
- [ ] Run precision validation tests from analysis
- [ ] Verify 60 in¬∑lbf round-trip is exact (not 59.9999092)
- [ ] Verify 48 in¬∑lbf round-trip is exact (not 47.9999273)
- [ ] Run performance benchmarks: measure impact
- [ ] Update CHANGELOG.md with precision fix details
- [ ] Add XML documentation to all public Rational members
- [ ] Code review: verify SOLID principles, immutability, no breaking changes

---

## Acceptance Criteria (Updated for Post-MVP)

### Precision Requirements (PRIMARY GOALS)
‚úÖ **AC-1**: 60 in¬∑lbf ‚Üí Nm ‚Üí in¬∑lbf returns exactly 60.0 (not 59.9999092)  
‚úÖ **AC-2**: 48 in¬∑lbf ‚Üí Nm ‚Üí in¬∑lbf returns exactly 48.0 (not 47.9999273)  
‚úÖ **AC-3**: All dimensional conversions within 0.001% tolerance (currently 0.015%)  
‚úÖ **AC-4**: Mile to inch conversion: 1 mile = 63360 inches (exact, already passing)  
‚úÖ **AC-5**: Multiple conversions preserve precision (no cumulative drift > 0.0001%)  

### Rational Type Requirements
‚úÖ **AC-6**: `Rational` struct is immutable (readonly struct, readonly properties)  
‚úÖ **AC-7**: Constructor normalizes fractions to simplest form via GCD  
‚úÖ **AC-8**: Constructor throws `ArgumentException` when denominator is zero  
‚úÖ **AC-9**: Sign is canonical (numerator holds sign, denominator always positive)  
‚úÖ **AC-10**: Arithmetic operations (*, /, +, -) produce normalized results  
‚úÖ **AC-11**: Division by zero throws `DivideByZeroException`  
‚úÖ **AC-12**: `ToDecimal()` returns correct decimal value  
‚úÖ **AC-13**: `FromDecimal(decimal)` constructs rational from decimal  
‚úÖ **AC-14**: Reciprocal of zero throws `InvalidOperationException`  

### Integration Requirements
‚úÖ **AC-15**: UnitDefinition.Factor property maintains backward compatibility (decimal)  
‚úÖ **AC-16**: UnitDefinition.FactorRational property added for internal use  
‚úÖ **AC-17**: DimensionalMath operations use Rational arithmetic internally  
‚úÖ **AC-18**: All 405 existing tests pass without modification  
‚úÖ **AC-19**: No breaking changes to public API surface  

### Quality Requirements
‚úÖ **AC-20**: All tests follow `MethodName_Condition_ExpectedResult()` naming convention  
‚úÖ **AC-21**: Test coverage ‚â• 95% for `Rational.cs`  
‚úÖ **AC-22**: No external dependencies introduced  
‚úÖ **AC-23**: Builds successfully on both `netstandard2.0` and `net7.0` TFMs  
‚úÖ **AC-24**: Zero heap allocations for typical Rational usage (struct, no boxing)  
‚úÖ **AC-25**: Overflow protection via checked arithmetic  
‚úÖ **AC-26**: XML documentation comments for all internal-visible members  
‚úÖ **AC-27**: CHANGELOG.md updated with precision fix details  
‚úÖ **AC-28**: Performance impact < 5% for dimensional operations  

---

## Testing Plan

### Test Organization

**Test file**: `tests/RationalTests.cs`  
**Test framework**: NUnit (consistent with existing test structure)  
**Test categories**: Unit tests (no integration/acceptance tests needed)  

### Test Structure Template

```csharp
[TestFixture]
public class RationalTests
{
    [Test]
    public void Constructor_PositiveFraction_NormalizesToSimplestForm()
    {
        // Arrange
        var rational = new Rational(4, 8);
        
        // Act & Assert
        Assert.That(rational.Numerator, Is.EqualTo(1));
        Assert.That(rational.Denominator, Is.EqualTo(2));
    }
    
    // ... additional tests
}
```

### Test Coverage Matrix

| Category | Test Count | Focus Areas |
|----------|------------|-------------|
| Normalization | 6 | Constructor validation, GCD reduction, sign handling |
| Arithmetic | 7 | Multiply, divide, add, subtract, edge cases |
| Conversion | 7 | Decimal‚ÜîRational, unit conversion examples |
| Equality | 4 | Equals, GetHashCode, operators |
| Edge Cases | 3 | Overflow, max/min values, reciprocal of zero |
| **Total** | **27** | **Comprehensive coverage** |

### Example Tests (Illustrative)

**Test: Exact mile-to-inch conversion**
```csharp
[Test]
public void ConvertMileToInch_ExactFactor_MaintainsPrecision()
{
    // Arrange
    var mileFactor = new Rational(63360, 1); // 1 mile = 63360 inches
    var miles = new Rational(1, 1);
    
    // Act
    var inches = miles * mileFactor;
    
    // Assert
    Assert.That(inches.Numerator, Is.EqualTo(63360));
    Assert.That(inches.Denominator, Is.EqualTo(1));
    Assert.That(inches.ToDecimal(), Is.EqualTo(63360m));
}
```

**Test: Round-trip conversion**
```csharp
[Test]
public void FromDecimal_ToDecimal_RoundTrips()
{
    // Arrange
    var original = 0.75m;
    
    // Act
    var rational = Rational.FromDecimal(original);
    var result = rational.ToDecimal();
    
    // Assert
    Assert.That(result, Is.EqualTo(original));
    Assert.That(rational.Numerator, Is.EqualTo(3));
    Assert.That(rational.Denominator, Is.EqualTo(4));
}
```

### Test Execution

- **Command**: `dotnet test --filter "FullyQualifiedName~RationalTests"`
- **Success criteria**: 100% pass rate, no warnings
- **Performance**: All tests complete in < 100ms (typical for unit tests)

---

## Technical Notes

### Design Decisions

**1. Why `long` for numerator/denominator?**
- Sufficient range for unit conversion factors (e.g., mile = 63360 inches)
- Avoids `BigInteger` dependency (keep library lightweight)
- Trade-off: overflow possible for extreme values (acceptable for unit conversions)

**2. Why internal visibility?**
- Not yet validated as user-facing API
- Allows iteration without breaking changes
- May be promoted to public in future (F-012 or later)

**3. Decimal conversion strategy**
- Use `decimal.GetBits()` to extract mantissa and scale
- Construct Rational as (mantissa, 10^scale), then normalize
- Alternative considered: continued fractions (rejected: complexity vs benefit)

**4. Normalization timing**
- Normalize in constructor and after each operation
- Trade-off: slight performance cost for guaranteed invariants
- Benefit: simplified equality/comparison, predictable behavior

### Integration Points (Updated Post-MVP)

**‚úÖ Current System (F-002 through F-009 Implemented)**:
- `UnitDefinition.Factor` is `decimal` (line 7, UnitDefinition.cs)
- `Quantity.Factor` is `decimal` (line 173, Quantity.cs)
- `DimensionalMath` operations use `decimal` arithmetic
- `UnitResolver.ResolvedUnit.FactorToBase` is `decimal`
- All unit catalog entries store `decimal` factors

**üéØ Migration Strategy (Minimize Changes)**:

**Phase 1: Add Rational Type (New Code)**
- Create `src/Internal/Rational.cs` (300 LOC)
- Internal visibility (not public API)
- Zero impact on existing code

**Phase 2: Update UnitDefinition (Breaking Internal Change)**
- Add `public Rational FactorRational { get; }` property to `UnitDefinition`
- Keep `public decimal Factor { get; }` for backward compatibility (computed from Rational)
- Constructor accepts both `decimal factor` and `Rational factor` overloads
- Internal catalog initialization uses Rational constructors

**Phase 3: Update Dimensional Operations (Precision Fix)**
- `DimensionalMath.Multiply()`: Use Rational arithmetic for factor combinations
- `DimensionalMath.Divide()`: Use Rational arithmetic for factor combinations
- `UnitResolver.Resolve()`: Return `Rational FactorToBase` alongside `decimal` for compatibility
- Conversion to `decimal` only at final display/output stage

**Phase 4: Update Unit Catalog (Data Migration)**
- Convert all `UnitDefinitions.Definitions` entries to use Rational factors
- Example: `1609.344m` (decimal) ‚Üí `new Rational(1609344, 1000)` (exact)
- Special cases: 
  - Mile to inch: `63360` ‚Üí `new Rational(63360, 1)`
  - Inch to meter: `0.0254` ‚Üí `new Rational(254, 10000)`
  - Pound-force to newton: `4.4482216152605` ‚Üí construct from decimal

**Backward Compatibility Guarantee**:
- Public API unchanged (Quantity, UnitDefinition public surface)
- All 405 existing tests pass without modification
- User code continues to work (no recompilation needed)
- `Factor` property returns `decimal` (computed from Rational via `ToDecimal()`)

**Integration Test Cases**:
- Verify 60 in¬∑lbf ‚Üí Nm ‚Üí in¬∑lbf returns exactly 60.0
- Verify 48 in¬∑lbf ‚Üí Nm ‚Üí in¬∑lbf returns exactly 48.0
- Verify simple conversions remain exact
- Verify all existing tests pass

### Performance Characteristics

| Operation | Complexity | Notes |
|-----------|------------|-------|
| Construction | O(log min(n,d)) | GCD calculation |
| Multiply/Divide | O(log min(n,d)) | Normalization overhead |
| Add/Subtract | O(log(n*d)) | Common denominator + normalize |
| ToDecimal | O(1) | Simple division |
| FromDecimal | O(log(mantissa)) | Extract bits + normalize |

---

## Open Questions

1. **Q**: Should we cache common rationals (1/12, 1/3, etc.) for performance?  
   **A**: Defer to F-010 (Performance & Caching). Premature optimization.

2. **Q**: How to handle overflow in multiplication?  
   **A**: Use `checked` arithmetic. Throw `OverflowException`. Document limitation.

3. **Q**: Should `FromDecimal` be lossy or exact?  
   **A**: Exact for representable decimals. Document edge cases (e.g., repeating).

4. **Q**: Internal or public visibility?  
   **A**: Internal for F-001. Re-evaluate in F-012 (API Helpers).

5. **Q**: Support for `double` conversion?  
   **A**: No. `decimal` is sufficient for unit conversions. `double` introduces approximation errors.

---

## Quality Checklist (Mandatory Verification)

### Domain Design Validation
‚úÖ **Domain Model**: I have verified that `Rational` is an immutable value object modeling exact fractions.  
‚úÖ **Ubiquitous Language**: I have confirmed terminology (Rational, Numerator, Denominator, GCD) is consistent.  
‚úÖ **SOLID Principles**: I have verified SRP (single arithmetic responsibility) and minimal interface design.  
‚úÖ **Business Rules**: I have validated normalization invariants and zero-denominator prohibition.  
‚úÖ **Event Handling**: N/A ‚Äî `Rational` is a pure value object with no events.

### Implementation Quality Validation
‚úÖ **Test Coverage**: I have planned 27 comprehensive tests following `MethodName_Condition_ExpectedResult()` naming.  
‚úÖ **Performance**: I have considered O(log n) GCD, zero allocations (struct), and checked arithmetic.  
‚úÖ **Security**: N/A ‚Äî No external input, no security surface.  
‚úÖ **Documentation**: I have planned XML docs for all members and CHANGELOG update.  
‚úÖ **.NET Best Practices**: I have used readonly struct, IEquatable, IComparable, and explicit operators.

### Precision & Compliance Validation
‚úÖ **Numeric Precision**: I have used `long` (not `double`) for exact fraction representation.  
‚úÖ **Conversion Accuracy**: I have planned exact decimal conversion tests (e.g., mile = 63360 inches).  
‚úÖ **Overflow Handling**: I have planned `checked` arithmetic with `OverflowException`.  
‚úÖ **Deterministic Behavior**: I have ensured normalization is deterministic and locale-independent.

---

## Dependencies (Updated Post-MVP)

**‚úÖ Prerequisites Complete**:
- F-002 (Dimension Signature Model) ‚Äî ‚úÖ Complete
- F-003 (Unit Normalization) ‚Äî ‚úÖ Complete
- F-004 (Dimensional Math Engine) ‚Äî ‚úÖ Complete
- F-005 (Known Signature Map) ‚Äî ‚úÖ Complete
- F-006 (Composite Formatter) ‚Äî ‚úÖ Complete
- F-007 (Operators Integration) ‚Äî ‚úÖ Complete
- F-008 (Format Extensions) ‚Äî ‚úÖ Complete
- F-009 (Composite Construction) ‚Äî ‚úÖ Complete

**‚ö†Ô∏è Precision Issues Identified**:
- Dimensional algebra operations show ~0.015% error with `decimal` factors
- Errors exceed engineering tolerance (0.001%)
- Imperial unit conversions most affected (in¬∑lbf, ft¬∑lbf)

**üéØ This Feature Fixes**:
- Precision drift in `DimensionalMath` operations (F-004)
- Factor arithmetic in `UnitResolver` (F-003)
- Catalog factor representation in `UnitDefinitions`

**Blocks**:
- None. This is an internal precision improvement.

**Enabled By**:
- F-002 through F-009 provide real-world test cases and integration points

---

## Risk Assessment (Updated Post-MVP)

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Breaking existing tests | Low | High | Maintain decimal Factor property; all public APIs unchanged |
| Performance regression | Low | Medium | Rational only used in factor arithmetic; final conversion to decimal cached |
| Overflow in multiplication | Medium | Low | Use `checked` arithmetic; document limits; unit factors rarely exceed long range |
| Decimal‚ÜíRational lossy | Low | Low | Use exact representation where possible; test with catalog factors |
| Integration complexity | Low | Medium | Phased rollout: Rational type ‚Üí UnitDefinition ‚Üí DimensionalMath ‚Üí Catalog |
| User code breaks | Very Low | High | Keep public API identical; decimal Factor computed from Rational |

**Key Risk Mitigation**:
- Run all 405 existing tests after each phase
- Maintain backward compatibility throughout
- Internal-only changes (no public API impact)
- Can roll back by reverting Rational usage while keeping type

---

## Success Metrics (Updated for Post-MVP)

### Precision Goals (Primary)
- [ ] 60 in¬∑lbf ‚Üí Nm ‚Üí in¬∑lbf returns exactly 60.0 (currently 59.9999092)
- [ ] 48 in¬∑lbf ‚Üí Nm ‚Üí in¬∑lbf returns exactly 48.0 (currently 47.9999273)
- [ ] All dimensional conversions within 0.001% tolerance (currently 0.015%)
- [ ] Complex chains maintain < 0.0001% cumulative error

### Quality Goals
- [ ] All 27 Rational unit tests pass with 100% success rate
- [ ] All 405 existing integration tests pass without modification
- [ ] Test coverage ‚â• 95% for `Rational.cs`
- [ ] Zero new build warnings introduced
- [ ] Build succeeds on both `netstandard2.0` and `net7.0`
- [ ] No external dependencies added

### Integration Goals
- [ ] UnitDefinition maintains backward-compatible decimal Factor property
- [ ] DimensionalMath operations use Rational arithmetic internally
- [ ] Unit catalog migrated to Rational representation
- [ ] Performance impact < 5% for dimensional operations (measured)
- [x] CHANGELOG.md updated

---

## Timeline (Updated for Post-MVP Integration)

| Phase | Duration | Deliverable |
|-------|----------|-------------|
| Phase 1: Core Rational Type | 0.5 day | Rational struct + normalization tests passing |
| Phase 2: Arithmetic Operations | 0.5 day | Multiply, divide, add, subtract + tests passing |
| Phase 3: Decimal Conversion | 0.3 day | ToDecimal, FromDecimal + conversion tests passing |
| Phase 4: Equality/Comparison | 0.3 day | IEquatable, IComparable + comparison tests passing |
| Phase 5: UnitDefinition Integration | 0.5 day | FactorRational property + backward-compatible Factor |
| Phase 6: DimensionalMath Integration | 0.5 day | Rational arithmetic in Multiply/Divide operations |
| Phase 7: Unit Catalog Migration | 0.3 day | All catalog entries use Rational factors |
| Phase 8: Integration Testing | 0.4 day | All 405 tests pass + precision validation |
| **Total** | **3.4 days** | **F-001 complete with zero precision drift** |

**Dependencies**: F-002 through F-009 must remain stable during integration

---

## Related Documents

- **Epic**: `.github/features/E-001.md` ‚Äî Option A Hybrid Core
- **Precision Spike**: `.github/features/S-005.md` ‚Äî Decimal Precision Evaluation
- **Implemented Features**: F-002 through F-009 (dimensional algebra complete)
- **Backlog**: `.github/features/feature-backlog.md` ‚Äî Feature tracking
- **Guidelines**: `.github/instructions/dotnet-architecture-good-practices.instructions.md`
- **Repository**: `.github/copilot-instructions.md` ‚Äî Tare-specific rules

---

## Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-11-07 | 1.0 | Copilot Agent | Initial feature plan created per user request |
| 2025-11-10 | 2.0 | Copilot Agent | **MAJOR UPDATE**: Revised post-MVP implementation plan based on precision testing of F-002‚ÄìF-009. Status changed from "Deferred" to "Ready for Implementation" due to confirmed 0.015% precision errors in dimensional operations. Updated integration points, timeline (2 days ‚Üí 3.4 days), acceptance criteria, and implementation phases to reflect actual system architecture. |

---

## Executive Summary (Post-MVP Update)

**üéØ Purpose**: Eliminate ~0.015% precision drift in dimensional algebra operations by replacing `decimal` factors with exact `Rational` arithmetic.

**‚úÖ What Was Right**: 
- MVP-first approach validated architecture
- Data-driven decision (not premature optimization)
- F-002 through F-009 successfully implemented

**‚ö†Ô∏è What Was Discovered**:
- Dimensional conversions have 15√ó higher error than acceptable (0.015% vs 0.001% tolerance)
- Errors visible in engineering displays (e.g., 60 ‚Üí 59.9999092)
- Imperial unit conversions most affected

**üéØ Solution**:
- Add `Rational` type for exact fraction arithmetic
- Surgical integration: UnitDefinition + DimensionalMath
- Maintain backward compatibility (all public APIs unchanged)
- Expected effort: 3.4 days

**üìä Expected Outcome**:
- Zero precision drift in dimensional operations
- All 405 existing tests pass
- Performance impact < 5%
- Engineering-grade precision achieved

---

**Ready for Implementation** ‚úÖ  
This updated feature plan addresses confirmed precision issues discovered post-MVP and provides a clear integration path.
