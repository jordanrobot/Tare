# S-004: Unified plan — simple API, rich unit algebra, no external deps

This spike consolidates lessons from S-001 (catalog/signatures), S-002 (greenfield options), and S-003 (EngineeringUnits eval), guided by these principles:

- Keep the user-facing API simple: one primary `Quantity` type (value + unit), intuitive operators, and predictable formatting.
- Preserve Tare’s strengths: robust string parsing (`Quantity.Parse("36in")`) and flexible formatting (`q.Format("ft")`).
- Avoid external runtime dependencies by default; do not force transitive dependencies on downstream users.
- Provide general unit algebra: allow multiply/divide to create derived units, including complex signatures like `(lbf*in^3)/s^2`.
- If the result matches a known unit family (e.g., Energy, Length), select a friendly canonical name; if not, surface a scalar + composite unit signature.
- Internal changes are acceptable; public API may evolve if it materially improves capability, but should remain concise and approachable.

## Goals

- Dimensionally correct runtime algebra for `*` and `/`, with cancellation and simplification.
- Friendly naming for known signatures, and stable composite strings for unknowns.
- Preserve decimal for values; ensure deterministic conversions with exact/rational unit factors.
- Retain and extend string-based parsing/formatting, including composite target units and signatures.
- No mandatory third-party dependencies.

## Non-goals

- Compile-time dimensional types across all quantities (nice-to-have, but not required now).
- Adopting a third-party units library as a hard dependency.
- Broad API refactors unrelated to unit algebra and formatting, unless there is justification or it improves the usability or functionality of the API.

---

## Refined development options

### Option A — Hybrid core: Dimension vectors for math + catalog for naming (Recommended)

- What: Implement an internal dimension signature (exponent vector over base dimensions: L, M, T, I, Θ, …). `*` and `/` add/subtract exponents, enabling universal composition and cancellation.
- Naming: Maintain a small signature→preferred-name map (Energy→`Nm`, Torque→`Nm`, Pressure→`Pa`, …). Use `UnitDefinitions` for factors/aliases. If a signature has no known family, format a canonical composite string (e.g., `lbf*in^3/s^2`).
- Parsing: Keep `Quantity.Parse` as the front door. Extend the parser to accept composite unit strings where appropriate (for formatting targets and possibly construction via `Quantity(value, "lbf*in")`).
- Precision: Values remain `decimal`. Unit factors use exact rationals (stored as integer numerator/denominator) to avoid drift.

Pros
- General, future-proof math; friendly names when known; single `Quantity` surface preserved.
- Reuses existing `UnitDefinitions` and parsing investments.
- No external dependency.

Cons / Risks
- Requires curating base signatures and a small known-signature map.
- Naming policy decisions (SI-first vs operand-derived) must be clear and consistent.

Spike slice
- Implement a minimal `DimensionSignature` (L, M, T are enough to cover examples).
- Add operator branches for `Quantity * Quantity` and `Quantity / Quantity` using signatures and rational factors.
- Add a tiny signature→name map for Energy/Torque/Area/Pressure; fallback to composite string.

---

### Option B — Symbolic unit expressions under the hood (Composite-first)

- What: Represent the unit as an immutable symbolic expression (prime unit symbols with integer exponents and a rational coefficient). Operators combine and normalize expressions; formatting pretty-prints a stable, ordered signature.
- Naming: A resolver maps common expressions (or equivalent signatures) to preferred unit names using `UnitDefinitions` + alias tables.

Pros
- Extremely expressive; handles complex signatures naturally; cancellation and simplification are inherent.
- Exact rational math for factors; stable formatting.

Cons / Risks
- More complex to implement than pure vectors; may need careful caching to keep allocations low.

Spike slice
- Introduce `UnitExpr` internally (no public exposure). Normalize on build; provide `ToSignature()` to bridge to A’s naming map.

---

### Option C — Rule bootstrap + general fallback (Pragmatic ramp)

- What: Start with a tiny rule table for high-value results (Torque, Energy, Area/Length, Volume/Length→Area) to demonstrate capability quickly. For everything else, fall back to signatures or symbolic expressions.

Pros
- Fast path to demos and early wins; reduces initial complexity.

Cons / Risks
- Rules alone don’t scale; must be complemented by A or B to cover long-tail cases.

Spike slice
- Implement 4–6 rules while A/B core is being built. Remove/simplify rules later as the general engine matures.

---

## Public API shape (minimal, user-friendly)

- Keep `readonly struct Quantity` with decimal value and unit string.
- Enable `Quantity * Quantity` and `Quantity / Quantity`.
- Parsing/formatting
  - Continue to accept simple units in `Parse("36in")` and format as today.
  - Allow composite format targets via `q.Format("lbf*in")` and known aliases (e.g., `Nm`).
  - Consider optional construction with composite unit strings when unambiguous.
- Inspection helpers (additive, not required for basic usage)
  - `bool IsKnown()` — does this quantity map to a known unit family?
  - `string Signature()` — returns a canonical composite unit signature (e.g., `lbf*in^3/s^2`).
  - `Quantity Normalize(string preferredUnit = null)` — convert to preferred known unit or normalized composite.

Notes
- Addition/subtraction remain restricted to like-dimension quantities.
- Backward compatibility: existing scalar operators remain unchanged.

## Parsing and formatting policy

- Canonicalization
  - Use a stable ordering (e.g., numerator alphabetical by base symbol, denominator likewise).
  - `*` for multiplication, `/` for division, `^n` for integer exponents.
  - Prefer middle-dot `·` only in display; accept `*` in input.
- Aliases
  - Normalize aliases on parse ("inch"→"in", "pound force"→"lbf").
  - `UnitDefinitions` remains the canonical alias table.
- Known-name selection
  - When signature matches a known family, prefer SI-first name by default (configurable). Example: `N*m` displayed as `Nm`.

## Error modes

- Incompatible add/sub: same as today (clear exception).
- Unknown unit tokens: parse error with a suggested correction if an alias is close.
- Divide by zero: same guards as today.
- Mixed-system surprises: always normalize via rational factors; formatting determines presentation.

## Precision and factors

- Values: `decimal`.
- Unit factors: exact rational representation (e.g., `63360 in / mi` stored as `num=63360, den=1`).
- Conversions: multiply value by rational factor, rounding only when formatting to target precision.

## Performance

- Keep `Quantity` and internal unit/signature types as readonly structs.
- Cache normalized signatures and common factors.
- Avoid allocations in hot operators; prefer precomputed maps.

## Test matrix (expanded)

- Multiply: `6 in * 10 lbf = 60 lbf*in`; equals `~6.779 Nm`.
- Divide with reduction: `48 in*in / 4 in = 12 in`.
- Cancellation to scalar: `48 in / 1 in = 48`.
- Cross-system conversion: `100 N*m` ↔ `~885.0 lbf*in`.
- Volume/length → area: `144 in^3 / 12 in = 12 in^2`.
- Mixed aliases: `2 inch * 3 pound force` → `6 lbf*in`.
- Complex signature: `(lbf*in^3)/s^2` remains composite when no known family exists; formatting stable.
- Temperature differences: `(10 °C - 5 °C)` allowed; ensure policy for absolute vs delta temps documented (no TemperatureDelta type).  

## Migration and compatibility

- Additive by default: enabling `*` and `/` expands capability without breaking existing usage.
- New helpers (`IsKnown`, `Signature`, `Normalize`) are optional for advanced scenarios.
- Any change to `UnitTypeEnum` (e.g., adding `Derived`) should be postponed unless strictly necessary; prefer keeping it internal to the engine.

## Risks and mitigations

- Naming disputes: document SI-first policy and allow opt-in preferences.
- Parser complexity: gate composite parsing for construction behind a feature flag initially; always allow composite in Format targets.
- Performance regressions: add microbenchmarks for hot operators and parsing.

## Recommendation

Proceed with Option A (Hybrid core) with a small bootstrap from Option C:

1) Build the internal dimension/signature engine with rational factors and decimal values.
2) Wire `*` and `/` through the engine; keep add/sub rules unchanged.
3) Implement known-signature naming for 5–8 high-value families; canonical composite fallback for others.
4) Extend formatting to accept composite targets; keep `Parse` strict for simple units initially.
5) Add inspection helpers and a minimal configuration surface (naming preferences).

## Timebox and deliverables

- Timebox: 3–5 days for a working POC across the test matrix.
- Deliverables:
  - Engine prototype (signature math + naming) and operator wiring.
  - Extended formatting; optional composite construction guarded behind a flag.
  - Unit tests for the matrix above; microbenchmarks for operators and conversions.
  - A brief RFC capturing any API pressure points and follow-up work.
