# S-005: Decimal Precision Evaluation for Dimensional Algebra (spike)

This spike evaluates whether .NET's built-in `decimal` type provides sufficient precision for dimensional algebra operations in the Tare library, or whether a custom `Rational` type (F-001) is required.

## Goals

- Implement dimensional algebra MVP using existing `decimal` factors (as currently stored in `UnitDefinition.Factor`)
- Measure precision loss in representative real-world scenarios involving chained dimensional operations
- Establish objective criteria for acceptable vs. unacceptable precision drift
- Provide data-driven recommendation: continue with `decimal` or implement `Rational` (F-001)
- Document findings to inform future optimization decisions

## Non-goals

- Do not implement `Rational` type during this spike
- Do not change existing `UnitDefinition` structure
- Do not optimize performance (performance evaluation is F-010's scope)
- Do not introduce external dependencies

## Background

### Current State

Tare currently uses `decimal` for unit conversion factors:
- `decimal Factor` in `UnitDefinition` (e.g., `1 mile = 1609.344m`)
- `decimal` provides 28-29 significant digits of precision
- Hardware-supported 128-bit operations (fast)
- Single conversions work well (e.g., `5 miles → 8046.72 meters`)

### The Question

When implementing dimensional algebra (multiplying/dividing quantities), factors must be combined:
- Example: `(6 in) × (10 lbf) = 60 in·lbf` requires `factorIn × factorLbf`
- Chained operations: `(A × B) ÷ (C × D)` involves multiple factor combinations
- Does `decimal` accumulate enough rounding error to cause problems?

### Precision Concerns

**Theoretical risk**:
- `decimal` division: `1m / 3m = 0.333333...` (truncated at 28-29 digits)
- Reciprocals: `1 / 63360 = 0.0000157828...` (may lose precision)
- Chained operations compound errors

**Real-world question**:
- Are errors large enough to matter in engineering/scientific contexts?
- Do common unit combinations (inch-pound, meter-newton) stay within acceptable tolerance?

## Success Criteria

### Quantitative Metrics

1. **Single conversion accuracy**: All standard unit conversions maintain ≤ 1 ULP (Unit in Last Place) error
2. **Two-step chain accuracy**: `A → B → A` round-trips within 0.0001% relative error
3. **Complex chain accuracy**: 5+ operations maintain ≤ 0.001% relative error
4. **Known problem cases**: Mile/inch (63360), foot-pound/newton-meter conversions stay within tolerance

### Qualitative Criteria

- Errors are not visible in typical display precision (4-6 decimal places)
- Results match expected values in engineering reference tables
- No accumulation of systemic bias over multiple operations

### Decision Threshold

**Continue with `decimal`** if:
- All quantitative metrics met
- No visible errors in representative use cases
- Performance is acceptable (measured separately in F-010)

**Implement `Rational` (F-001)** if:
- Any metric fails by >10x margin
- Visible errors in common scenarios
- Accumulating drift detected in chains

## Test Scenarios

### Category 1: Single Conversions (Baseline)

Test that existing conversions work correctly:
- Mile ↔ inch (factor 63360)
- Meter ↔ foot (factor 0.3048)
- Pound-force ↔ newton (factor 4.448...)
- Newton-meter ↔ foot-pound (factor 1.355...)

**Expected**: All pass with `decimal` (already validated in current codebase)

### Category 2: Dimensional Products

Multiply two quantities with units:
- `6 in × 10 lbf = 60 in·lbf`
- Convert result: `60 in·lbf = 6.779 Nm` (known reference value)
- `0.5 m × 20 N = 10 Nm`
- `12 in × 3 in = 36 in²` → `0.0232 m²`

**Test**:
```csharp
[Test]
public void Multiply_InchByPoundForce_ProducesTorqueWithinTolerance()
{
    // Arrange
    var length = new Quantity(6, "in");
    var force = new Quantity(10, "lbf");
    
    // Act
    var torque = length * force; // Should be 60 in·lbf
    var torqueNm = torque.As("Nm"); // Convert to SI
    
    // Assert
    Assert.That(torqueNm.Value, Is.EqualTo(6.779).Within(0.001)); // 0.015% tolerance
}
```

### Category 3: Dimensional Quotients

Divide quantities:
- `36 in² ÷ 3 in = 12 in`
- `100 Nm ÷ 2 m = 50 N`
- Unit cancellation: `5 in ÷ 1 in = 5` (scalar)

### Category 4: Chained Operations

Multi-step calculations:
- `((12 in × 8 in) ÷ 4 in) × 2 lbf` → verify final value and unit
- Convert through multiple units: `1 mile → km → m → ft → in → mile` (round-trip)
- Combined operations: `(A × B) ÷ (C + D)` where compatible

**Critical test**:
```csharp
[Test]
public void ChainedConversions_MileRoundTrip_MaintainsPrecision()
{
    // Arrange
    var original = new Quantity(1, "mile");
    
    // Act: mile → km → m → ft → in → mile
    var km = original.As("km");
    var m = km.As("m");
    var ft = m.As("ft");
    var inches = ft.As("in");
    var result = inches.As("mile");
    
    // Assert: within 0.0001% (1 ppm)
    Assert.That(result.Value, Is.EqualTo(1.0).Within(0.000001));
}
```

### Category 5: Engineering Scenarios

Real-world calculations:
- Torque calculation: `force × lever_arm`
- Work/Energy: `force × distance`
- Pressure: `force ÷ area`
- Flow rate: `volume ÷ time`
- Stress: `force ÷ area` in engineering units (psi, MPa)

### Category 6: Edge Cases

Stress test decimal precision:
- Very large factors: `1 parsec × 1 lightyear` (astronomical)
- Very small factors: `1 nm × 1 nm` (nanoscale)
- Reciprocal chains: `(1 / A) × A` should equal 1
- Known problematic fractions: `1/3`, `1/7`, `22/7` (π approximation)

## Implementation Plan

### Phase 1: Test Infrastructure (0.5 day)

- [ ] Create `DecimalPrecisionTests.cs` test file
- [ ] Implement helper methods for tolerance checking
- [ ] Define representative test data (unit pairs, conversion factors)
- [ ] Set up benchmark structure for measurements

### Phase 2: Dimensional Algebra with Decimal (1 day)

- [ ] Implement basic `Quantity × Quantity` using decimal factors
- [ ] Implement basic `Quantity ÷ Quantity` using decimal factors
- [ ] Handle dimension tracking (simplified version for spike)
- [ ] Implement unit result naming (temporary logic)

**Note**: This is throwaway code for measurement only. Real implementation happens in F-002–F-007.

### Phase 3: Execute Test Matrix (0.5 day)

- [ ] Run all Category 1-6 tests
- [ ] Record precision measurements (actual vs. expected)
- [ ] Calculate relative errors for each scenario
- [ ] Document any failures or unexpected behaviors

### Phase 4: Analysis and Recommendation (0.5 day)

- [ ] Analyze results against success criteria
- [ ] Calculate worst-case error scenarios
- [ ] Determine if errors are visible in typical usage
- [ ] Write recommendation: `decimal` sufficient or need `Rational`

### Phase 5: Documentation (0.25 day)

- [ ] Update this spike with findings
- [ ] Update F-001 status based on recommendation
- [ ] Update E-001 epic timeline
- [ ] Document decision rationale for future reference

## Measurement Methodology

### Tolerance Calculation

For each test, measure:
- **Absolute error**: `|actual - expected|`
- **Relative error**: `|actual - expected| / expected`
- **ULP distance**: Count of representable values between actual and expected

### Reference Values

Use high-precision reference sources:
- NIST unit conversion tables
- Engineering handbooks (Machinery's Handbook, etc.)
- Double-precision calculations as sanity check (not authoritative)

### Reporting Format

```
Test: Multiply_InchByPoundForce_ProducesTorque
Expected: 6.77905 Nm (reference)
Actual:   6.77904999... Nm (decimal)
Abs Error: 0.00000001 Nm
Rel Error: 0.00000147% (1.47 ppm)
Status: ✅ PASS (within 0.001% tolerance)
```

## Expected Outcomes

### Likely Scenario 1: Decimal is Sufficient (70% probability)

**If** all tests pass within tolerance:
- **Action**: Continue with `decimal` for MVP
- **F-001 Status**: Remains deferred indefinitely
- **Benefits**: Simpler codebase, faster delivery, no maintenance burden for `Rational`
- **Risk**: Monitor precision in production; revisit if issues arise

### Likely Scenario 2: Decimal Shows Minor Issues (20% probability)

**If** some edge cases fail but common scenarios pass:
- **Action**: Continue with `decimal`, document known limitations
- **F-001 Status**: Deferred with caveat (implement if users report problems)
- **Mitigation**: Add validation/warnings for problematic operations

### Unlikely Scenario 3: Decimal is Insufficient (10% probability)

**If** common scenarios fail tolerance checks:
- **Action**: Implement `Rational` (F-001) before MVP release
- **F-001 Status**: Promoted back to P1 (Must)
- **Impact**: 2-day delay to MVP timeline

## Performance Considerations

While this spike focuses on **precision**, note:
- Decimal arithmetic is hardware-accelerated (~10-100ns per operation)
- Rational arithmetic requires GCD calculation (~1-10μs per operation)
- Performance evaluation happens separately in F-010

If `Rational` is needed, performance trade-off is acceptable for correctness.

## Open Questions

1. **Q**: What tolerance is acceptable for engineering applications?
   **A**: Standard engineering practice: 0.01% (1 part in 10,000) for most calculations; 0.001% for precision work

2. **Q**: Should we test with `BigInteger`/`Rational` types from external libraries?
   **A**: No. Spike evaluates built-in types only. Custom `Rational` (F-001) is self-contained.

3. **Q**: What if different unit families have different precision needs?
   **A**: Document per-family if needed; consider targeted `Rational` use (e.g., only for torque calculations)

4. **Q**: How to handle user-defined units with arbitrary factors?
   **A**: Out of scope for spike; assume standard unit catalog

## Dependencies

**Enables**:
- F-002 (Dimension Signature) — can proceed with `decimal` or wait for F-001 based on findings
- F-004 (Dimensional Math Engine) — implementation choice depends on spike results
- F-001 (Rational Arithmetic) — proceed only if spike indicates necessity

**Blocks**:
- None. Spike runs in parallel with planning; results inform F-002+ implementation approach

## Timeline

| Phase | Duration | Deliverable |
|-------|----------|-------------|
| Phase 1 | 0.5 day | Test infrastructure ready |
| Phase 2 | 1.0 day | Basic dimensional algebra working with decimal |
| Phase 3 | 0.5 day | All tests executed, data collected |
| Phase 4 | 0.5 day | Analysis complete, recommendation documented |
| Phase 5 | 0.25 day | Spike findings documented, F-001/E-001 updated |
| **Total** | **2.75 days** | **Decision: decimal sufficient or implement Rational** |

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Decimal insufficient | Low (10%) | Medium | F-001 ready as contingency; 2-day implementation |
| Test coverage incomplete | Medium | Low | Start with known problem cases; expand if needed |
| Tolerance criteria wrong | Low | Medium | Use established engineering standards; validate with domain experts |
| Spike takes longer | Medium | Low | Prioritize core scenarios; defer edge cases |

## Success Metrics

- [x] Test matrix defined (6 categories, ~20 tests)
- [ ] All tests implemented and executed
- [ ] Precision data collected for each scenario
- [ ] Recommendation documented with justification
- [ ] F-001 and E-001 updated based on findings
- [ ] Decision rationale clear for future reference

## Related Documents

- **Epic**: `.github/features/E-001.md` — Option A Hybrid Core
- **Deferred Feature**: `.github/features/F-001.md` — Core Rational Arithmetic
- **Guidelines**: `.github/instructions/dotnet-architecture-good-practices.instructions.md`

---

## Findings (To Be Completed)

### Summary

_[Will be filled in after spike execution]_

### Recommendation

_[Will be filled in after spike execution]_

**Decision**: `[ ] Continue with decimal` or `[ ] Implement Rational (F-001)`

### Supporting Data

_[Precision measurements table to be added]_

---

**Status**: Ready to execute  
**Next Action**: Implement Phase 1 (test infrastructure)
