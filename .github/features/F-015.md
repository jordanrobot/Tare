# F-015: Test Suite Expansion

**Status**: Planned  
**Epic**: E-001 (Option A Hybrid Core)  
**Priority**: P1 (Must)  
**Effort**: L (3â€“5 days)  
**Dependencies**: F-002 through F-014 (all core features)

---

## TL;DR â€” Quick Reference

**Goal**: Expand test coverage to â‰¥85% with comprehensive tests for all dimensional algebra features, edge cases, and error scenarios

**Effort**: 3-5 days (L)

**Impact**: Production-ready quality assurance, regression prevention, comprehensive validation of E-001 epic deliverables

### What Gets Tested

**ğŸ§® Dimensional Arithmetic Test Matrix**  
Full coverage of multiply/divide scenarios from S-004  
**Time**: 8-12 hours

**ğŸ” Edge Cases & Error Scenarios**  
Null handling, incompatible operations, malformed composites  
**Time**: 6-8 hours

**ğŸ“ Naming Convention Enforcement**  
All tests follow `MethodName_Condition_ExpectedResult()` pattern  
**Time**: 4-6 hours

**âœ… Integration & Round-Trip Tests**  
End-to-end scenarios, cross-system conversions, format consistency  
**Time**: 6-8 hours

**ğŸ“Š Coverage Analysis & Reporting**  
Measure and document coverage, identify gaps  
**Time**: 4-6 hours

### Quick Command Reference

```bash
# Build project
dotnet build

# Run all tests
dotnet test

# Run tests with coverage (requires dotnet-coverage tool)
dotnet-coverage collect -f cobertura -o coverage.cobertura.xml dotnet test

# Run specific test category
dotnet test --filter "FullyQualifiedName~DimensionalMath"

# Generate coverage report (requires reportgenerator tool)
reportgenerator -reports:coverage.cobertura.xml -targetdir:coverage-report -reporttypes:Html

# Install coverage tools (one-time setup)
dotnet tool install -g dotnet-coverage
dotnet tool install -g dotnet-reportgenerator-globaltool
```

---

## Mandatory Thinking (DDD/.NET Guidelines)

### 1) Analysis

**Applicable Patterns**:
- **Test-Driven Development (TDD)**: Tests validate domain rules and business logic
- **SOLID Principles in Testing**:
  - **SRP**: Each test validates one behavior
  - **OCP**: Test infrastructure extensible without modifying existing tests
  - **ISP**: Test helpers focused on specific concerns (builders, assertions)
- **Ubiquitous Language**: All test names and assertions use consistent domain terminology

**Layers Affected**:
- **Domain**: Value objects (Quantity, Rational, DimensionSignature), domain services (DimensionalMath)
- **Application**: Parsing, formatting, conversion logic
- **Infrastructure**: N/A (library context)

**Security & Compliance**:
- Validate all input boundaries (null, empty, malformed)
- Test precision requirements for financial calculations
- Ensure audit trail completeness (all operations testable)
- LGPD compliance: no sensitive data in test fixtures

### 2) Review Against Guidelines

**Aggregate Boundaries**: Tests respect value object immutability; validate state transitions

**SRP Compliance**: Each test method validates single behavior; no multi-concern tests

**Domain Rules Encapsulated**: Tests validate business rules through public APIs only

**Tests**: All follow `MethodName_Condition_ExpectedResult()` pattern without exception

**Ubiquitous Language**: Consistent terminology in test names and documentation

### 3) Implementation Plan Validation

**Test Categories to Create/Expand**:
- Dimensional arithmetic (multiply, divide, exponents)
- Known signature resolution and naming
- Composite unit parsing and formatting
- Cross-system conversions (SI â†” US Customary)
- Edge cases (null, empty, malformed, incompatible)
- Error handling and exception messages
- Round-trip consistency (construct â†’ operate â†’ format â†’ parse)
- Performance benchmarks (optional but recommended)

**Coverage Goals**:
- Domain layer: â‰¥90% (critical business logic)
- Application layer: â‰¥85% (orchestration and coordination)
- Overall project: â‰¥85%
- Exception paths: 100% (all throw statements covered)

**Testing Strategy**:
- Unit tests for isolated components
- Integration tests for cross-component scenarios
- Property-based tests for algebraic laws (associativity, commutativity)
- Performance tests for hot paths (operators, parsing)

---

## Description

F-015 establishes comprehensive test coverage for the entire E-001 epic implementation. This feature ensures:
1. All dimensional arithmetic scenarios from S-004 test matrix are validated
2. Edge cases and error conditions are thoroughly tested
3. Test naming conventions are consistently enforced
4. Coverage meets or exceeds quality gates (â‰¥85%)
5. Regression prevention through comprehensive test suite

This is the quality assurance foundation that validates the entire hybrid dimensional algebra engine.

---

## User Stories

### User Story 1: Comprehensive Dimensional Arithmetic Coverage

**As a** Tare library maintainer  
**I want** comprehensive tests for all dimensional arithmetic operations  
**So that** users can trust the library's correctness and we prevent regressions

**Example**:
```csharp
[Fact]
public void Multiply_LengthByForce_ReturnsTorque()
{
    // Arrange
    var length = Quantity.Parse("6 in");
    var force = Quantity.Parse("10 lbf");
    
    // Act
    var torque = length * force;
    
    // Assert
    Assert.Equal(60m, torque.Value);
    Assert.Equal("lbf*in", torque.Unit);
    
    // Verify conversion to SI
    var torqueNm = torque.As("Nm");
    Assert.True(Math.Abs(6.779m - torqueNm.Value) < 0.01m);
}
```

### User Story 2: Edge Case and Error Validation

**As a** Tare library maintainer  
**I want** all error paths and edge cases tested  
**So that** we provide clear error messages and handle invalid inputs gracefully

**Example**:
```csharp
[Fact]
public void Add_IncompatibleUnits_ThrowsInvalidOperationException()
{
    // Arrange
    var length = Quantity.Parse("10 m");
    var mass = Quantity.Parse("5 kg");
    
    // Act & Assert
    var ex = Assert.Throws<InvalidOperationException>(() => _ = length + mass);
    Assert.Contains("incompatible", ex.Message.ToLower());
    Assert.Contains("Length", ex.Message);
    Assert.Contains("Mass", ex.Message);
}
```

### User Story 3: Test Naming Convention Enforcement

**As a** Tare library maintainer  
**I want** all tests to follow consistent naming conventions  
**So that** tests are self-documenting and easy to understand

**Example**:
```csharp
// âœ… Good: Clear, follows pattern
[Fact]
public void Parse_CompositeUnitWithSpaces_CreatesValidQuantity()

// âŒ Bad: Unclear, doesn't follow pattern
[Fact]
public void TestParse()
```

### User Story 4: Coverage Visibility

**As a** Tare library maintainer  
**I want** clear visibility into test coverage metrics  
**So that** I can identify gaps and prioritize testing efforts

**Example**:
```bash
$ dotnet-coverage collect -f cobertura -o coverage.xml dotnet test

Coverage Report:
  Domain Layer: 92.3%
  Application Layer: 87.5%
  Overall: 88.7%
  
âœ… Meets quality gate (â‰¥85%)
```

---

## Acceptance Criteria

### 1. Test Matrix Coverage (from S-004)

- âœ… Multiply: `6 in * 10 lbf = 60 lbf*in`; equals `~6.779 Nm` (tested)
- âœ… Divide with reduction: `48 in*in / 4 in = 12 in` (tested)
- âœ… Cancellation to scalar: `48 in / 1 in = 48` (tested)
- âœ… Cross-system conversion: `100 N*m` â†” `~885.0 lbf*in` (tested)
- âœ… Volume/length â†’ area: `144 in^3 / 12 in = 12 in^2` (tested)
- âœ… Mixed aliases: `2 inch * 3 pound force` â†’ `6 lbf*in` (tested)
- âœ… Complex signature: `(lbf*in^3)/s^2` formatting stable (tested)
- âœ… Temperature differences: `(10 Â°C - 5 Â°C)` allowed with documented policy (tested)

### 2. Dimensional Arithmetic Operations

- âœ… All operator combinations tested (*, /, +, -, scalar ops)
- âœ… Known signature resolution tested for all families (Force, Energy, Torque, Pressure, etc.)
- âœ… Unknown signature fallback to composite formatting tested
- âœ… Dimensional cancellation tested (e.g., Length/Length â†’ Scalar)
- âœ… Multi-step operations tested (e.g., (Force * Length) / Time)

### 3. Parsing and Formatting

- âœ… Catalog unit parsing tested (all UnitTypeEnum values)
- âœ… Composite unit parsing tested (all notation styles: *, /, ^)
- âœ… Alias resolution tested (inch/in, pound force/lbf)
- âœ… Format to composite targets tested (e.g., `Format("lbf*in")`)
- âœ… Round-trip consistency tested (construct â†’ format â†’ parse)
- âœ… Error cases tested (unknown units, malformed composites)

### 4. Edge Cases and Error Handling

- âœ… Null input handling tested (all public methods)
- âœ… Empty/whitespace input tested
- âœ… Incompatible operations tested (add Length + Mass)
- âœ… Divide-by-zero tested (all contexts)
- âœ… Malformed composite syntax tested
- âœ… Unknown base units in composites tested
- âœ… Exception message content validated

### 5. Test Quality Standards

- âœ… All tests follow `MethodName_Condition_ExpectedResult()` naming pattern
- âœ… All tests use Arrange-Act-Assert (AAA) structure
- âœ… All tests are independent (no shared mutable state)
- âœ… All tests are deterministic (no random values, no time dependencies)
- âœ… Test names are self-documenting
- âœ… Tests use explicit assertions (no magic values)

### 6. Coverage Goals

- âœ… Domain layer coverage â‰¥90%
- âœ… Application layer coverage â‰¥85%
- âœ… Overall project coverage â‰¥85%
- âœ… All `throw` statements covered by tests
- âœ… All public methods covered by tests
- âœ… Coverage report generated and reviewed

### 7. Integration and Compatibility

- âœ… Integration tests for end-to-end scenarios
- âœ… Backward compatibility verified (all existing tests pass)
- âœ… Both TFMs tested (netstandard2.0, net7.0)
- âœ… No new test warnings introduced
- âœ… Test execution time reasonable (<5 minutes for full suite)

### 8. Documentation

- âœ… Test organization documented (categories, structure)
- âœ… Coverage reports committed to repository
- âœ… Test execution instructions in README
- âœ… Known gaps documented (if any below 85%)

---

## Technical Approach

### Phase 1: Test Infrastructure Assessment (Day 1 Morning)

**Objective**: Understand current state and identify gaps

**Tasks**:
1. Run existing test suite and measure coverage
2. Analyze coverage report by layer and component
3. Identify untested code paths
4. Document naming convention compliance
5. Review test organization and structure

**Deliverables**:
- Coverage baseline report
- Gap analysis document
- Test organization assessment

### Phase 2: Dimensional Arithmetic Tests (Day 1 Afternoon - Day 2 Morning)

**Objective**: Complete S-004 test matrix

**Test Categories**:

#### Multiplication Tests
```csharp
// Basic multiplication
Multiply_LengthByForce_ReturnsTorque()
Multiply_MassByAcceleration_ReturnsForce()
Multiply_ForceByLength_ReturnsEnergy()

// Cross-system multiplication
Multiply_MetricLengthByImperialForce_ReturnsCompositeTorque()
Multiply_WithAliases_ResolvesCorrectly()

// Scalar multiplication
Multiply_QuantityByScalar_MultipliesValue()
Multiply_ScalarByQuantity_MultipliesValue()

// Complex signatures
Multiply_ComplexUnits_ProducesStableComposite()
```

#### Division Tests
```csharp
// Basic division
Divide_AreaByLength_ReturnsLength()
Divide_VolumeByArea_ReturnsLength()
Divide_EnergyByForce_ReturnsLength()

// Dimensional cancellation
Divide_LengthByLength_ReturnsScalar()
Divide_SameComplexUnits_ReturnsScalar()

// Cross-system division
Divide_MetricEnergyByImperialTorque_ReturnsScalar()

// Scalar division
Divide_QuantityByScalar_DividesValue()
Divide_ScalarByQuantity_InvertsUnits()
```

#### Exponentiation Tests (if supported)
```csharp
Power_LengthSquared_ReturnsArea()
Power_LengthCubed_ReturnsVolume()
Root_AreaSquareRoot_ReturnsLength()
```

### Phase 3: Parsing and Formatting Tests (Day 2 Afternoon)

**Objective**: Validate all parsing and formatting scenarios

**Test Categories**:

#### Catalog Unit Parsing
```csharp
Parse_AllCatalogUnits_CreatesValidQuantities()
Parse_WithAllAliases_ResolvesCorrectly()
Parse_CaseInsensitive_ResolvesCorrectly()
Parse_WithWhitespace_HandlesGracefully()
```

#### Composite Unit Parsing
```csharp
Parse_NewtonMeter_CreatesValidQuantity()
Parse_PoundForceInch_CreatesValidQuantity()
Parse_ComplexComposite_CreatesValidQuantity()
Parse_WithExponents_CreatesValidQuantity()
Parse_WithDivision_CreatesValidQuantity()
Parse_MixedOperators_CreatesValidQuantity()
```

#### Formatting
```csharp
Format_ToCompositeTarget_ReturnsCorrectValue()
Format_ToKnownSignature_UsesPreferredUnit()
Format_ToUnknownSignature_UsesComposite()
Format_WithCulture_RespectsFormatProvider()
```

#### Round-Trip Tests
```csharp
RoundTrip_CatalogUnit_Consistent()
RoundTrip_CompositeUnit_Consistent()
RoundTrip_AfterMultiplication_Consistent()
RoundTrip_AfterConversion_Consistent()
```

### Phase 4: Edge Cases and Error Handling (Day 3 Morning)

**Objective**: Test all error paths and edge cases

**Test Categories**:

#### Null Handling
```csharp
Constructor_NullUnit_ThrowsArgumentNullException()
Parse_NullInput_ThrowsArgumentNullException()
TryParse_NullInput_ReturnsFalse()
Format_NullTarget_ThrowsArgumentNullException()
```

#### Empty/Whitespace Handling
```csharp
Constructor_EmptyUnit_ThrowsArgumentException()
Constructor_WhitespaceUnit_ThrowsArgumentException()
Parse_EmptyInput_ThrowsArgumentException()
```

#### Invalid Operations
```csharp
Add_IncompatibleUnits_ThrowsInvalidOperationException()
Subtract_IncompatibleUnits_ThrowsInvalidOperationException()
Add_VerifyExceptionMessage()
```

#### Malformed Input
```csharp
Parse_UnknownUnit_ThrowsArgumentException()
Parse_MalformedComposite_ThrowsFormatException()
Constructor_InvalidComposite_ThrowsFormatException()
```

#### Divide by Zero
```csharp
Divide_ByZeroValue_ThrowsDivideByZeroException()
Rational_ZeroDenominator_ThrowsDivideByZeroException()
```

### Phase 5: Integration and Cross-Cutting Tests (Day 3 Afternoon)

**Objective**: Validate end-to-end scenarios

**Test Categories**:

#### End-to-End Scenarios
```csharp
Integration_CompleteWorkflow_ProducesCorrectResult()
Integration_CrossSystemConversion_ProducesCorrectResult()
Integration_MultiStepCalculation_ProducesCorrectResult()
```

#### Known Signature Resolution
```csharp
KnownSignature_Force_ResolvesToNewton()
KnownSignature_Energy_ResolvesToJoule()
KnownSignature_Torque_ResolvesToNewtonMeter()
KnownSignature_Pressure_ResolvesToPascal()
```

#### Composite Operators (F-010)
```csharp
CompositeOperator_Multiply_WorksCorrectly()
CompositeOperator_Divide_WorksCorrectly()
CompositeOperator_CrossSystem_WorksCorrectly()
```

#### Helper Methods (F-013)
```csharp
GetSignature_ReturnsCorrectSignature()
IsKnownDimension_ReturnsTrueForKnown()
ToBaseUnits_ConvertsCorrectly()
ToCanonical_ConvertsToPreferredUnit()
ContainsValidUnit_ValidatesCorrectly()
GetUnitsForType_ReturnsCorrectList()
```

### Phase 6: Coverage Analysis and Gap Filling (Day 4)

**Objective**: Achieve â‰¥85% coverage

**Tasks**:
1. Generate coverage report
2. Identify uncovered code paths
3. Write tests for uncovered paths
4. Verify coverage meets quality gates
5. Document any intentional gaps

**Tools**:
```bash
# Collect coverage
dotnet-coverage collect -f cobertura -o coverage.cobertura.xml dotnet test

# Generate HTML report
reportgenerator -reports:coverage.cobertura.xml -targetdir:coverage-report -reporttypes:Html
```

### Phase 7: Test Organization and Documentation (Day 5)

**Objective**: Ensure maintainability and clarity

**Tasks**:
1. Organize tests by category (region blocks)
2. Verify naming convention compliance (all tests)
3. Update test documentation
4. Add code coverage badge to README
5. Document test execution procedures
6. Create test maintenance guide

---

## Test Organization Strategy

### File Structure

```
tests/
â”œâ”€â”€ Usings.cs (global using statements)
â”‚
â”œâ”€â”€ Core Value Objects/
â”‚   â”œâ”€â”€ QuantityTests.cs (construction, equality, comparison)
â”‚   â”œâ”€â”€ RationalTests.cs (rational arithmetic)
â”‚   â””â”€â”€ DimensionSignatureTests.cs (signature operations)
â”‚
â”œâ”€â”€ Dimensional Arithmetic/
â”‚   â”œâ”€â”€ DimensionalMathTests.cs (engine logic)
â”‚   â”œâ”€â”€ QuantityOperatorTests.cs (*, /, +, -, scalar ops)
â”‚   â””â”€â”€ CompositeOperatorTests.cs (composite unit operators)
â”‚
â”œâ”€â”€ Parsing and Formatting/
â”‚   â”œâ”€â”€ CompositeParserTests.cs (composite parsing)
â”‚   â”œâ”€â”€ QuantityFormattingTests.cs (ToString, Format)
â”‚   â”œâ”€â”€ QuantityFormatCompositeTests.cs (composite formatting)
â”‚   â””â”€â”€ QuantityCompositeConstructionTests.cs (composite construction)
â”‚
â”œâ”€â”€ Unit Resolution/
â”‚   â”œâ”€â”€ UnitResolverTests.cs (unit resolution)
â”‚   â”œâ”€â”€ UnitDefinitionTests.cs (catalog operations)
â”‚   â”œâ”€â”€ UnitDefinitionIntegrationTests.cs (catalog integration)
â”‚   â””â”€â”€ UnitTokenTests.cs (token parsing)
â”‚
â”œâ”€â”€ Known Signatures/
â”‚   â”œâ”€â”€ KnownSignatureMapTests.cs (signature mapping)
â”‚   â””â”€â”€ CompositeFormatterTests.cs (composite formatting)
â”‚
â”œâ”€â”€ Helper Methods/
â”‚   â””â”€â”€ QuantityHelperTests.cs (introspection, normalization, validation)
â”‚
â”œâ”€â”€ Special Units/
â”‚   â”œâ”€â”€ DozenUnitTests.cs (dozen unit tests)
â”‚   â””â”€â”€ QuantityComparerTests.cs (comparison logic)
â”‚
â””â”€â”€ Integration/
    â””â”€â”€ (End-to-end scenario tests)
```

### Test Naming Convention

**Pattern**: `MethodName_Condition_ExpectedResult()`

**Examples**:
```csharp
// âœ… Good examples
Multiply_LengthByForce_ReturnsTorque()
Parse_CompositeWithSpaces_CreatesValidQuantity()
Add_IncompatibleUnits_ThrowsInvalidOperationException()
Format_ToPreferredUnit_ReturnsCorrectValue()

// âŒ Bad examples (don't follow pattern)
TestMultiply()
QuantityTest1()
Verify_Multiplication()
MultiplyLengthByForce()
```

### Test Structure (AAA Pattern)

```csharp
[Fact]
public void MethodName_Condition_ExpectedResult()
{
    // Arrange - Set up test data and preconditions
    var length = Quantity.Parse("10 m");
    var force = Quantity.Parse("5 N");
    
    // Act - Execute the method under test
    var result = length * force;
    
    // Assert - Verify the outcome
    Assert.Equal(50m, result.Value);
    Assert.Equal("Nm", result.Unit);
    Assert.Equal(UnitTypeEnum.Energy, result.UnitType);
}
```

---

## Test Matrix from S-004 (Detailed Specifications)

### 1. Multiply: Length Ã— Force = Torque
```csharp
[Fact]
public void Multiply_LengthByForce_ReturnsTorque()
{
    // Arrange
    var length = Quantity.Parse("6 in");
    var force = Quantity.Parse("10 lbf");
    
    // Act
    var torque = length * force;
    
    // Assert
    Assert.Equal(60m, torque.Value);
    Assert.Equal("lbf*in", torque.Unit);
    
    // Verify conversion to SI
    var torqueNm = torque.As("Nm");
    Assert.True(Math.Abs(6.779m - torqueNm.Value) < 0.01m, 
        $"Expected ~6.779 Nm, got {torqueNm.Value} Nm");
}
```

### 2. Divide with Reduction: Area Ã· Length = Length
```csharp
[Fact]
public void Divide_AreaByLength_ReturnsLength()
{
    // Arrange
    var area = Quantity.Parse("48 in*in");
    var length = Quantity.Parse("4 in");
    
    // Act
    var result = area / length;
    
    // Assert
    Assert.Equal(12m, result.Value);
    Assert.Equal("in", result.Unit);
    Assert.Equal(UnitTypeEnum.Length, result.UnitType);
}
```

### 3. Cancellation to Scalar: Length Ã· Length = Scalar
```csharp
[Fact]
public void Divide_SameUnit_ReturnsScalar()
{
    // Arrange
    var numerator = Quantity.Parse("48 in");
    var denominator = Quantity.Parse("1 in");
    
    // Act
    var result = numerator / denominator;
    
    // Assert
    Assert.Equal(48m, result.Value);
    Assert.Equal("", result.Unit); // Dimensionless
    Assert.Equal(UnitTypeEnum.Dimensionless, result.UnitType);
}
```

### 4. Cross-System Conversion: NÂ·m â†” lbfÂ·in
```csharp
[Fact]
public void Convert_NewtonMeterToLbfIn_ConvertsCorrectly()
{
    // Arrange
    var torqueNm = Quantity.Parse("100 Nm");
    
    // Act
    var torqueLbfIn = torqueNm.As("lbf*in");
    
    // Assert
    Assert.True(Math.Abs(885.0m - torqueLbfIn.Value) < 1.0m,
        $"Expected ~885.0 lbf*in, got {torqueLbfIn.Value} lbf*in");
}

[Fact]
public void Convert_LbfInToNewtonMeter_ConvertsCorrectly()
{
    // Arrange
    var torqueLbfIn = Quantity.Parse("885 lbf*in");
    
    // Act
    var torqueNm = torqueLbfIn.As("Nm");
    
    // Assert
    Assert.True(Math.Abs(100.0m - torqueNm.Value) < 0.1m,
        $"Expected ~100.0 Nm, got {torqueNm.Value} Nm");
}
```

### 5. Volume Ã· Length = Area
```csharp
[Fact]
public void Divide_VolumeByLength_ReturnsArea()
{
    // Arrange
    var volume = Quantity.Parse("144 in^3");
    var length = Quantity.Parse("12 in");
    
    // Act
    var area = volume / length;
    
    // Assert
    Assert.Equal(12m, area.Value);
    Assert.Equal("in^2", area.Unit);
    Assert.Equal(UnitTypeEnum.Area, area.UnitType);
}
```

### 6. Mixed Aliases: inch Ã— pound force
```csharp
[Fact]
public void Multiply_UsingAliases_ResolvesCorrectly()
{
    // Arrange
    var length = Quantity.Parse("2 inch");
    var force = Quantity.Parse("3 pound force");
    
    // Act
    var torque = length * force;
    
    // Assert
    Assert.Equal(6m, torque.Value);
    Assert.Equal("lbf*in", torque.Unit);
}
```

### 7. Complex Signature: Stability Test
```csharp
[Fact]
public void Format_ComplexSignature_IsStable()
{
    // Arrange
    var complex = new Quantity(10m, "lbf*in^3/s^2");
    
    // Act
    var formatted1 = complex.ToString();
    var formatted2 = complex.Format(complex.Unit);
    var parsed = Quantity.Parse(formatted1);
    var formatted3 = parsed.ToString();
    
    // Assert
    Assert.Equal(formatted1, formatted2);
    Assert.Equal(formatted1, formatted3);
    Assert.Equal(10m, parsed.Value);
}
```

### 8. Temperature Differences
```csharp
[Fact]
public void Subtract_CelsiusTemperatures_AllowedPerPolicy()
{
    // Arrange
    var temp1 = Quantity.Parse("10 Â°C");
    var temp2 = Quantity.Parse("5 Â°C");
    
    // Act
    var delta = temp1 - temp2;
    
    // Assert
    Assert.Equal(5m, delta.Value);
    Assert.Equal("Â°C", delta.Unit);
    // Note: Result represents temperature difference, not absolute temperature
    // Policy documented: temperature arithmetic allowed, user responsible for interpretation
}
```

---

## Coverage Goals and Metrics

### Domain Layer (Target: â‰¥90%)

**Components**:
- `Quantity` (value object): 95%
- `Rational` (value object): 95%
- `DimensionSignature` (value object): 95%
- `DimensionalMath` (domain service): 90%
- `KnownSignatureMap` (domain service): 90%

### Application Layer (Target: â‰¥85%)

**Components**:
- `CompositeParser`: 90%
- `CompositeFormatter`: 90%
- `UnitResolver`: 85%
- `UnitDefinitions`: 85%

### Overall Project (Target: â‰¥85%)

**Metrics**:
- Line coverage: â‰¥85%
- Branch coverage: â‰¥80%
- Method coverage: â‰¥90%

### Exception Paths (Target: 100%)

- All `throw` statements covered
- All exception types validated
- All error messages tested

---

## Out of Scope

- âŒ Performance benchmarking (handled separately)
- âŒ Mutation testing (future enhancement)
- âŒ Property-based testing (future enhancement)
- âŒ Stress testing (future enhancement)
- âŒ Concurrency testing (library is stateless)
- âŒ UI testing (no UI in library)

---

## Dependencies

### Consumes
- **F-002 through F-014**: All features must be implemented before comprehensive testing

### Enables
- **Production Release**: Quality gate for v2.0 release
- **Continuous Integration**: Foundation for automated testing
- **Regression Prevention**: Safety net for future changes

---

## Testing Strategy Details

### Unit Tests

**Focus**: Isolated component behavior

**Characteristics**:
- Fast execution (<1ms per test)
- No external dependencies
- Deterministic results
- Independent (can run in any order)

**Coverage**: 70-80% of total test count

### Integration Tests

**Focus**: Cross-component scenarios

**Characteristics**:
- Moderate execution time (1-10ms per test)
- Multiple components involved
- Real implementations (no mocks)
- End-to-end workflows

**Coverage**: 20-30% of total test count

### Edge Case Tests

**Focus**: Boundary conditions and error paths

**Characteristics**:
- Validate null/empty/malformed inputs
- Test exception types and messages
- Verify error recovery
- Guard clause validation

**Coverage**: Included in unit and integration tests

---

## Breaking Changes

âœ… **NONE** - This feature only adds tests

**Why No Breaking Changes**:
- Tests are not part of public API
- No production code modified (only test code)
- Existing tests remain unchanged
- New tests validate existing behavior

---

## Documentation Updates

### README.md

Add section:
```markdown
## Testing

### Running Tests

```bash
# Run all tests
dotnet test

# Run with coverage
dotnet-coverage collect -f cobertura -o coverage.xml dotnet test

# Generate coverage report
reportgenerator -reports:coverage.xml -targetdir:coverage-report -reporttypes:Html
```

### Test Coverage

Current coverage: 88.7% (target: â‰¥85%)

- Domain Layer: 92.3%
- Application Layer: 87.5%

View detailed coverage report: `coverage-report/index.html`
```

### CHANGELOG.md

Add entry:
```markdown
## [version] - [date]

### Added
- Comprehensive test suite expansion (F-015)
- Full S-004 test matrix coverage
- Edge case and error scenario tests
- Test naming convention enforcement
- Coverage reporting and analysis

### Improved
- Test coverage increased to 88.7% (from baseline)
- All dimensional arithmetic scenarios validated
- 100% exception path coverage achieved
```

---

## Files to Create/Modify

### New Test Files (if needed)
- `tests/Integration/EndToEndScenarios.cs` (integration tests)
- `tests/EdgeCases/NullHandlingTests.cs` (consolidated edge cases)
- `tests/EdgeCases/ErrorMessageTests.cs` (error message validation)

### Existing Test Files to Expand
- `tests/QuantityOperatorTests.cs` (add missing operator tests)
- `tests/DimensionalMathTests.cs` (add S-004 matrix tests)
- `tests/CompositeParserTests.cs` (add edge cases)
- `tests/QuantityFormatCompositeTests.cs` (add round-trip tests)
- `tests/KnownSignatureMapTests.cs` (add all known signatures)
- `tests/QuantityHelperTests.cs` (add F-013 helper tests)
- All other existing test files (fill coverage gaps)

### Documentation
- `README.md` (add testing section)
- `docs/CHANGELOG.md` (add F-015 entry)
- `docs/TestingGuide.md` (new, comprehensive testing guide)
- `coverage-report/` (generated coverage reports)

---

## Quality Gates

### Before Committing
- [ ] All tests pass (100% pass rate)
- [ ] All tests follow `MethodName_Condition_ExpectedResult()` pattern
- [ ] S-004 test matrix fully covered
- [ ] Edge cases and error paths tested
- [ ] Coverage report generated

### Before PR Merge
- [ ] Code review passed
- [ ] Coverage â‰¥85% (overall)
- [ ] Domain layer coverage â‰¥90%
- [ ] Application layer coverage â‰¥85%
- [ ] Exception paths coverage 100%
- [ ] CHANGELOG.md updated
- [ ] README.md updated with testing section
- [ ] Build succeeds with zero warnings
- [ ] Test execution time <5 minutes

---

## Quality Checklist

### Domain Design Validation
- âœ… I have verified tests validate domain rules through public APIs
- âœ… I have confirmed tests use ubiquitous language consistently
- âœ… I have verified tests respect value object immutability
- âœ… I have validated tests follow AAA pattern

### Implementation Quality Validation
- âœ… I have written tests using `MethodName_Condition_ExpectedResult()` naming
- âœ… I have achieved â‰¥85% overall coverage
- âœ… I have achieved â‰¥90% domain layer coverage
- âœ… I have achieved 100% exception path coverage
- âœ… I have documented test organization and structure

### Test Quality Validation
- âœ… I have ensured all tests are independent
- âœ… I have ensured all tests are deterministic
- âœ… I have verified test names are self-documenting
- âœ… I have validated all tests use explicit assertions
- âœ… I have confirmed test execution time is reasonable

---

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| Test suite becomes too large/slow | Medium | Low | Focus on unit tests (fast); limit integration tests |
| Test brittleness (false failures) | Low | Medium | Use tolerance for floating-point; avoid time dependencies |
| Incomplete coverage in critical areas | Low | High | Prioritize domain layer; measure and track coverage |
| Test maintenance burden | Medium | Medium | Follow naming conventions; organize by category |

---

## Timeline

**Estimated Effort**: 3â€“5 days

**Breakdown**:
- **Day 1 AM**: Infrastructure assessment, coverage baseline (4 hours)
- **Day 1 PM**: Dimensional arithmetic tests (4 hours)
- **Day 2 AM**: Complete arithmetic tests, start parsing tests (4 hours)
- **Day 2 PM**: Parsing and formatting tests (4 hours)
- **Day 3 AM**: Edge cases and error handling (4 hours)
- **Day 3 PM**: Integration tests (4 hours)
- **Day 4**: Coverage analysis and gap filling (8 hours)
- **Day 5**: Organization, documentation, final verification (8 hours)

**Note**: Timeline assumes F-002 through F-014 are complete.

---

## Success Metrics

### Objective Measures
- âœ… Overall coverage â‰¥85% achieved
- âœ… Domain layer coverage â‰¥90% achieved
- âœ… Exception paths coverage 100% achieved
- âœ… All S-004 test matrix scenarios pass
- âœ… All tests follow naming convention
- âœ… Test suite executes in <5 minutes
- âœ… Zero test warnings

### Subjective Measures
- âœ… Test suite reviewed and deemed comprehensive
- âœ… Test organization reviewed and deemed maintainable
- âœ… Coverage gaps (if any) documented and justified
- âœ… Test execution procedures documented

---

## References

### Internal
- **E-001**: Epic defining F-015 scope and dependencies
- **S-004**: Spike defining test matrix requirements
- **F-002 through F-014**: All features being tested

### External
- **xUnit Documentation**: https://xunit.net/docs/getting-started/netcore/cmdline
- **Coverlet Coverage Tool**: https://github.com/coverlet-coverage/coverlet
- **ReportGenerator**: https://github.com/danielpalme/ReportGenerator
- **.NET Testing Best Practices**: https://learn.microsoft.com/en-us/dotnet/core/testing/unit-testing-best-practices

---

## Open Questions

### Q1: Should we implement property-based testing?

**Context**: Property-based testing (e.g., FsCheck) can validate algebraic properties

**Options**:
- **A**: Add property-based tests in F-015
- **B**: Defer to future enhancement based on value

**Recommendation**: **Option B** (defer). Rationale:
- Current test suite provides adequate coverage
- Property-based testing adds complexity
- Can add incrementally if gaps found
- Focus F-015 on achieving coverage goals

### Q2: Should we measure test execution performance?

**Context**: Test suite should run quickly to support development workflow

**Options**:
- **A**: Set performance targets (<5 minutes total)
- **B**: No performance targets, focus on coverage

**Recommendation**: **Option A** (set targets). Rationale:
- Fast tests encourage frequent execution
- <5 minutes is reasonable for full suite
- Can identify slow tests and optimize
- Supports CI/CD pipeline efficiency

### Q3: Should we implement mutation testing?

**Context**: Mutation testing validates test quality by introducing bugs

**Options**:
- **A**: Add mutation testing in F-015
- **B**: Defer to future enhancement

**Recommendation**: **Option B** (defer). Rationale:
- Mutation testing is time-intensive
- Current coverage metrics sufficient for F-015
- Can add later if test quality concerns arise
- Focus F-015 on coverage goals first

---

## Decisions Recorded

1. **Test Naming Convention** (2025-11-13): Enforce `MethodName_Condition_ExpectedResult()` pattern for all tests without exception. This is non-negotiable for F-015.

2. **Coverage Targets** (2025-11-13): Set minimum coverage targets:
   - Overall: â‰¥85%
   - Domain layer: â‰¥90%
   - Application layer: â‰¥85%
   - Exception paths: 100%

3. **Test Organization** (2025-11-13): Organize tests by functional area (value objects, arithmetic, parsing, etc.) rather than by type (unit/integration). This improves discoverability.

4. **S-004 Test Matrix** (2025-11-13): All 8 scenarios from S-004 test matrix are mandatory and must be explicitly tested with dedicated test methods.

5. **Property-Based Testing** (2025-11-13): Defer to future enhancement. Current explicit tests provide adequate coverage for F-015 goals.

6. **Mutation Testing** (2025-11-13): Defer to future enhancement. Focus F-015 on achieving coverage targets first.

7. **Test Execution Performance** (2025-11-13): Set target of <5 minutes for full test suite execution. Monitor and optimize slow tests.

8. **Coverage Reporting** (2025-11-13): Use Cobertura format for coverage reports. Generate HTML reports for human review. Commit coverage reports to repository.

---

**Ready for Review** âœ…  
This implementation plan defines F-015 (Test Suite Expansion) with comprehensive test matrix, coverage goals, and quality standards to validate the entire E-001 epic implementation.
