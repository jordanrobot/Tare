# S-003: Third‑party library spike — EngineeringUnits

This spike evaluates adopting the EngineeringUnits library to provide dimensional analysis and cross‑unit arithmetic.

- Repo: https://github.com/MadsKirkFoged/EngineeringUnits
- NuGet: https://www.nuget.org/packages/EngineeringUnits
- License: MIT
- Target frameworks: .NET Standard 2.0, .NET 6.0 (compatible with Tare's netstandard2.0/net7.0 targets)

## Goals

- Enable dimensional analysis and derived‑unit math (multiply/divide, powers, roots) across many physical quantities.
- Support conversions across unit systems (SI, imperial) with a broad catalog (e.g., N·m ↔ lbf·in).
- Keep Tare's core principles (value semantics, predictable formatting) and decimal‑first precision where applicable.
- Minimize churn to the existing public API; prefer additive or adapter approaches.

## Non‑Goals

- Rewrite Tare to mirror EngineeringUnits type system.
- Commit to a hard dependency without an adapter/abstraction plan.

## Quick overview of EngineeringUnits

EngineeringUnits provides strongly‑typed quantities (Length, Mass, Torque, etc.) with unit enumerations (LengthUnit, TorqueUnit, …), operators for arithmetic (+, −, ×, ÷), conversions via `.ToUnit(...)` and numeric extraction via `.As(...)`. Unit checks are enforced at runtime. The package includes extensive unit catalogs and formatting helpers.

Notable capabilities from the README:
- Arithmetic across units producing derived quantities (e.g., `MassFlow * SpecificEntropy * (T2 - T1) -> Power`).
- Temperature arithmetic without a distinct temperature‑delta type.
- Aliased unit names (e.g., SpecificEnergy ≈ Enthalpy).
- Formatting specifiers like `"S5"`, `"G4"`, and unit‑only output.
- JSON serialization examples and helpers to rebuild from value+unit strings.

## Code examples (C#)

These examples illustrate representative usage patterns taken from and aligned with the library’s README.

### Create, convert, and format

```csharp
using EngineeringUnits;
using EngineeringUnits.Units;

// Create using ctor + enum
Length L1 = new Length(1.0, LengthUnit.Yard); // 1 yd

// Alternate factory
Length L2 = Length.FromMeter(0.9144); // ~1 yd

// Convert to a different unit
Length L_in = L1.ToUnit(LengthUnit.Inch); // 36 in

double inches = L1.As(LengthUnit.Inch);   // 36.0

// Formatting (significant digits, value only, unit only)
string s1 = L1.ToString();       // default ~ S4, e.g., "1 yd"
string s2 = L1.ToString("S5");  // "1.0000 yd" (example)
string s3 = $"{L1:V4}";         // value only with 4 sig digits
string s4 = $"{L1:UnitOnly}";   // "yd"
```

### Arithmetic and derived units

```csharp
// Area from length^2
Length a = new Length(54.3, LengthUnit.Foot);
Area A = a.Pow(2);          // 2948 ft²
Length back = A.Sqrt();     // 54.3 ft

// Density from mass / volume
Mass m = new Mass(10, MassUnit.Kilogram);
Volume v = new Volume(4, VolumeUnit.CubicMeter);
Density rho = m / v;        // 2.5 kg/m³
// v / m would throw a WrongUnitException per README example
```

### Cross‑system conversion (torque)

```csharp
Torque tau = new Torque(100, TorqueUnit.NewtonMeter);
Torque tauImperial = tau.ToUnit(TorqueUnit.PoundForceInch); // ~885 lbf·in

double asLbfIn = tau.As(TorqueUnit.PoundForceInch);         // ~885.0
```

### Unit cancellation and mixed arithmetic

```csharp
// 48 in*in ÷ 4 in → 12 in (using Area and Length)
Length x = new Length(48, LengthUnit.Inch);    // interpret as 48 in
Area   area = x * new Length(1, LengthUnit.Inch); // 48 in² (illustrative)
Length result = area / new Length(4, LengthUnit.Inch); // 12 in
```

### Temperature arithmetic

```csharp
Temperature T1 = new Temperature(5, TemperatureUnit.DegreeCelsius);
Temperature T2 = new Temperature(10, TemperatureUnit.DegreeCelsius);
Temperature dT = T2 - T1; // Library treats like any other unit
```

### Rebuilding from value + unit strings (storage interop)

```csharp
// Example pattern from README: store (value, unitName) and rebuild
// e.g., value = 10, unit = "Meter"

Length len = 10d.AddUnit<LengthUnit>("Meter"); // extension provided by the library
```

## Benefits

- Broad unit catalog: Large coverage across engineering domains (mechanical, electrical, thermal, etc.).
- Strongly‑typed quantities: Compile‑time names (Length, Mass, Torque, …) with runtime unit checks for derived math.
- Rich arithmetic: Operators across units to produce derived quantities (multiply/divide, powers, sqrt).
- Formatting and helpers: Significant‑digit specifiers, unit‑only/value‑only, JSON examples, list math (Min/Max/Average), clamping.
- Cross‑system conversions: Built‑in N·m ↔ lbf·in, metric/imperial, many aliases, extensive unit lists.
- Compatibility: Targets netstandard2.0, aligns with Tare’s TFMs.
- Permissive license: MIT.

## Drawbacks / Risks

- Precision model: Most constructors/samples use `double`. Tare uses `decimal` intentionally for financial‑style precision. Mixing may introduce floating‑point rounding differences unless carefully bounded at the edges.
- Type surface area: Dozens of quantity types and unit enums increase API footprint and learning curve.
- Runtime unit checks: Errors surface at runtime (not compile‑time). While powerful, this shifts detection later.
- Dependency weight: Adds a third‑party dependency (~700 KB package as of current NuGet), impacting minimal footprint goals.
- API mismatch: Tare’s single `Quantity` (value + unit string) differs from per‑quantity types; requires an adapter to avoid rippling changes across consumers.

## Comparison: Tare vs EngineeringUnits

| Aspect | Tare (current) | EngineeringUnits |
|---|---|---|
| Core type | Single readonly struct `Quantity` (decimal value + unit string) | Many quantity types (Length, Mass, Torque, …) with unit enums |
| Dimensional analysis | Not supported yet (spikes F‑001/F‑002) | Supported via operators, powers, sqrt, runtime checks |
| Conversions | Within same unit type via `UnitDefinitions` factor | Cross‑system conversions built‑in per quantity |
| Precision | `decimal` for value computations | Predominantly `double` in API and SI helpers |
| Parsing | String‑based via Tare’s `Parse`/`UnitDefinitions` | Enum‑driven; string helpers exist (e.g., `AddUnit<TUnit>("Meter")`) |
| Formatting | Stable unit‑included strings | Format specifiers (Sx, Gx, Vx), unit‑only, extensive options |
| Extensibility | Add units via `UnitDefinitions` | Add custom units (wiki guide); very large built‑in catalog |
| TFMs | netstandard2.0, net7.0 | netstandard2.0, net6.0 |

## Interop/Adoption options

1) Adapter inside Tare (recommended for exploration)
- Keep Tare’s public API (`Quantity`).
- Internally, map `Quantity` to the closest EngineeringUnits type when operations require dimensional math.
- Maintain decimal at Tare boundaries; convert to/from double with controlled rounding only when invoking EngineeringUnits operations.
- Pros: Minimal surface change, incremental adoption. Cons: Mapping table and conversion policy needed; performance overhead in adapters.

2) Dual‑path implementation
- For simple same‑type conversions, use existing Tare `UnitDefinitions` (decimal‑preserving).
- For compound operations (e.g., length × length ÷ length, torque conversions), delegate to EngineeringUnits.
- Pros: Preserves precision for simple cases. Cons: Split logic may surprise maintainers.

3) Direct dependency (breaking change)
- Expose EngineeringUnits types directly in Tare’s public API.
- Pros: Leverages full feature set, less glue. Cons: Significant breaking changes; diverges from Tare’s minimal surface.

## Example adapter sketch (conceptual)

- Contract
  - Input: Tare `Quantity`(decimal value, string unit)
  - Output: EngineeringUnits quantity (e.g., `Length`, `Area`, `Torque`) with the correct `*Unit` enum
  - Error modes: Unknown unit; unsupported mapping; incompatible operation
- Steps
  - Resolve Tare unit to `UnitTypeEnum`; select matching EngineeringUnits quantity type
  - Convert decimal → double once, call library op, convert result back (double → decimal) with configurable rounding
  - Preserve Tare’s formatting and unit strings when returning to callers

## Test matrix (to mirror F‑001/F‑002)

- 48 in*in ÷ 4 in → 12 in (area/length → length)
- 100 N·m ↔ ~885.0 lbf·in (torque)
- 144 in³ ÷ 12 in → 12 in² (volume/length → area)
- Temperature arithmetic: (10 °C − 5 °C) valid; conversions to °F
- Wrong unit detection example (e.g., volume/mass vs mass/volume) throws

## Evaluation criteria

- Coverage: Required quantities/units present (mechanical, thermal, electrical basics)
- Precision: Tolerance bounds when bridging decimal↔double; deterministic formatting
- Ergonomics: Feasibility of an adapter without leaking types; predictable error messages
- Performance: Overhead of mapping + conversions vs pure Tare
- Maintenance: Catalog updates, versioning cadence, and community support

## Recommendation (initial)

Proceed with a thin adapter spike to validate:
- Mapping Tare units to a subset of EngineeringUnits quantities needed for the use‑cases in F‑001.
- Round‑trip arithmetic for the test matrix with explicit decimal rounding policy at Tare boundaries.
- Error shaping to match current/desired Tare exception messages.

If results are positive (accuracy, ergonomics, and performance acceptable), consider formalizing the adapter and gating EngineeringUnits usage behind a feature flag or internal abstraction to limit blast radius.
