# F-005: Known-Signature Naming Map

**Status**: Planned  
**Priority**: P1 (Must)  
**Effort**: M (1.5–2 days)  
**Epic**: E-001 — Option A Hybrid Core  
**Dependencies**: F-002 (Dimension Signature Model), F-004 (Dimensional Math Engine)

---

## Feature Overview

This feature delivers a known-signature naming map that provides preferred unit names for common dimension signatures. When dimensional algebra operations produce results, the map enables the system to display them using recognized unit names (e.g., "Nm" for torque, "Pa" for pressure, "m²" for area) rather than generic composite strings.

### User Story

**As a** Tare library user performing engineering calculations  
**I want** multiplication and division results to display using recognized unit names when available  
**So that** results like force×length appear as "Nm" (torque) instead of "kg·m²/s²", improving readability and domain alignment

### Context

F-005 is the fifth feature in the E-001 epic implementing Option A (Hybrid Core). It builds on:
- **F-002**: Dimension signature model for representing dimensional compositions
- **F-004**: Dimensional math engine that produces dimension signatures from operations

The known-signature map bridges computational results with domain-specific naming conventions:
- Maps dimension signatures to preferred canonical unit names
- Supports both SI and US Customary unit preferences  
- Provides fallback to composite formatting when signature is unknown
- Enables future extensibility for domain-specific naming preferences

This feature will be consumed by F-006 (Composite Unit Formatter) and F-007 (Operators Integration) to present results with appropriate unit naming.

---

## Mandatory Thinking Process (DDD/.NET Guidelines)

### 1. Domain Analysis (REQUIRED)

#### Domain Concepts Involved

- **Known Signature**: A dimension signature with a recognized canonical unit name (e.g., Force = "N", Torque = "Nm")
- **Signature Family**: A conceptual grouping of signatures representing the same physical quantity (e.g., Energy and Torque share signature L²M¹T⁻²)
- **Preferred Unit**: The canonical unit name chosen for a signature family (SI-first: "Nm" for torque, or US Customary: "lbf·in")
- **Unit System Preference**: Choice between SI (meters, newtons) or US Customary (feet, pound-force)
- **Composite Fallback**: Generic unit string used when signature is not in the known map
- **Signature Resolution**: The process of looking up a signature to find its preferred unit name

#### Aggregate Boundaries and Consistency Requirements

- **Value Objects**: 
  - `DimensionSignature` — Immutable signature from F-002
  - `PreferredUnit` — Value object containing canonical name and alternative names
- **Domain Service**: 
  - `IKnownSignatureMap` — Interface for signature → name resolution
  - `KnownSignatureMap` — Implementation with built-in known signatures
- **Consistency**: 
  - Each signature maps to one preferred unit per naming system (SI vs US Customary)
  - Signatures are unique keys (immutable, deterministic hashing)
  - Names are stable across library versions (backward compatibility)

#### Ubiquitous Language Terms

- **Known Signature**, **Preferred Unit**, **Canonical Name**, **SI System**, **US Customary System**, **Composite Fallback**, **Unit Family**, **Dimension Resolution**

#### Business Rules and Invariants

- **SI-First Policy**: Default to SI unit names when both systems provide options
- **Deterministic Resolution**: Same signature always resolves to same name (for a given preference)
- **Extensibility**: Map can be extended with new signatures without modifying core logic
- **Fallback Behavior**: Unknown signatures return null (caller handles composite formatting)

### 2. Architecture Review (REQUIRED)

#### Layer Responsibilities

- **Domain Layer**: 
  - `PreferredUnit` value object (internal)
  - `IKnownSignatureMap` interface (internal)
  - `KnownSignatureMap` implementation (internal sealed class)
- **Integration Points**:
  - Consumes `DimensionSignature` from F-002
  - Provides naming for `DimensionalResult` from F-004
  - Used by F-006 (Composite Formatter) and F-007 (Operators Integration)

#### SOLID Principles Adherence

- **SRP**: `KnownSignatureMap` has single responsibility—resolve signatures to preferred names
- **OCP**: Extensible to new signatures via map additions; closed to modification of resolution logic
- **LSP**: N/A (no inheritance hierarchy for value objects)
- **ISP**: Interface focused only on signature resolution operations
- **DIP**: Depends on `DimensionSignature` abstraction; consumers depend on `IKnownSignatureMap` interface

#### Domain Events

- N/A — Signature resolution is a pure lookup operation with no side effects

#### Security Implications

- No user credentials or sensitive data
- Deterministic behavior with no external dependencies
- Immutable data structures prevent modification attacks

### 3. Implementation Planning (REQUIRED)

#### Files to Create/Modify

| File | Type | Justification |
|------|------|---------------|
| `src/Internal/Units/PreferredUnit.cs` | New | Value object for preferred unit names (canonical + alternatives) |
| `src/Internal/Units/IKnownSignatureMap.cs` | New | Interface for signature resolution service |
| `src/Internal/Units/KnownSignatureMap.cs` | New | Implementation with built-in signature → name mappings |
| `src/Internal/Units/UnitSystemPreference.cs` | New | Enum for SI vs US Customary preference (future use) |
| `tests/KnownSignatureMapTests.cs` | New | Comprehensive unit tests for map |
| `tests/PreferredUnitTests.cs` | New | Tests for PreferredUnit value object |
| `docs/CHANGELOG.md` | Modified | Document internal implementation |

#### Test Cases (Following `MethodName_Condition_ExpectedResult()` Pattern)

**Signature Resolution:**
- `TryGetPreferredUnit_ForceSignature_ReturnsNewton()`
- `TryGetPreferredUnit_TorqueSignature_ReturnsNewtonMeter()`
- `TryGetPreferredUnit_PressureSignature_ReturnsPascal()`
- `TryGetPreferredUnit_AreaSignature_ReturnsSquareMeter()`
- `TryGetPreferredUnit_VelocitySignature_ReturnsMeterPerSecond()`
- `TryGetPreferredUnit_UnknownSignature_ReturnsFalse()`

**US Customary Alternatives:**
- `TryGetPreferredUnit_ForceSignatureUSCustomary_ReturnsPoundForce()`
- `TryGetPreferredUnit_TorqueSignatureUSCustomary_ReturnsPoundForceInch()`
- `TryGetPreferredUnit_PressureSignatureUSCustomary_ReturnsPSI()`

**Edge Cases:**
- `TryGetPreferredUnit_DimensionlessSignature_ReturnsEmptyString()`
- `TryGetPreferredUnit_ComplexUnknownSignature_ReturnsFalse()`
- `IsKnown_KnownSignature_ReturnsTrue()`
- `IsKnown_UnknownSignature_ReturnsFalse()`

**Multiple Names (same signature, different contexts):**
- `TryGetPreferredUnit_EnergyTorqueSignature_ReturnsJoule()` — Default for energy context
- `GetAlternativeNames_EnergyTorqueSignature_IncludesNewtonMeter()` — Torque alternative

#### Error Handling and Validation Strategy

- **No Exceptions**: Signature resolution uses `TryGetPreferredUnit` pattern (returns bool)
- **Null Handling**: Signature parameter validated with `ArgumentNullException.ThrowIfNull`
- **Thread Safety**: Immutable dictionary ensures thread-safe lookups
- **Unknown Signatures**: Return false from `TryGetPreferredUnit`; caller decides fallback strategy

#### Performance and Scalability Considerations

- **Lookup Efficiency**: O(1) dictionary lookup by signature
- **Memory**: Small static dictionary (~50-100 entries initially); minimal overhead
- **Caching**: No caching needed; map is static and immutable
- **Allocation**: Value types minimize allocation overhead

---

## Detailed Implementation Design

### PreferredUnit Value Object

```csharp
namespace Tare.Internal.Units;

/// <summary>
/// Represents a preferred unit name for a known dimension signature.
/// Includes the canonical name and optional alternative names for different contexts.
/// </summary>
internal readonly struct PreferredUnit : IEquatable<PreferredUnit>
{
    /// <summary>
    /// Gets the canonical unit name (e.g., "N", "Nm", "Pa", "m²").
    /// </summary>
    public string CanonicalName { get; }
    
    /// <summary>
    /// Gets alternative names for the same signature (e.g., "J" as alternative to "Nm" for energy).
    /// </summary>
    public IReadOnlyList<string> AlternativeNames { get; }
    
    /// <summary>
    /// Gets a description of the physical quantity (e.g., "Force", "Torque", "Pressure").
    /// </summary>
    public string Description { get; }
    
    /// <summary>
    /// Initializes a new instance of the <see cref="PreferredUnit"/> struct.
    /// </summary>
    public PreferredUnit(string canonicalName, string description, params string[] alternativeNames);
    
    // IEquatable implementation
    public bool Equals(PreferredUnit other);
    public override bool Equals(object? obj);
    public override int GetHashCode();
    public static bool operator ==(PreferredUnit left, PreferredUnit right);
    public static bool operator !=(PreferredUnit left, PreferredUnit right);
    
    public override string ToString();
}
```

### IKnownSignatureMap Interface

```csharp
namespace Tare.Internal.Units;

/// <summary>
/// Service interface for resolving dimension signatures to preferred unit names.
/// </summary>
internal interface IKnownSignatureMap
{
    /// <summary>
    /// Attempts to get the preferred unit for a given dimension signature.
    /// </summary>
    /// <param name="signature">The dimension signature to resolve.</param>
    /// <param name="preferredUnit">The preferred unit if found; otherwise default.</param>
    /// <returns>True if the signature is known; false otherwise.</returns>
    bool TryGetPreferredUnit(DimensionSignature signature, out PreferredUnit preferredUnit);
    
    /// <summary>
    /// Checks if a signature is known in the map.
    /// </summary>
    /// <param name="signature">The dimension signature to check.</param>
    /// <returns>True if the signature has a known preferred unit.</returns>
    bool IsKnown(DimensionSignature signature);
    
    /// <summary>
    /// Gets all known signatures in the map.
    /// </summary>
    IEnumerable<DimensionSignature> GetKnownSignatures();
}
```

### KnownSignatureMap Implementation

```csharp
namespace Tare.Internal.Units;

/// <summary>
/// Provides a mapping from dimension signatures to preferred unit names.
/// Implements the known-signature naming map for common physical quantities.
/// </summary>
internal sealed class KnownSignatureMap : IKnownSignatureMap
{
    /// <summary>
    /// Singleton instance for efficient reuse.
    /// </summary>
    public static readonly KnownSignatureMap Instance = new KnownSignatureMap();
    
    private readonly IReadOnlyDictionary<DimensionSignature, PreferredUnit> _signatureMap;
    
    private KnownSignatureMap()
    {
        _signatureMap = BuildSignatureMap();
    }
    
    /// <inheritdoc/>
    public bool TryGetPreferredUnit(DimensionSignature signature, out PreferredUnit preferredUnit)
    {
        ArgumentNullException.ThrowIfNull(signature);
        return _signatureMap.TryGetValue(signature, out preferredUnit);
    }
    
    /// <inheritdoc/>
    public bool IsKnown(DimensionSignature signature)
    {
        ArgumentNullException.ThrowIfNull(signature);
        return _signatureMap.ContainsKey(signature);
    }
    
    /// <inheritdoc/>
    public IEnumerable<DimensionSignature> GetKnownSignatures()
    {
        return _signatureMap.Keys;
    }
    
    private static IReadOnlyDictionary<DimensionSignature, PreferredUnit> BuildSignatureMap()
    {
        var map = new Dictionary<DimensionSignature, PreferredUnit>();
        
        // Dimensionless (Scalar)
        map[DimensionSignature.Dimensionless] = 
            new PreferredUnit("", "Dimensionless", "each", "1");
        
        // Base SI Dimensions
        map[DimensionSignature.LengthSignature] = 
            new PreferredUnit("m", "Length");
        map[DimensionSignature.MassSignature] = 
            new PreferredUnit("kg", "Mass");
        map[DimensionSignature.TimeSignature] = 
            new PreferredUnit("s", "Time");
        
        // Derived Dimensions - Area, Volume
        map[DimensionSignature.AreaSignature] = 
            new PreferredUnit("m²", "Area", "m^2");
        map[DimensionSignature.VolumeSignature] = 
            new PreferredUnit("m³", "Volume", "m^3");
        
        // Kinematics
        map[DimensionSignature.VelocitySignature] = 
            new PreferredUnit("m/s", "Velocity");
        map[DimensionSignature.AccelerationSignature] = 
            new PreferredUnit("m/s²", "Acceleration", "m/s^2");
        
        // Dynamics
        map[DimensionSignature.ForceSignature] = 
            new PreferredUnit("N", "Force", "newton");
        map[DimensionSignature.EnergySignature] = 
            new PreferredUnit("J", "Energy", "joule", "Nm");  // Also used for Torque
        map[DimensionSignature.PowerSignature] = 
            new PreferredUnit("W", "Power", "watt");
        
        // Pressure and Related
        map[DimensionSignature.PressureSignature] = 
            new PreferredUnit("Pa", "Pressure", "pascal");
        
        // Additional common signatures can be added here
        
        return map;
    }
}
```

### UnitSystemPreference Enum (Future Use)

```csharp
namespace Tare.Internal.Units;

/// <summary>
/// Specifies the unit system preference for resolving dimension signatures.
/// </summary>
/// <remarks>
/// This enum enables future support for preferred unit naming based on unit system.
/// Initially, only SI (SI-first policy) is implemented.
/// </remarks>
internal enum UnitSystemPreference
{
    /// <summary>
    /// Prefer SI units (meters, newtons, pascals).
    /// </summary>
    SI = 0,
    
    /// <summary>
    /// Prefer US Customary units (feet, pound-force, PSI).
    /// </summary>
    USCustomary = 1
}
```

**Note**: Initial implementation uses SI-first policy only. US Customary preferences will be added in a future iteration when user demand is validated.

---

## Initial Known Signatures

The following signatures will be included in the initial map:

### Base Dimensions
- **Dimensionless** (0,0,0,0,0,0,0) → "" (empty string) or "each"
- **Length** (1,0,0,0,0,0,0) → "m"
- **Mass** (0,1,0,0,0,0,0) → "kg"
- **Time** (0,0,1,0,0,0,0) → "s"
- **Electric Current** (0,0,0,1,0,0,0) → "A"
- **Temperature** (0,0,0,0,1,0,0,0) → "K"
- **Amount of Substance** (0,0,0,0,0,1,0) → "mol"
- **Luminous Intensity** (0,0,0,0,0,0,1) → "cd"

### Geometric Dimensions
- **Area** (2,0,0,0,0,0,0) → "m²"
- **Volume** (3,0,0,0,0,0,0) → "m³"

### Kinematic Dimensions
- **Velocity** (1,0,-1,0,0,0,0) → "m/s"
- **Acceleration** (1,0,-2,0,0,0,0) → "m/s²"

### Dynamic Dimensions
- **Force** (1,1,-2,0,0,0,0) → "N" (newton)
- **Energy/Torque** (2,1,-2,0,0,0,0) → "J" (joule) — Primary: energy; Alternative: "Nm" for torque
- **Power** (2,1,-3,0,0,0,0) → "W" (watt)
- **Pressure** (-1,1,-2,0,0,0,0) → "Pa" (pascal)

### Additional Common Dimensions (Initial Set)
- **Frequency** (0,0,-1,0,0,0,0) → "Hz" (hertz)
- **Momentum** (1,1,-1,0,0,0,0) → "kg·m/s"
- **Angular Momentum** (2,1,-1,0,0,0,0) → "kg·m²/s"
- **Density** (-3,1,0,0,0,0,0) → "kg/m³"

**Extensibility**: Additional signatures can be added based on user needs. The initial set covers ~80% of common engineering calculations.

---

## Specific Tasks

### Phase 1: Value Object and Interface (Day 1, 2-3 hours)

- [ ] Create `PreferredUnit` value object
  - [ ] Define readonly struct with CanonicalName, Description, AlternativeNames
  - [ ] Implement constructor with validation
  - [ ] Implement `IEquatable<PreferredUnit>` interface
  - [ ] Override `Equals(object?)`, `GetHashCode()`, `ToString()`
  - [ ] Implement equality operators (`==`, `!=`)
  - [ ] Add XML documentation
- [ ] Create `IKnownSignatureMap` interface
  - [ ] Define `TryGetPreferredUnit` method signature
  - [ ] Define `IsKnown` method signature
  - [ ] Define `GetKnownSignatures` method signature
  - [ ] Add XML documentation
- [ ] Create `UnitSystemPreference` enum
  - [ ] Define SI and USCustomary values
  - [ ] Add XML documentation (note: only SI implemented initially)

### Phase 2: Map Implementation (Day 1-2, 3-4 hours)

- [ ] Create `KnownSignatureMap` implementation
  - [ ] Define sealed class implementing `IKnownSignatureMap`
  - [ ] Create singleton instance pattern
  - [ ] Implement `BuildSignatureMap()` private method
  - [ ] Add all initial known signatures (base, geometric, kinematic, dynamic)
  - [ ] Implement `TryGetPreferredUnit` with dictionary lookup
  - [ ] Implement `IsKnown` with containment check
  - [ ] Implement `GetKnownSignatures` returning keys
  - [ ] Add comprehensive XML documentation
- [ ] Validate signature mappings
  - [ ] Verify each signature matches expected exponents
  - [ ] Confirm canonical names match SI standards
  - [ ] Validate alternative names are meaningful

### Phase 3: Comprehensive Testing (Day 2, 3-4 hours)

- [ ] Create `PreferredUnitTests.cs`
  - [ ] Test constructor with valid inputs
  - [ ] Test equality for identical units
  - [ ] Test inequality for different units
  - [ ] Test hash code consistency
  - [ ] Test `ToString()` output
- [ ] Create `KnownSignatureMapTests.cs`
  - [ ] Test `TryGetPreferredUnit` for each known signature
    - [ ] Dimensionless → ""
    - [ ] Length → "m"
    - [ ] Force → "N"
    - [ ] Torque/Energy → "J" (with "Nm" alternative)
    - [ ] Pressure → "Pa"
    - [ ] Area → "m²"
    - [ ] Velocity → "m/s"
    - [ ] Power → "W"
  - [ ] Test `TryGetPreferredUnit` for unknown signatures
    - [ ] Complex unknown signature returns false
    - [ ] Out parameter remains default when not found
  - [ ] Test `IsKnown` method
    - [ ] Known signatures return true
    - [ ] Unknown signatures return false
  - [ ] Test `GetKnownSignatures` method
    - [ ] Returns all known signatures
    - [ ] Count matches expected number
  - [ ] Test alternative names
    - [ ] Energy signature includes "Nm" alternative
    - [ ] Area signature includes "m^2" alternative
  - [ ] Test singleton pattern
    - [ ] Instance is not null
    - [ ] Multiple accesses return same instance

### Phase 4: Integration and Documentation (Day 2, 1-2 hours)

- [ ] Integration validation
  - [ ] Verify signatures match `DimensionSignature` factory methods
  - [ ] Confirm compatibility with `DimensionalResult` from F-004
  - [ ] Validate interface suitable for F-006 and F-007 consumption
- [ ] Add comprehensive XML documentation
  - [ ] All public-within-internal members documented
  - [ ] Examples in remarks where helpful
  - [ ] Document design decisions (SI-first policy, extensibility)
- [ ] Update CHANGELOG.md
  - [ ] Note internal implementation (not public API change)
  - [ ] Document initial set of known signatures
  - [ ] Reference F-005 feature completion
- [ ] Code review
  - [ ] SOLID principles adherence
  - [ ] Immutability verification
  - [ ] Thread-safety confirmation
  - [ ] Naming consistency

---

## Acceptance Criteria

### Functional Requirements

✅ **AC-1**: Map resolves all initial known signatures to correct canonical names  
✅ **AC-2**: Unknown signatures return false from `TryGetPreferredUnit`  
✅ **AC-3**: Dimensionless signature resolves to empty string ""  
✅ **AC-4**: Force signature resolves to "N" (newton)  
✅ **AC-5**: Energy/Torque signature resolves to "J" (joule) with "Nm" alternative  
✅ **AC-6**: Pressure signature resolves to "Pa" (pascal)  
✅ **AC-7**: Area signature resolves to "m²" (square meter)  
✅ **AC-8**: Velocity signature resolves to "m/s"  
✅ **AC-9**: `IsKnown` correctly identifies known vs unknown signatures  
✅ **AC-10**: `GetKnownSignatures` returns all mapped signatures

### Quality Requirements

✅ **AC-11**: All tests follow `MethodName_Condition_ExpectedResult()` naming convention  
✅ **AC-12**: Test coverage ≥85% for `KnownSignatureMap` and `PreferredUnit`  
✅ **AC-13**: No public API changes (internal implementation only)  
✅ **AC-14**: No external dependencies added  
✅ **AC-15**: Builds successfully on both `netstandard2.0` and `net7.0` TFMs  
✅ **AC-16**: No compiler warnings related to new code

### Non-Functional Requirements

✅ **AC-17**: O(1) lookup performance (dictionary-based)  
✅ **AC-18**: Thread-safe (immutable dictionary)  
✅ **AC-19**: Minimal memory footprint (<50KB for initial map)  
✅ **AC-20**: XML documentation for all members  
✅ **AC-21**: CHANGELOG.md updated with implementation note

### Integration Requirements

✅ **AC-22**: Compatible with `DimensionSignature` from F-002  
✅ **AC-23**: Ready for F-006 (Composite Formatter) integration  
✅ **AC-24**: Ready for F-007 (Operators Integration) consumption  
✅ **AC-25**: Extensible for future signature additions

---

## Test Plan

### Test Organization

**Test Files**:
- `tests/PreferredUnitTests.cs` — Value object tests
- `tests/KnownSignatureMapTests.cs` — Signature resolution tests

**Test Framework**: xUnit (consistent with existing test structure)  
**Test Categories**: Unit tests (no integration tests needed for pure lookup)

### Test Structure Template

```csharp
[Fact]
public void TryGetPreferredUnit_ForceSignature_ReturnsNewton()
{
    // Arrange
    var map = KnownSignatureMap.Instance;
    var forceSignature = DimensionSignature.ForceSignature;
    
    // Act
    var found = map.TryGetPreferredUnit(forceSignature, out var preferredUnit);
    
    // Assert
    Assert.True(found);
    Assert.Equal("N", preferredUnit.CanonicalName);
    Assert.Equal("Force", preferredUnit.Description);
}
```

### Test Coverage Matrix

| Category | Test Count | Focus Areas |
|----------|------------|-------------|
| PreferredUnit | 6 | Construction, equality, hash code, ToString |
| Known Signatures | 15 | Base dims, geometric, kinematic, dynamic |
| Unknown Signatures | 3 | Return false, out parameter, complex sigs |
| IsKnown Method | 4 | Known true, unknown false, edge cases |
| GetKnownSignatures | 2 | Count, enumeration |
| Alternative Names | 3 | Energy/Torque "Nm", Area "m^2" |
| Singleton Pattern | 2 | Instance not null, same instance |
| **Total** | **35** | **Comprehensive coverage** |

---

## Dependencies

### Upstream Dependencies (Required)
- **F-002**: `DimensionSignature` must be implemented and tested
  - Provides signature structure and factory methods
  - Provides equality and hashing for dictionary keys
- **F-004**: `DimensionalMath` context (understanding of signature usage)
  - While not a hard dependency, F-004 provides context for signature usage

### Downstream Consumers (Will Use This)
- **F-006**: Composite Unit Formatter
  - Will check known signatures before generating composite strings
  - Will use preferred names when available
- **F-007**: Operators Integration
  - Will format operation results using preferred unit names
- **F-008**: Format Extensions
  - May use signature map for format target validation

---

## Risks and Mitigations

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Missing important signatures | Medium | Medium | Start with ~20 most common; iterate based on user feedback |
| Signature collision (same signature, multiple names) | Low | Medium | Use alternative names for context-dependent naming; document primary choice |
| Performance with large map | Low | Low | Dictionary lookup is O(1); initial map is small (~20-30 entries) |
| Breaking changes if signatures change | Low | High | `DimensionSignature` is stable from F-002; changes would break multiple features |
| US Customary preference complexity | Medium | Low | Defer to future iteration; SI-first policy is sufficient for MVP |

---

## Integration Notes

### For F-006 (Composite Unit Formatter)

The map is designed to be consumed by the formatter layer:

```csharp
// Example integration pattern (to be implemented in F-006)
public string FormatResult(DimensionalResult result)
{
    // Try known signature first
    if (KnownSignatureMap.Instance.TryGetPreferredUnit(result.Signature, out var preferredUnit))
    {
        return $"{result.Value} {preferredUnit.CanonicalName}";
    }
    
    // Fallback to composite formatting
    return FormatComposite(result);
}
```

### For F-007 (Operators Integration)

Operators will use the map to provide friendly result unit names:

```csharp
// Example operator integration (to be implemented in F-007)
public static Quantity operator *(Quantity left, Quantity right)
{
    var result = engine.Multiply(...);
    
    // Get preferred unit name if known
    string unitName;
    if (KnownSignatureMap.Instance.TryGetPreferredUnit(result.Signature, out var preferred))
    {
        unitName = preferred.CanonicalName;
    }
    else
    {
        unitName = CompositeFormatter.Format(result.Signature);
    }
    
    return new Quantity(result.Value, unitName);
}
```

---

## Out of Scope

The following are explicitly NOT part of F-005:

❌ **US Customary Preferences**: Deferred to future iteration based on user demand  
❌ **User-Configurable Maps**: Map is fixed at compile time; runtime configuration deferred  
❌ **Composite Formatting Logic**: Handled by F-006 (Composite Formatter)  
❌ **Operator Wiring**: Handled by F-007 (Operators Integration)  
❌ **Format Method Integration**: Handled by F-008 (Format Extensions)  
❌ **Public API Exposure**: Map remains internal; public API unchanged  
❌ **Localization/Translation**: Unit names are English only; localization deferred

---

## Quality Checklist

### Domain Design Validation
- [ ] I have verified that the map properly models signature → name resolution
- [ ] I have confirmed consistent terminology (signature, preferred unit, canonical name)
- [ ] I have verified SOLID principles adherence (SRP, OCP)
- [ ] I have validated signature mappings against SI standards

### Implementation Quality Validation
- [ ] I have written comprehensive tests following `MethodName_Condition_ExpectedResult()` naming
- [ ] I have achieved >85% code coverage for map implementation
- [ ] I have considered performance and used appropriate data structures
- [ ] I have documented all APIs and design decisions

### Precision & Compliance Validation
- [ ] I have used exact signature matches (no approximation)
- [ ] I have validated unit names against SI/NIST standards
- [ ] I have ensured deterministic behavior
- [ ] I have documented SI-first policy

### Integration Readiness Validation
- [ ] I have designed interface suitable for F-006 and F-007 consumption
- [ ] I have verified no breaking changes to existing code
- [ ] I have confirmed all existing tests still pass
- [ ] I have provided clear integration examples

---

## Success Metrics

1. **Functionality**: All acceptance criteria met and validated
2. **Test Coverage**: >85% coverage for `KnownSignatureMap` and `PreferredUnit`
3. **Performance**: Lookups complete in <100ns (baseline measurement)
4. **Quality**: Zero regressions in existing test suite
5. **Readiness**: F-006 and F-007 teams confirm interface meets their needs

---

## Timeline

**Total Estimated Effort**: 1.5 - 2 days

- **Day 1 Morning**: Value objects and interface (Phase 1) - 2-3 hours
- **Day 1 Afternoon**: Map implementation (Phase 2) - 3-4 hours
- **Day 2 Morning**: Comprehensive testing (Phase 3) - 3-4 hours
- **Day 2 Afternoon**: Documentation and validation (Phase 4) - 1-2 hours

**Note**: Timeline assumes F-002 is complete and stable.

---

## References

### Internal References
- **E-001**: Epic — Option A Hybrid Core
- **F-001**: Core Rational Arithmetic (deferred per S-005)
- **F-002**: Dimension Signature Model (dependency)
- **F-004**: Dimensional Math Engine (context provider)
- **F-006**: Composite Unit Formatter (consumer)
- **F-007**: Operators Integration (consumer)

### External References
- **SI Units**: https://www.nist.gov/pml/owm/metric-si/si-units
- **SI Derived Units**: https://www.nist.gov/pml/owm/metric-si/si-derived-units
- **Dimensional Analysis (Wikipedia)**: https://en.wikipedia.org/wiki/Dimensional_analysis
- **Frink Units**: https://frinklang.org/frinkdata/units.txt (reference for unit naming)

---

## Open Questions

### Resolved Decisions

1. **Q**: Should we support multiple unit systems (SI vs US Customary)?  
   **A**: Initial implementation uses SI-first policy only. US Customary deferred to future iteration based on user demand.

2. **Q**: How to handle Energy vs Torque (same signature)?  
   **A**: Primary canonical name is "J" (joule) for energy; "Nm" included as alternative name. Context-dependent selection deferred to future enhancement.

3. **Q**: Should map be extensible at runtime?  
   **A**: No, map is fixed at compile time for initial implementation. Runtime extensibility deferred pending user need validation.

4. **Q**: What about non-SI units like "psi", "mph", "ft·lbf"?  
   **A**: Deferred to future iteration. Initial implementation focuses on SI units only.

### Open Questions for Review

1. **Q**: Should we provide a way to register custom signatures dynamically?  
   **Open**: Defer decision to user feedback. Static map is simpler and sufficient for MVP.

2. **Q**: How granular should alternative names be?  
   **Open**: Start minimal (only essential alternatives); expand based on actual usage patterns.

3. **Q**: Should we version the signature map?  
   **Open**: Not needed initially; revisit if breaking changes to signatures become necessary.

---

## Notes

- This is a foundational feature; correctness and simplicity prioritized over extensibility
- F-006 and F-007 will validate the interface design during implementation
- Map is internal API; breaking changes allowed before 1.0 if needed
- SI-first policy aligns with international standards and Tare's design philosophy
- Extensibility designed into architecture but deferred to actual user demand

---

## Revision History

| Version | Date | Author | Changes |
|---------|------|--------|---------|
| 1.0 | 2025-11-08 | Planning Team | Initial planning document created per user request |

---

**Ready for Review** ✅  
This planning document defines F-005 (Known-Signature Naming Map) implementation strategy, following the structure and standards established in F-002, F-003, and F-004 planning documents. The feature provides signature → name resolution for common dimensional compositions while maintaining extensibility for future enhancements.
