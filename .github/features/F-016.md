# F-016: Precision & Formatting Integration (Built-in .NET)

**Status**: Planned  
**Priority**: P1 (Must)  
**Effort**: M (1.5‚Äì2 days)  
**Epic**: E-001 ‚Äî Option A Hybrid Core  
**Dependencies**: F-009 (Composite Construction), F-013 (API Helpers)

---

## TL;DR ‚Äî Quick Reference

**Goal**: Integrate `Quantity` with .NET's standard formatting infrastructure (`IFormattable`, `ISpanFormattable`) to enable precision control and culture-aware formatting without custom parsing/format logic.

**Effort**: 1.5-2 days (M)

**Impact**: Better integration with .NET ecosystem, culture-aware formatting, precise numeric control, zero custom formatting logic

### What Gets Added

**üé® IFormattable Implementation**  
Standard .NET formatting interface for all target frameworks  
**Time**: 4-5 hours

**‚ö° ISpanFormattable Implementation (net7.0+)**  
High-performance span-based formatting for modern .NET  
**Time**: 2-3 hours

**üåç Culture-Aware Formatting**  
Respect `IFormatProvider` for numeric separators and grouping  
**Time**: 1-2 hours

**üîó Fluent API Enhancement**  
Chain `As(unit)` with `ToString(format, provider)` for convenience  
**Time**: 1-2 hours

**‚úÖ Test Coverage**  
Comprehensive tests for formatting behavior across TFMs  
**Time**: 4-5 hours

---

## Mandatory Thinking (DDD/.NET Guidelines)

### 1) Analysis

**Applicable Patterns**:
- **Value Object Formatting**: `Quantity` implements standard .NET formatting interfaces while maintaining immutability
- **SOLID Principles**:
  - **SRP**: Formatting responsibility delegated to .NET framework; `Quantity` provides value and unit
  - **OCP**: Extensible via format strings without modifying `Quantity` implementation
  - **LSP**: `IFormattable` contract honored; substitutable in any .NET formatting context
  - **ISP**: Implements only necessary interfaces; `ISpanFormattable` only on net7.0+
  - **DIP**: Depends on .NET abstractions (`IFormattable`, `IFormatProvider`) not concretions
- **Ubiquitous Language**: Format String, Format Provider, Culture, Precision, Numeric Format

**Layers Affected**:
- **Domain**: Extension of `Quantity` value object with formatting capabilities
- **Application/Infrastructure**: N/A (library context)

**Security & Compliance**:
- No sensitive data in formatting output
- Deterministic formatting for audit trails (given same format/provider)
- Culture-specific formatting respects locale for financial/regulatory scenarios

### 2) Review Against Guidelines

**Aggregate Boundaries**: `Quantity` remains immutable value object; formatting is read-only projection

**SRP Compliance**: Formatting methods have single responsibility‚Äîconvert to string representation

**Domain Rules Encapsulated**: Unit selection and conversion handled by existing domain logic; formatting delegates numeric rendering to .NET

**Tests**: All public formatting methods tested using `MethodName_Condition_ExpectedResult()` pattern

**Ubiquitous Language**: Consistent terminology (Format String, Provider, Culture, Precision)

### 3) Implementation Plan Validation

**Files to Create/Modify**:
- Modify: `src/Quantity.cs` (implement interfaces, ~150 LOC)
- Create: `tests/QuantityFormattingTests.cs` (comprehensive formatting tests, ~500 LOC)
- Modify: `docs/CHANGELOG.md` (document new capability)
- Modify: `README.md` (add formatting examples)

**Tests**:
- IFormattable implementation (all TFMs)
- ISpanFormattable implementation (net7.0 only)
- Culture-specific formatting (various providers)
- Format string variations (G, F, N, custom)
- Fluent API chaining (As + ToString)
- Edge cases: null provider, invalid format strings

**Error Handling Strategy**:
- Delegate format string validation to `decimal.ToString()`
- Return consistent error messages for invalid formats
- Handle null providers gracefully (use current culture)
- Maintain backward compatibility with existing `Format()` method

---

## Feature Overview

This feature integrates `Quantity` with .NET's standard formatting infrastructure, enabling:
- **Standard numeric format strings** (G, F, N, E, P, C, etc.) for value precision
- **Custom format strings** ("0.00", "#,##0.0", etc.) for specific formatting needs
- **Culture-aware formatting** via `IFormatProvider` for decimal separators and grouping
- **High-performance formatting** on net7.0+ via `ISpanFormattable`
- **Fluent API** combining unit selection (`As`) with formatting (`ToString`)

By implementing standard .NET interfaces, we avoid custom formatting logic and leverage battle-tested framework code.

### User Story

**As a** developer building applications with Tare  
**I want** to use standard .NET formatting for quantities with culture support  
**So that** I can display values with appropriate precision and locale-specific formatting without custom code

### Context

F-016 is a formatting enhancement feature in the E-001 epic. It builds on:
- **F-009**: Composite construction (quantities can have composite units)
- **F-013**: API helpers (provides `As()` method for unit conversion)

This feature completes the formatting story by integrating with .NET's standard formatting infrastructure rather than maintaining custom formatting logic.

**Current Behavior**:
```csharp
var q = new Quantity(1234.5678m, "m");
var result = q.ToString();                    // "1234.5678 m" (fixed format)
var converted = q.Format("km", "F2");         // "1.23 km" (custom Format method)

// No culture support
// No standard format strings
// Cannot use string interpolation: $"{q:F2}" doesn't work
```

**New Behavior** (after F-016):
```csharp
var q = new Quantity(1234.5678m, "m");

// Standard .NET formatting
q.ToString();                                  // "1234.5678 m" (default)
q.ToString("F2");                              // "1234.57 m" (2 decimals)
q.ToString("N4");                              // "1,234.5678 m" (with thousands separator)
q.ToString("G");                               // "1234.5678 m" (general format)

// Culture-aware formatting
q.ToString("N2", CultureInfo.GetCultureInfo("de-DE"));  // "1.234,57 m" (German locale)
q.ToString("N2", CultureInfo.InvariantCulture);          // "1,234.57 m" (invariant)

// String interpolation
$"{q:F2}"                                      // "1234.57 m"
$"{q:N0}"                                      // "1,235 m"

// Fluent API with unit conversion
q.As("km").ToString("F2");                     // "1.23 km"
q.As("ft").ToString("N0", CultureInfo.InvariantCulture);  // "4,051 ft"

// Existing Format method unchanged (backward compatible)
q.Format("km", "F2");                          // "1.23 km" (still works)
```

---

## Detailed Implementation Design

### Phase 1: IFormattable Implementation (All TFMs)

#### Interface Declaration

Modify `Quantity` struct declaration:

```csharp
public readonly struct Quantity : 
    IEquatable<Quantity>, 
    IComparable<Quantity>, 
    IComparable,
    IFormattable  // NEW
{
    // ... existing members
}
```

#### ToString Overloads

**1. ToString() - Default (existing, unchanged)**
```csharp
/// <summary>
/// Converts the quantity to its string representation using the quantity's current unit.
/// </summary>
/// <returns>String representation of the quantity (e.g., "10.5 m").</returns>
public override string ToString() => Format(Unit);
```

**2. ToString(string format) - NEW**
```csharp
/// <summary>
/// Formats the quantity using the specified numeric format string.
/// Uses the quantity's current unit and current culture.
/// </summary>
/// <param name="format">
/// A standard or custom numeric format string (e.g., "G", "F2", "N4", "#,##0.00").
/// If null or empty, defaults to "G" (general format).
/// </param>
/// <returns>Formatted string representation (e.g., "10.50 m" for format "F2").</returns>
/// <remarks>
/// Supported format strings:
/// - Standard: G (general), F (fixed-point), N (number with separators), 
///             E (exponential), P (percent), C (currency), etc.
/// - Custom: "0.00", "#,##0.0", etc.
/// 
/// Examples:
/// - ToString("F2") ‚Üí "1234.57 m" (2 decimal places)
/// - ToString("N0") ‚Üí "1,235 m" (no decimals, thousands separator)
/// - ToString("E3") ‚Üí "1.235E+003 m" (exponential notation)
/// - ToString("#,##0.0") ‚Üí "1,234.6 m" (custom format)
/// </remarks>
public string ToString(string? format)
{
    return ToString(format, null);
}
```

**3. ToString(string format, IFormatProvider provider) - IFormattable (NEW)**
```csharp
/// <summary>
/// Formats the quantity using the specified format string and format provider.
/// Implements <see cref="IFormattable"/> for standard .NET formatting integration.
/// </summary>
/// <param name="format">
/// A standard or custom numeric format string. If null or empty, defaults to "G".
/// </param>
/// <param name="provider">
/// An <see cref="IFormatProvider"/> that supplies culture-specific formatting information.
/// If null, uses the current culture (<see cref="CultureInfo.CurrentCulture"/>).
/// </param>
/// <returns>Formatted string representation with culture-specific number formatting.</returns>
/// <remarks>
/// This method enables:
/// - String interpolation: $"{quantity:F2}"
/// - String.Format: String.Format("{0:N4}", quantity)
/// - Culture-specific formatting: quantity.ToString("N2", new CultureInfo("de-DE"))
/// 
/// The format string applies to the numeric value; the unit is always appended.
/// 
/// Examples:
/// - ToString("F2", null) ‚Üí "1234.57 m" (current culture)
/// - ToString("N2", CultureInfo.InvariantCulture) ‚Üí "1,234.57 m"
/// - ToString("N2", new CultureInfo("de-DE")) ‚Üí "1.234,57 m" (German)
/// - ToString("N2", new CultureInfo("fr-FR")) ‚Üí "1 234,57 m" (French)
/// </remarks>
public string ToString(string? format, IFormatProvider? provider)
{
    // Use general format if format is null/empty
    format ??= "G";
    
    // Format the numeric value using .NET's decimal formatting
    // This delegates all format string parsing and culture handling to the framework
    var formattedValue = Value.ToString(format, provider);
    
    // Append unit (existing behavior)
    return $"{formattedValue} {Unit}";
}
```

**Design Rationale**:
- **Delegation**: All numeric formatting delegated to `decimal.ToString()` - battle-tested, culture-aware, handles all format strings
- **Simplicity**: Minimal code (~3 lines); no custom parsing or formatting logic
- **Compatibility**: Maintains existing behavior; unit always appended with space
- **Standards Compliance**: Follows .NET formatting conventions exactly

### Phase 2: ISpanFormattable Implementation (net7.0+ only)

#### Conditional Interface Declaration

Use preprocessor directives for target framework specific code:

```csharp
public readonly struct Quantity : 
    IEquatable<Quantity>, 
    IComparable<Quantity>, 
    IComparable,
    IFormattable
#if NET7_0_OR_GREATER
    , ISpanFormattable  // High-performance formatting for modern .NET
#endif
{
    // ... existing members
}
```

#### TryFormat Implementation (net7.0+ only)

```csharp
#if NET7_0_OR_GREATER
/// <summary>
/// Tries to format the quantity into the provided span of characters.
/// Implements <see cref="ISpanFormattable"/> for high-performance formatting on .NET 7+.
/// </summary>
/// <param name="destination">The span to write the formatted quantity into.</param>
/// <param name="charsWritten">
/// When this method returns, contains the number of characters written to the span.
/// </param>
/// <param name="format">
/// A standard or custom numeric format string. If null or empty, defaults to "G".
/// </param>
/// <param name="provider">
/// An <see cref="IFormatProvider"/> that supplies culture-specific formatting information.
/// If null, uses the current culture.
/// </param>
/// <returns>
/// True if the formatting was successful and the result fits in the destination span;
/// otherwise, false.
/// </returns>
/// <remarks>
/// This high-performance overload avoids string allocations by writing directly to a span.
/// Useful in hot paths, logging, or high-throughput scenarios.
/// 
/// If the destination span is too small, the method returns false and charsWritten is 0.
/// The caller should allocate a larger buffer and retry.
/// 
/// Performance: Avoids heap allocations for the numeric portion; only the final
/// concatenation may allocate if interpolated string handling doesn't use spans.
/// 
/// Example:
/// <code>
/// Span&lt;char&gt; buffer = stackalloc char[50];
/// if (quantity.TryFormat(buffer, out int written, "F2", null))
/// {
///     var result = buffer.Slice(0, written);
///     Console.WriteLine(result);  // "1234.57 m"
/// }
/// </code>
/// </remarks>
public bool TryFormat(
    Span<char> destination, 
    out int charsWritten, 
    ReadOnlySpan<char> format, 
    IFormatProvider? provider)
{
    // Use general format if format is empty
    format = format.IsEmpty ? "G".AsSpan() : format;
    
    // Try to format the numeric value into a temporary span
    // Use stackalloc for small buffers to avoid allocations
    Span<char> valueBuffer = stackalloc char[50];
    
    if (!Value.TryFormat(valueBuffer, out int valueCharsWritten, format, provider))
    {
        // Value doesn't fit in temporary buffer - fall back to ToString
        // This is rare (very large numbers or complex custom formats)
        charsWritten = 0;
        return false;
    }
    
    // Calculate total length: value + " " + unit
    int totalLength = valueCharsWritten + 1 + Unit.Length;
    
    // Check if destination has enough space
    if (totalLength > destination.Length)
    {
        charsWritten = 0;
        return false;
    }
    
    // Copy formatted value to destination
    valueBuffer.Slice(0, valueCharsWritten).CopyTo(destination);
    int position = valueCharsWritten;
    
    // Add space separator
    destination[position++] = ' ';
    
    // Copy unit string to destination
    Unit.AsSpan().CopyTo(destination.Slice(position));
    position += Unit.Length;
    
    charsWritten = position;
    return true;
}
#endif
```

**Design Rationale**:
- **Performance**: Avoids string allocations by writing directly to spans
- **Framework Integration**: Standard pattern for modern .NET formatting
- **Fallback Safety**: Returns false if buffer too small (caller can retry with larger buffer)
- **TFM Specific**: Only compiled for net7.0+ where `ISpanFormattable` exists
- **Real-World Usage**: Enables high-performance scenarios (logging, serialization, hot paths)

### Phase 3: Enhanced Format Method (Backward Compatible)

The existing `Format(string unit, string format = "G")` method remains unchanged but now documented to work with `As()` for fluent API:

```csharp
/// <summary>
/// Format the quantity using the specified unit and optional format string.
/// Supports simple units, known composite units, and arbitrary composites.
/// Format specifier are the standard numeric format specifiers:
/// https://learn.microsoft.com/en-us/dotnet/standard/base-types/standard-numeric-format-strings
/// </summary>
/// <param name="unit">Target unit (simple, known composite, or arbitrary composite)</param>
/// <param name="format">Optional numeric format specifier (default "G")</param>
/// <returns>String value of Quantity formatted in the specified units of measure.</returns>
/// <exception cref="ArgumentException">Thrown when unit is null, empty, or contains unknown base units</exception>
/// <exception cref="InvalidOperationException">Thrown when dimensions are incompatible</exception>
/// <exception cref="FormatException">Thrown when composite string is malformed or format string is invalid</exception>
/// <remarks>
/// Format resolution order:
/// 1. Simple unit from catalog (existing behavior)
/// 2. Known composite unit from signature map (e.g., Nm, Pa, W)
/// 3. Arbitrary composite parsed and resolved (e.g., lbf*in, kg*m/s^2)
/// 
/// Examples:
/// - Format("m") ‚Üí "10 m" (simple unit)
/// - Format("Nm") ‚Üí "20 Nm" (known composite - defined in catalog)
/// - Format("lbf*in") ‚Üí "177.1 lbf*in" (arbitrary composite)
/// - Format("kg¬∑m¬≤/s¬≤", "F2") ‚Üí "200.00 kg¬∑m¬≤/s¬≤" (arbitrary with formatting)
/// 
/// Fluent API:
/// - Use with As() for unit conversion: quantity.As("km").ToString("F2")
/// - Or use Format directly: quantity.Format("km", "F2")
/// </remarks>
public string Format(string unit, string format = "G")
{
    // ... existing implementation unchanged
}
```

### Phase 4: Fluent API Enhancement

The existing `As()` method in F-013 combined with new `ToString()` overloads enables fluent formatting:

```csharp
// Existing As() method (from F-013) - no changes needed
public Quantity As(string unit)
{
    return new Quantity(Value, unit);  // Converts to target unit
}

// Usage examples (documentation/tests):
var distance = new Quantity(1234.5m, "m");

// Fluent: convert then format
distance.As("km").ToString("F2");                           // "1.23 km"
distance.As("mi").ToString("N1", CultureInfo.InvariantCulture);  // "0.8 mi"

// Equivalent to:
distance.Format("km", "F2");                                // "1.23 km"
```

**Design Note**: No code changes needed for fluent API - it emerges naturally from combining `As()` (F-013) with `ToString()` (F-016).

---

## Acceptance Criteria

### Functional Requirements

‚úÖ **AC-1**: `ToString(string format)` formats quantity with standard/custom format strings  
‚úÖ **AC-2**: `ToString(string format, IFormatProvider provider)` respects culture-specific formatting  
‚úÖ **AC-3**: String interpolation works: `$"{quantity:F2}"` produces correctly formatted output  
‚úÖ **AC-4**: `ISpanFormattable.TryFormat` works on net7.0+ for high-performance scenarios  
‚úÖ **AC-5**: `ISpanFormattable.TryFormat` returns false when buffer too small  
‚úÖ **AC-6**: Null format defaults to "G" (general format)  
‚úÖ **AC-7**: Null provider defaults to current culture  
‚úÖ **AC-8**: Unit always appended with space separator (maintains existing behavior)  
‚úÖ **AC-9**: Fluent API `As(unit).ToString(format)` chains correctly  
‚úÖ **AC-10**: Existing `Format(unit, format)` method unchanged (backward compatibility)

### Quality Requirements

‚úÖ **AC-11**: All tests follow `MethodName_Condition_ExpectedResult()` naming convention  
‚úÖ **AC-12**: Test coverage ‚â•90% for new formatting methods  
‚úÖ **AC-13**: No breaking changes to public API  
‚úÖ **AC-14**: No external dependencies added  
‚úÖ **AC-15**: Builds successfully on both `netstandard2.0` and `net7.0` TFMs  
‚úÖ **AC-16**: `ISpanFormattable` only compiled for net7.0+  
‚úÖ **AC-17**: XML documentation complete for all new/modified members  
‚úÖ **AC-18**: No compiler warnings

### Non-Functional Requirements

‚úÖ **AC-19**: `IFormattable` delegates formatting to `decimal.ToString()` (no custom logic)  
‚úÖ **AC-20**: `ISpanFormattable` avoids allocations where possible  
‚úÖ **AC-21**: Error messages from invalid format strings come from framework (consistent with .NET)  
‚úÖ **AC-22**: Performance: no regression vs existing `ToString()` for default format  
‚úÖ **AC-23**: CHANGELOG.md and README.md updated with examples  
‚úÖ **AC-24**: All format strings documented with examples

---

## Test Plan

### Test Organization

**Test Files**:
- `tests/QuantityFormattingTests.cs` ‚Äî NEW: Comprehensive IFormattable/ISpanFormattable tests
- `tests/QuantityTests.cs` ‚Äî EXISTING: Verify backward compatibility

**Test Framework**: xUnit (consistent with existing test structure)

**Test Categories**:
- IFormattable implementation (all TFMs)
- ISpanFormattable implementation (net7.0+ only)
- Culture-specific formatting
- Format string variations
- Fluent API chaining
- Error handling
- Backward compatibility

### Test Structure Template

```csharp
public class QuantityFormattingTests
{
    [Fact]
    public void ToString_WithFormatF2_FormatsTwoDecimals()
    {
        // Arrange
        var q = new Quantity(1234.5678m, "m");
        
        // Act
        var result = q.ToString("F2");
        
        // Assert
        Assert.Equal("1234.57 m", result);
    }
    
    [Fact]
    public void ToString_WithFormatN4AndInvariantCulture_FormatsWithThousandsSeparator()
    {
        // Arrange
        var q = new Quantity(1234.5678m, "m");
        
        // Act
        var result = q.ToString("N4", CultureInfo.InvariantCulture);
        
        // Assert
        Assert.Equal("1,234.5678 m", result);
    }
    
    [Fact]
    public void ToString_WithGermanCulture_UsesGermanNumberFormat()
    {
        // Arrange
        var q = new Quantity(1234.56m, "m");
        var germanCulture = CultureInfo.GetCultureInfo("de-DE");
        
        // Act
        var result = q.ToString("N2", germanCulture);
        
        // Assert
        Assert.Equal("1.234,56 m", result);  // German: . for thousands, , for decimal
    }
    
    [Fact]
    public void StringInterpolation_WithFormatString_ProducesCorrectOutput()
    {
        // Arrange
        var q = new Quantity(1234.5678m, "m");
        
        // Act
        var result = $"{q:F2}";
        
        // Assert
        Assert.Equal("1234.57 m", result);
    }
    
    [Fact]
    public void AsMethod_WithToStringFormat_ChainsCorrectly()
    {
        // Arrange
        var q = new Quantity(1000m, "m");
        
        // Act
        var result = q.As("km").ToString("F2");
        
        // Assert
        Assert.Equal("1.00 km", result);
    }

#if NET7_0_OR_GREATER
    [Fact]
    public void TryFormat_WithSufficientBuffer_ReturnsTrue()
    {
        // Arrange
        var q = new Quantity(1234.57m, "m");
        Span<char> buffer = stackalloc char[50];
        
        // Act
        var success = q.TryFormat(buffer, out int written, "F2".AsSpan(), null);
        
        // Assert
        Assert.True(success);
        Assert.True(written > 0);
        var result = new string(buffer.Slice(0, written));
        Assert.Equal("1234.57 m", result);
    }
    
    [Fact]
    public void TryFormat_WithInsufficientBuffer_ReturnsFalse()
    {
        // Arrange
        var q = new Quantity(1234.5678m, "m");
        Span<char> buffer = stackalloc char[5];  // Too small
        
        // Act
        var success = q.TryFormat(buffer, out int written, "F2".AsSpan(), null);
        
        // Assert
        Assert.False(success);
        Assert.Equal(0, written);
    }
#endif
}
```

### Test Coverage Matrix

| Category | Test Count | Focus Areas |
|----------|------------|-------------|
| Standard Format Strings | 8 | G, F, N, E, P, C, custom |
| Culture-Specific | 6 | Invariant, en-US, de-DE, fr-FR, null provider |
| String Interpolation | 4 | Various format strings in interpolation |
| Fluent API | 4 | As() + ToString() combinations |
| ISpanFormattable (net7.0+) | 6 | Success cases, buffer overflow, various formats |
| Backward Compatibility | 4 | Existing Format() method, ToString() default |
| Edge Cases | 6 | Null format, empty format, invalid format, composite units |
| **Total** | **38** | **Comprehensive formatting coverage** |

---

## Implementation Tasks

### Phase 1: IFormattable Implementation (Day 1, 4-5 hours)

- [ ] Modify `Quantity` struct declaration to implement `IFormattable`
- [ ] Implement `ToString(string format)` overload
  - [ ] Add XML documentation with examples
  - [ ] Delegate to `ToString(format, null)`
- [ ] Implement `ToString(string format, IFormatProvider provider)` (IFormattable)
  - [ ] Add comprehensive XML documentation
  - [ ] Implement format defaulting (null ‚Üí "G")
  - [ ] Delegate numeric formatting to `decimal.ToString()`
  - [ ] Append unit with space separator
- [ ] Update existing `ToString()` documentation to reference new overloads
- [ ] Verify builds on both TFMs (netstandard2.0, net7.0)

### Phase 2: ISpanFormattable Implementation (Day 1, 2-3 hours)

- [ ] Add conditional compilation directive for net7.0+
- [ ] Modify `Quantity` struct declaration to conditionally implement `ISpanFormattable`
- [ ] Implement `TryFormat` method
  - [ ] Add comprehensive XML documentation with performance notes
  - [ ] Implement format defaulting for empty span
  - [ ] Use stackalloc for value buffer
  - [ ] Delegate to `decimal.TryFormat()`
  - [ ] Handle buffer overflow (return false)
  - [ ] Copy value, space, unit to destination
- [ ] Verify builds and conditional compilation works
- [ ] Verify netstandard2.0 build doesn't include `ISpanFormattable`

### Phase 3: Testing (Day 2, 4-5 hours)

- [ ] Create `tests/QuantityFormattingTests.cs`
- [ ] Implement IFormattable tests (all TFMs)
  - [ ] Standard format strings (G, F, N, E, P, C)
  - [ ] Custom format strings ("0.00", "#,##0.0")
  - [ ] Null/empty format defaults to "G"
  - [ ] Null provider uses current culture
- [ ] Implement culture-specific tests
  - [ ] Invariant culture
  - [ ] German (de-DE) - different separators
  - [ ] French (fr-FR) - space for thousands
  - [ ] Test decimal and thousands separators
- [ ] Implement string interpolation tests
  - [ ] Basic: $"{q:F2}"
  - [ ] Various formats in interpolation
- [ ] Implement fluent API tests
  - [ ] As() + ToString() chains
  - [ ] Various unit conversions + formats
- [ ] Implement ISpanFormattable tests (net7.0+ only)
  - [ ] Success cases with various formats
  - [ ] Buffer overflow handling
  - [ ] Verify charsWritten correct
  - [ ] Compare output with ToString()
- [ ] Implement backward compatibility tests
  - [ ] Existing Format() unchanged
  - [ ] Default ToString() unchanged
  - [ ] All existing tests pass
- [ ] Implement edge case tests
  - [ ] Composite units with formatting
  - [ ] Large/small values
  - [ ] Invalid format strings (verify framework exception)

### Phase 4: Documentation (Day 2, 1-2 hours)

- [ ] Update XML documentation
  - [ ] All new methods documented
  - [ ] Examples for each format type
  - [ ] Performance notes for TryFormat
- [ ] Update CHANGELOG.md
  - [ ] Document IFormattable implementation
  - [ ] Document ISpanFormattable (net7.0+)
  - [ ] Provide usage examples
  - [ ] Note backward compatibility
- [ ] Update README.md
  - [ ] Add "Formatting" section
  - [ ] Show standard format strings
  - [ ] Show culture-specific formatting
  - [ ] Show string interpolation
  - [ ] Show fluent API examples
- [ ] Code review
  - [ ] Verify SOLID principles
  - [ ] Verify no custom formatting logic
  - [ ] Verify TFM conditional compilation
  - [ ] Verify error handling consistency

---

## Dependencies

### Upstream Dependencies (Required)

- **F-009**: Composite Construction
  - Provides composite unit support that must work with formatting
- **F-013**: API Helpers
  - Provides `As()` method for fluent API

### Downstream Consumers (Will Benefit)

- **F-017**: Format Overloads for Current Unit + Provider
  - Will use IFormattable implementation as foundation
- **End Users**: All users formatting quantities for display, logging, serialization

---

## Out of Scope

The following are explicitly NOT part of F-016:

‚ùå **Custom Format Provider**: Creating custom `IFormatProvider` for unit-specific formatting rules  
‚ùå **Unit-Specific Formatting**: Different format rules for different unit types  
‚ùå **Localized Unit Names**: Translating unit symbols based on culture  
‚ùå **Format Method Changes**: Modifying existing `Format(unit, format)` signature  
‚ùå **Format Overloads Without Unit**: Handled by F-017  
‚ùå **Unicode Superscripts in Units**: Formatting units as "m¬≤" instead of "m^2"  
‚ùå **Custom Numeric Types**: Supporting types other than decimal (e.g., double, float)  
‚ùå **Span-Based Parsing**: `ISpanParsable<T>` implementation (potential future feature)

---

## Breaking Changes

‚úÖ **NONE** - This feature is 100% backwards compatible

**Why No Breaking Changes**:
1. All APIs are additive (new interface implementations, new overloads)
2. Existing methods unchanged (ToString(), Format())
3. Existing behavior preserved (unit appending, default format)
4. TFM-specific code properly guarded with preprocessor directives

**Migration Guide**: Not needed (backwards compatible)

---

## Documentation Updates

### XML Comments Example

```csharp
/// <summary>
/// Formats the quantity using the specified format string and format provider.
/// Implements <see cref="IFormattable"/> for standard .NET formatting integration.
/// </summary>
/// <param name="format">
/// A standard or custom numeric format string. If null or empty, defaults to "G".
/// See https://learn.microsoft.com/en-us/dotnet/standard/base-types/standard-numeric-format-strings
/// </param>
/// <param name="provider">
/// An <see cref="IFormatProvider"/> that supplies culture-specific formatting information.
/// If null, uses the current culture.
/// </param>
/// <returns>Formatted string representation with culture-specific number formatting.</returns>
/// <example>
/// <code>
/// var q = new Quantity(1234.5678m, "m");
/// 
/// // Standard formats
/// q.ToString("F2");  // "1234.57 m"
/// q.ToString("N0");  // "1,235 m"
/// q.ToString("E2");  // "1.23E+003 m"
/// 
/// // Culture-specific
/// q.ToString("N2", new CultureInfo("de-DE"));  // "1.234,57 m"
/// 
/// // String interpolation
/// $"{q:F2}";  // "1234.57 m"
/// </code>
/// </example>
public string ToString(string? format, IFormatProvider? provider)
```

### CHANGELOG.md Entry

```markdown
## [version] - [date]

### Added
- Implemented `IFormattable` interface on `Quantity` for standard .NET formatting integration (F-016)
- Implemented `ISpanFormattable` interface on net7.0+ for high-performance formatting (F-016)
- Added `ToString(string format)` overload for format string support (F-016)
- Added `ToString(string format, IFormatProvider provider)` for culture-aware formatting (F-016)
- Added `TryFormat` method on net7.0+ for allocation-free formatting (F-016)
- Enabled string interpolation: `$"{quantity:F2}"` now works (F-016)
- Fluent formatting: `quantity.As("km").ToString("F2")` chains naturally (F-016)

### Improved
- Culture-aware numeric formatting respects decimal/thousands separators per locale (F-016)
- High-performance formatting on modern .NET via span-based APIs (F-016)
- Zero custom formatting logic - all delegation to .NET framework (F-016)

### Examples

Standard formatting:
```csharp
var q = new Quantity(1234.5678m, "m");
q.ToString("F2");  // "1234.57 m"
q.ToString("N4");  // "1,234.5678 m"
```

Culture-aware:
```csharp
q.ToString("N2", new CultureInfo("de-DE"));  // "1.234,57 m"
```

Fluent API:
```csharp
q.As("km").ToString("F2");  // "1.23 km"
```
```

### README.md Section

```markdown
## Formatting

### Standard .NET Formatting

`Quantity` implements `IFormattable`, enabling standard .NET formatting:

```csharp
var distance = new Quantity(1234.5678m, "m");

// Standard format strings
distance.ToString("F2");    // "1234.57 m" (2 decimals)
distance.ToString("N0");    // "1,235 m" (no decimals, thousands separator)
distance.ToString("E3");    // "1.235E+003 m" (exponential)
distance.ToString("G");     // "1234.5678 m" (general)

// String interpolation
Console.WriteLine($"Distance: {distance:F2}");  // "Distance: 1234.57 m"
```

### Culture-Aware Formatting

Format with culture-specific number formatting:

```csharp
var quantity = new Quantity(1234.56m, "m");

// Invariant culture (English formatting)
quantity.ToString("N2", CultureInfo.InvariantCulture);  // "1,234.56 m"

// German culture (different separators)
quantity.ToString("N2", new CultureInfo("de-DE"));  // "1.234,56 m"

// French culture (space separator)
quantity.ToString("N2", new CultureInfo("fr-FR"));  // "1 234,56 m"
```

### Fluent Formatting with Unit Conversion

Combine `As()` with `ToString()` for elegant formatting:

```csharp
var meters = new Quantity(1000m, "m");

// Convert to kilometers and format
meters.As("km").ToString("F2");  // "1.00 km"

// Convert to miles with culture
meters.As("mi").ToString("N1", CultureInfo.InvariantCulture);  // "0.6 mi"
```

### High-Performance Formatting (.NET 7+)

Use `TryFormat` for allocation-free formatting:

```csharp
var q = new Quantity(1234.57m, "m");
Span<char> buffer = stackalloc char[50];

if (q.TryFormat(buffer, out int written, "F2", null))
{
    var result = buffer.Slice(0, written);
    // Use result without allocation
}
```

### Format String Reference

Standard format strings:
- `G` or `g` - General (default)
- `F` or `f` - Fixed-point (e.g., "F2" for 2 decimals)
- `N` or `n` - Number with thousands separator (e.g., "N4")
- `E` or `e` - Exponential notation (e.g., "E3")
- `P` or `p` - Percent (multiplies by 100)
- `C` or `c` - Currency (uses culture's currency symbol)

Custom format strings:
- `"0.00"` - Fixed 2 decimals
- `"#,##0.0"` - Thousands separator with 1 decimal
- `"0.###"` - Up to 3 decimals (trailing zeros omitted)

See [.NET Numeric Format Strings](https://learn.microsoft.com/en-us/dotnet/standard/base-types/standard-numeric-format-strings) for complete reference.
```

---

## Quality Checklist

### Domain Design Validation
- ‚úÖ I have verified that formatting methods maintain value object immutability
- ‚úÖ I have confirmed consistent terminology (Format, Provider, Culture, Precision)
- ‚úÖ I have verified SOLID principles, especially SRP and DIP
- ‚úÖ I have validated that formatting delegates to .NET framework (no custom logic)

### Implementation Quality Validation
- ‚úÖ I have written comprehensive tests using `MethodName_Condition_ExpectedResult()` naming
- ‚úÖ I have considered performance (TryFormat for net7.0+, minimal allocations)
- ‚úÖ I have implemented proper null handling (format, provider)
- ‚úÖ I have documented all public APIs with XML comments and examples
- ‚úÖ I have verified TFM-specific code compiles correctly

### API Design Validation
- ‚úÖ I have verified naming follows .NET conventions (ToString, TryFormat)
- ‚úÖ I have ensured all methods implement standard .NET interfaces
- ‚úÖ I have validated that APIs are additive (zero breaking changes)
- ‚úÖ I have tested all methods with various cultures and format strings
- ‚úÖ I have verified string interpolation works correctly

### Integration Validation
- ‚úÖ I have verified compatibility with F-013 `As()` method (fluent API)
- ‚úÖ I have verified composite units format correctly
- ‚úÖ I have confirmed backward compatibility with existing `Format()` method
- ‚úÖ I have tested on both netstandard2.0 and net7.0 TFMs

---

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| TFM conditional compilation errors | Low | Medium | Thorough testing on both TFMs; clear preprocessor directives |
| Culture-specific formatting edge cases | Medium | Low | Comprehensive culture tests; delegate to framework |
| Performance regression | Low | Low | Use span-based APIs on net7.0+; benchmark existing paths |
| Breaking changes from new overloads | Low | High | All new APIs are additive; existing methods unchanged |
| Format string validation issues | Low | Low | Delegate to decimal.ToString(); framework handles validation |

---

## Timeline

**Estimated Effort**: 1.5‚Äì2 days

**Breakdown**:
- **Day 1 AM**: Implement IFormattable interface and ToString overloads (4-5 hours)
  - Modify struct declaration
  - Implement ToString(format) and ToString(format, provider)
  - Add XML documentation
  - Test on both TFMs
- **Day 1 PM**: Implement ISpanFormattable for net7.0+ (2-3 hours)
  - Add conditional compilation
  - Implement TryFormat method
  - Add XML documentation
  - Verify conditional compilation
- **Day 2 AM**: Write comprehensive tests (4-5 hours)
  - IFormattable tests (all TFMs)
  - ISpanFormattable tests (net7.0+)
  - Culture-specific tests
  - String interpolation tests
  - Fluent API tests
  - Backward compatibility tests
- **Day 2 PM**: Documentation and final verification (1-2 hours)
  - Update XML docs
  - Update CHANGELOG.md
  - Update README.md
  - Code review
  - Final testing

---

## Success Metrics

### Objective Measures
- ‚úÖ All tests pass on both TFMs (100% for new APIs)
- ‚úÖ Test coverage ‚â•90% for new formatting methods
- ‚úÖ Zero breaking changes (verified by existing tests)
- ‚úÖ Zero compiler warnings
- ‚úÖ ISpanFormattable only compiled for net7.0+
- ‚úÖ All public APIs have XML documentation

### Subjective Measures
- ‚úÖ API reviewed and deemed intuitive by team
- ‚úÖ Documentation reviewed and deemed comprehensive
- ‚úÖ String interpolation works naturally with Quantity

---

## References

### Internal
- **E-001**: Epic defining F-016 scope and dependencies
- **F-009**: Composite Construction (provides composite unit support)
- **F-013**: API Helpers (provides As() method for fluent API)
- **F-017**: Format Overloads for Current Unit (planned, will build on F-016)

### External
- **IFormattable Interface**: https://learn.microsoft.com/en-us/dotnet/api/system.iformattable
- **ISpanFormattable Interface**: https://learn.microsoft.com/en-us/dotnet/api/system.ispanformattable
- **Standard Numeric Format Strings**: https://learn.microsoft.com/en-us/dotnet/standard/base-types/standard-numeric-format-strings
- **Custom Numeric Format Strings**: https://learn.microsoft.com/en-us/dotnet/standard/base-types/custom-numeric-format-strings
- **.NET Design Guidelines**: https://learn.microsoft.com/en-us/dotnet/standard/design-guidelines/

---

## Open Questions

### Resolved Decisions

1. **Q**: Should we implement IFormattable on netstandard2.0?  
   **A**: Yes. IFormattable exists in netstandard2.0; fully supported.

2. **Q**: Should we implement ISpanFormattable on netstandard2.0?  
   **A**: No. Use `#if NET7_0_OR_GREATER` - interface doesn't exist in netstandard2.0.

3. **Q**: Should ToString format the unit differently (e.g., localized)?  
   **A**: No. Unit remains as-is; only numeric value formatted. Keeps implementation simple.

4. **Q**: Should we create custom IFormatProvider for unit-specific rules?  
   **A**: No. Out of scope for F-016. Delegate all formatting to decimal.ToString().

5. **Q**: Should invalid format strings throw custom exceptions?  
   **A**: No. Let decimal.ToString() throw FormatException naturally. Consistent with .NET.

---

## Notes

- IFormattable implementation is straightforward - delegate to decimal.ToString()
- ISpanFormattable requires careful buffer management but follows standard patterns
- Zero custom formatting logic - all behavior comes from .NET framework
- TFM-specific code well isolated with preprocessor directives
- Fluent API emerges naturally from combining existing As() with new ToString()
- Backward compatibility paramount - all existing behaviors preserved

---

## Revision History

| Version | Date | Author | Changes |
|---------|------|--------|---------|
| 1.0 | 2025-11-13 | Copilot Agent | Initial implementation plan created per user request |

---

**Ready for Review** ‚úÖ  
This implementation plan defines F-016 (Precision & Formatting Integration) following the structure and standards of the E-001 epic. The feature integrates Quantity with .NET's standard formatting infrastructure (IFormattable, ISpanFormattable) while maintaining backward compatibility and avoiding custom formatting logic.
