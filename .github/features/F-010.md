# F-010: Composite Unit Operator Support

**Status**: Planned  
**Priority**: P1 (Must Have)  
**Effort**: M (3-5 days)  
**Epic**: E-001 — Option A Hybrid Core  
**Dependencies**: F-009 (Composite Unit Construction)

---

## Feature Overview

This feature extends dimensional arithmetic operators to fully support composite units created through F-009. Currently, quantities constructed with composite units (e.g., "m*s") cannot participate in multiplication and division operations because these operators rely on `UnitResolver.Resolve()` which only works with catalog units.

### User Story

**As a** Tare library user performing engineering calculations with composite units  
**I want** to perform multiplication and division operations on quantities with composite units  
**So that** I can use dimensional algebra with any valid composite unit, not just those in the catalog

### Context

F-009 enabled construction of quantities using composite unit strings, but revealed a limitation: the dimensional arithmetic operators (`*` and `/`) fail when operands contain composite units not in the catalog. For example:

```csharp
var q1 = Quantity.Parse("2 m*s");      // ✓ Construction works (F-009)
var q2 = Quantity.Parse("0.5 s");      // ✓ Standard catalog unit
var result = q1 / q2;                   // ✗ Throws: "No matching unit m*s was found"
```

This occurs because the operators use `UnitResolver.Resolve()` which calls `UnitDefinitions.Parse()`, expecting all units to be in the catalog. Composite units need special handling to decompose them into their base units and signatures before dimensional algebra can be performed.

---

## Problem Statement

### Current Behavior (F-009 Limitation)

After F-009, quantities with composite units can be:
- ✓ Constructed: `Quantity.Parse("2 m*s")`
- ✓ Stored and displayed
- ✓ Formatted to other units: `q.Format("ft*s")`
- ✓ Added/subtracted with same-dimension quantities
- ✗ **Cannot** be used in multiplication: `compositeQ * otherQ`
- ✗ **Cannot** be used in division: `compositeQ / otherQ`

### Desired Behavior (After F-010)

```csharp
// Example 1: Division with composite numerator
var q1 = Quantity.Parse("2 m*s");      // Unknown signature composite
var q2 = Quantity.Parse("0.5 s");      // Catalog unit
var result = q1 / q2;                   // ✓ Should return Quantity(4, "m")

// Example 2: Multiplication with composites
var velocity = Quantity.Parse("10 m/s");   // Known signature composite
var time = Quantity.Parse("5 s");          // Catalog unit
var distance = velocity * time;             // ✓ Should return Quantity(50, "m")

// Example 3: Division of two composites
var torque = Quantity.Parse("100 Nm");     // Known signature composite (in catalog)
var force = Quantity.Parse("20 N");        // Catalog unit
var distance = torque / force;              // ✓ Should return Quantity(5, "m")

// Example 4: Complex composite operations
var q1 = Quantity.Parse("10 kg*m/s^2");   // Force composite
var q2 = Quantity.Parse("2 m");            // Catalog unit
var torque = q1 * q2;                       // ✓ Should return Quantity(20, "Nm") or "kg*m^2/s^2"
```

---

## Technical Design

### Root Cause Analysis

The multiplication and division operators (lines 505-638 in `Quantity.cs`) use this logic:

1. Fast paths for scalars and same-unit-type operations (unchanged)
2. Dimensional algebra path: calls `UnitResolver.Resolve(q.Unit)` for each operand
3. `UnitResolver.Resolve()` → `Normalize()` → `UnitDefinitions.Parse()`
4. `UnitDefinitions.Parse()` throws if the unit isn't in the catalog

**The Issue**: When a quantity has a composite unit string (e.g., "m*s"), `UnitDefinitions.Parse()` fails because it's not a catalog entry.

### Proposed Solution

Enhance the dimensional algebra path in operators to detect and handle composite units:

1. **Check if unit is composite** before calling `UnitResolver.Resolve()`
2. **If composite**: Use `CompositeParser` to decompose into signature + factor
3. **If catalog**: Use existing `UnitResolver` path (fast and correct)
4. **Proceed with dimensional algebra** using the resolved signature + factor

### Implementation Approach

#### Option A: Enhance UnitResolver (Recommended)

Extend `UnitResolver.Resolve()` to handle composite units internally:

```csharp
public NormalizedUnit Resolve(string unit)
{
    // Try catalog first (fast path)
    if (IsValidUnit(unit))
    {
        var token = Normalize(unit);
        var definition = _tokenToDefinition[token];
        var baseToken = GetBaseUnit(definition.UnitType);
        var factorToBase = ComputeFactorToBase(token, baseToken, definition);
        var signature = GetSignatureForUnitType(definition.UnitType);
        
        return new NormalizedUnit(token, factorToBase, definition.UnitType, signature);
    }
    
    // Try composite parsing (new path)
    var parser = CompositeParser.Instance;
    if (parser.TryParse(unit, out var signature, out var factor))
    {
        // Create a synthetic token for the composite
        var token = new UnitToken(unit);
        
        // Determine UnitType from signature
        var knownMap = KnownSignatureMap.Instance;
        var unitType = knownMap.TryGetPreferredUnit(signature, out var preferred)
            ? MapDescriptionToUnitType(preferred.Description)
            : UnitTypeEnum.Unknown;
        
        return new NormalizedUnit(token, factor, unitType, signature);
    }
    
    // Neither catalog nor valid composite
    throw new ArgumentException($"Unknown or malformed unit: '{unit}'");
}
```

**Pros**:
- Centralized logic - all resolution in one place
- Operators unchanged (minimal code changes)
- Consistent behavior across all uses of `UnitResolver`

**Cons**:
- Modifies internal infrastructure (requires careful testing)
- Slightly more complex `UnitResolver` logic

#### Option B: Operator-Level Handling

Modify each operator to check for composites before calling `UnitResolver`:

```csharp
public static Quantity operator /(Quantity q1, Quantity q2)
{
    // ... existing fast paths ...
    
    // Dimensional algebra path
    NormalizedUnit left, right;
    
    // Resolve q1.Unit (handle composite)
    if (UnitDefinitions.IsValidUnit(q1.Unit))
    {
        left = UnitResolver.Instance.Resolve(q1.Unit);
    }
    else
    {
        left = ResolveComposite(q1.Unit); // New helper method
    }
    
    // Resolve q2.Unit (handle composite)
    if (UnitDefinitions.IsValidUnit(q2.Unit))
    {
        right = UnitResolver.Instance.Resolve(q2.Unit);
    }
    else
    {
        right = ResolveComposite(q2.Unit); // New helper method
    }
    
    // ... rest of dimensional algebra ...
}
```

**Pros**:
- Keeps `UnitResolver` unchanged
- Explicit handling in operators

**Cons**:
- Code duplication in `*` and `/` operators
- More places to maintain consistency

### Recommended Approach

**Option A (Enhance UnitResolver)** is recommended because:
- Single source of truth for unit resolution
- Minimal changes to operator code
- Future-proof: any code using `UnitResolver` automatically supports composites
- Better separation of concerns

---

## Implementation Plan

### Phase 1: UnitResolver Enhancement (2 days)

1. **Modify `UnitResolver.Resolve()`**:
   - Add composite unit detection after catalog lookup fails
   - Use `CompositeParser.TryParse()` to decompose composite
   - Create `NormalizedUnit` from composite signature + factor
   - Determine UnitType from signature (reuse `MapDescriptionToUnitType` from F-009)

2. **Add helper method** (if needed):
   - `MapDescriptionToUnitType(string description)` - might already exist from F-009

3. **Error handling**:
   - Clear exceptions for truly invalid units (neither catalog nor valid composite)
   - Maintain backward compatibility with existing error messages

### Phase 2: Testing (2 days)

1. **Unit tests for UnitResolver**:
   - `Resolve_CatalogUnit_ReturnsCorrectNormalized()` - verify no regression
   - `Resolve_CompositeUnit_ReturnsCorrectSignatureAndFactor()`
   - `Resolve_KnownComposite_ReturnsCorrectUnitType()`
   - `Resolve_UnknownComposite_ReturnsUnknownUnitType()`
   - `Resolve_InvalidUnit_ThrowsArgumentException()`

2. **Operator tests with composites**:
   - `Multiply_CompositeByScalar_PreservesComposite()`
   - `Divide_CompositeByTime_ReturnsCorrectDimension()`
   - `Divide_CompositeBySameComposite_ReturnsScalar()`
   - `Multiply_TwoComposites_ReturnsCorrectSignature()`

3. **Integration tests**:
   - End-to-end scenarios from user stories
   - Round-trip: construct composite → operate → format
   - Edge cases: complex composites, unknown signatures

### Phase 3: Documentation (1 day)

1. Update E-001 epic status
2. Update CHANGELOG.md
3. Add examples to README
4. Update F-009 documentation to remove "Known Limitations" section

---

## Test Plan

### Test Coverage Matrix

| Category | Test Count | Focus Areas |
|----------|------------|-------------|
| UnitResolver - Catalog Units | 4 | Backward compatibility, no regression |
| UnitResolver - Composite Units | 6 | Known composites, unknown composites, invalid |
| Operators - Composite × Catalog | 8 | All operator combinations |
| Operators - Composite × Composite | 6 | Same/different signatures |
| Integration - End-to-End | 8 | User story scenarios |
| Edge Cases | 4 | Complex composites, precision |
| **Total** | **36** | **Comprehensive coverage** |

### Specific Test Cases

#### UnitResolver Tests
```csharp
[Test]
public void Resolve_CatalogUnit_Unchanged()
{
    var resolver = UnitResolver.Instance;
    var result = resolver.Resolve("m");
    
    Assert.That(result.Token.Name, Is.EqualTo("m"));
    Assert.That(result.UnitType, Is.EqualTo(UnitTypeEnum.Length));
}

[Test]
public void Resolve_CompositeUnit_ReturnsSignatureAndFactor()
{
    var resolver = UnitResolver.Instance;
    var result = resolver.Resolve("m*s");
    
    Assert.That(result.UnitType, Is.EqualTo(UnitTypeEnum.Unknown));
    Assert.That(result.Signature, Is.Not.EqualTo(DimensionSignature.Dimensionless));
}

[Test]
public void Resolve_KnownComposite_ReturnsCorrectUnitType()
{
    var resolver = UnitResolver.Instance;
    var result = resolver.Resolve("kg*m/s^2");
    
    Assert.That(result.UnitType, Is.EqualTo(UnitTypeEnum.Force));
}
```

#### Operator Tests
```csharp
[Test]
public void Divide_CompositeByTime_ReturnsLength()
{
    // Arrange
    var q1 = Quantity.Parse("2 m*s");
    var q2 = Quantity.Parse("0.5 s");
    
    // Act
    var result = q1 / q2;
    
    // Assert
    Assert.That(result.Value, Is.EqualTo(4));
    Assert.That(result.UnitType, Is.EqualTo(UnitTypeEnum.Length));
}

[Test]
public void Multiply_VelocityByTime_ReturnsLength()
{
    // Arrange
    var velocity = Quantity.Parse("10 m/s");
    var time = Quantity.Parse("5 s");
    
    // Act
    var distance = velocity * time;
    
    // Assert
    Assert.That(distance.Value, Is.EqualTo(50));
    Assert.That(distance.UnitType, Is.EqualTo(UnitTypeEnum.Length));
}
```

---

## Acceptance Criteria

### Functional Requirements

✅ **AC-1**: Quantities with catalog units continue to work unchanged in all operators  
✅ **AC-2**: Quantities with composite units can be multiplied by catalog units  
✅ **AC-3**: Quantities with composite units can be divided by catalog units  
✅ **AC-4**: Division of composite by matching composite returns scalar  
✅ **AC-5**: Multiplication/division of two composites produces correct dimensional result  
✅ **AC-6**: Known composite signatures resolve to proper UnitType  
✅ **AC-7**: Unknown composite signatures are marked as UnitTypeEnum.Unknown  
✅ **AC-8**: Invalid units (neither catalog nor valid composite) throw clear exceptions  

### Quality Requirements

✅ **AC-9**: All tests follow `MethodName_Condition_ExpectedResult()` naming convention  
✅ **AC-10**: Test coverage ≥85% for modified UnitResolver code  
✅ **AC-11**: All 387 existing tests pass (no regressions)  
✅ **AC-12**: No breaking changes to public API  
✅ **AC-13**: Performance: Composite resolution <5ms for typical units  
✅ **AC-14**: Documentation updated (E-001, CHANGELOG, README)

### Integration Requirements

✅ **AC-15**: Works seamlessly with Format method (round-trip consistency)  
✅ **AC-16**: Compatible with F-009 composite construction  
✅ **AC-17**: Integrates with existing dimensional algebra engine  
✅ **AC-18**: Error messages are clear and actionable

---

## Risks and Mitigations

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Breaking UnitResolver for catalog units | Low | High | Comprehensive regression tests; catalog fast-path unchanged |
| Performance degradation | Low | Medium | Profile before/after; composite check is O(1) pattern match |
| Complex edge cases in composites | Medium | Medium | Thorough test matrix; reuse proven CompositeParser logic |
| Inconsistent behavior with Format | Low | Medium | Integration tests verify round-trip consistency |

---

## Success Metrics

1. **Functionality**: All acceptance criteria met
2. **Test Coverage**: ≥85% for new/modified code
3. **Backward Compatibility**: 100% of existing tests pass (387 tests)
4. **Performance**: Composite operations complete in <5ms
5. **Quality**: Zero regressions, clear error messages

---

## Dependencies

### Upstream Dependencies (Required)

- **F-009**: Composite Unit Construction ✓ Complete
  - Provides `CompositeParser` infrastructure
  - Provides `MapDescriptionToUnitType` helper
  - Establishes composite unit semantics

### Downstream Consumers (Will Benefit)

- **F-011** (formerly F-010): Performance & caching - can now cache composite resolutions
- **F-012** (formerly F-011): Error handling - benefits from unified resolution
- All user code performing dimensional arithmetic with composites

---

## References

### Internal References

- **E-001**: Epic — Option A Hybrid Core
- **F-009**: Composite Unit Construction (dependency) ✓ Complete
- **F-011** (formerly F-010): Performance & caching (consumer)

### Related Issues

- Original F-009 limitation documented in PR comments
- User request: "A composite unit of 'm*s' is just the unit 'm' multiplied by the unit 's'. This absolutely needs to be supported!"

---

## Notes

- This feature completes the composite unit support started in F-009
- After F-010, composite units will be first-class citizens in all operations
- The limitation noted in F-009 PR will be resolved
- This is a high-priority feature (P1) to deliver complete composite unit functionality

---

## Revision History

| Version | Date | Author | Changes |
|---------|------|--------|---------|
| 1.0 | 2025-11-09 | Copilot Agent | Initial planning document created per user request |
