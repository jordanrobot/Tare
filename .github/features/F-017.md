# F-017: Unified Converter Interface

**Status**: Planned  
**Priority**: P2 (Should)  
**Effort**: M (2-3 days)  
**Epic**: E-001 ‚Äî Option A Hybrid Core  
**Dependencies**: F-015 (Operators Integration - Complete)

---

## TL;DR ‚Äî Quick Reference

**Goal**: Refactor unit conversion system to use a unified interface abstraction that handles Factor-based, Rational-based, and Delegate-based conversions through a single code path, eliminating special-case handling.

**Effort**: 2-3 days (M)

**Impact**: Cleaner architecture, easier maintenance, simpler addition of new unit types, single conversion code path

### What Gets Added

**üîß IUnitConverter Interface**  
Unified abstraction for all conversion types  
**Time**: 2-3 hours

**üìä Converter Implementations**  
LinearConverter (factor/rational), DelegateConverter (custom functions)  
**Time**: 3-4 hours

**üîÑ Refactor Conversion Logic**  
Update Convert(), As(), and arithmetic operators to use interface  
**Time**: 6-8 hours

**‚úÖ Test Coverage**  
Verify all existing tests pass, add interface-specific tests  
**Time**: 4-5 hours

---

## Mandatory Thinking (DDD/.NET Guidelines)

### 1) Analysis

**Applicable Patterns**:
- **Strategy Pattern**: Different conversion strategies (linear, delegate) unified behind common interface
- **SOLID Principles**:
  - **SRP**: Each converter implementation has single responsibility for its conversion type
  - **OCP**: New conversion strategies can be added without modifying existing code
  - **LSP**: All converters are substitutable through IUnitConverter interface
  - **ISP**: Single focused interface with only necessary methods
  - **DIP**: High-level conversion logic depends on abstraction, not concrete implementations

**Layers Affected**:
- Domain: UnitDefinition, Quantity conversion methods
- No changes to public API

**Ubiquitous Language**:
- Converter, ToBase, FromBase, Linear Conversion, Custom Conversion

**Security & Compliance**:
- No security implications - internal refactoring only
- Maintains precision through existing Rational/decimal usage

### 2) Review Against Guidelines

**Aggregate Boundaries**: 
- UnitDefinition remains a value object with converter reference
- Quantity operations remain pure value operations

**SRP**: 
- Each converter implementation handles one conversion type
- UnitDefinition delegates conversion to converter

**Domain Rules Encapsulated**: 
- Conversion logic encapsulated in converter implementations
- UnitDefinition validates converter presence

**Tests**: 
- All existing tests must pass
- Follow `MethodName_Condition_ExpectedResult()` pattern for new tests

**Ubiquitous Language**: 
- Consistent "converter" terminology throughout

### 3) Implementation Plan Validation

**Value Objects**:
- `IUnitConverter` (internal interface): ToBase/FromBase methods
- `LinearConverter` (internal class): Factor/Rational-based conversion
- `DelegateConverter` (internal class): Function-based conversion

**Changes to Existing Types**:
- `UnitDefinition`: Replace Factor/HasCustomConverter/ToBaseFunc/FromBaseFunc with single `Converter` property
- `Quantity`: Update Convert(), BaseValue, arithmetic operators to use converter interface

**Tests**:
- Verify all 625+ existing tests pass
- Add tests for converter implementations
- Add tests for converter substitution

---

## Current Problem

The current codebase has three different ways to specify unit conversions:

1. **Factor-based** (decimal): Simple linear conversions
2. **Rational-based**: Exact linear conversions with numerator/denominator
3. **Delegate-based**: Custom conversion functions for non-linear units (e.g., temperature)

This leads to:
- Multiple code paths in conversion logic
- Special-case handling in operators
- Duplicate logic across Convert(), As(), and arithmetic operations
- Difficulty adding new conversion types

### Code Smell Example

Current `Convert()` method:
```csharp
public decimal Convert(string unit)
{
    var TargetUnit = UnitDefinitions.Parse(unit);
    
    // Special case for custom converters
    if (TargetUnit.HasCustomConverter || (UnitDefinitions.IsValidUnit(Unit) && UnitDefinitions.Parse(Unit).HasCustomConverter))
    {
        var sourceDef = UnitDefinitions.Parse(Unit);
        var baseValue = sourceDef.ToBaseFunc(Value);
        var result = TargetUnit.FromBaseFunc(baseValue);
        return result;
    }
    
    // Factor-based path
    var factorRatio = thisFactor / targetFactor;
    return (Value * factorRatio.Numerator) / factorRatio.Denominator;
}
```

---

## Proposed Solution

### IUnitConverter Interface

```csharp
namespace Tare.Internal;

/// <summary>
/// Unified interface for unit conversions.
/// Implementations handle conversion to/from base unit values.
/// </summary>
internal interface IUnitConverter
{
    /// <summary>
    /// Converts a value from this unit to the base unit.
    /// </summary>
    /// <param name="value">Value in this unit.</param>
    /// <returns>Value in base unit.</returns>
    decimal ToBase(decimal value);
    
    /// <summary>
    /// Converts a value from the base unit to this unit.
    /// </summary>
    /// <param name="baseValue">Value in base unit.</param>
    /// <returns>Value in this unit.</returns>
    decimal FromBase(decimal baseValue);
    
    /// <summary>
    /// Gets whether this converter uses exact rational arithmetic.
    /// </summary>
    bool IsExact { get; }
}
```

### LinearConverter Implementation

```csharp
namespace Tare.Internal;

/// <summary>
/// Converter for linear (proportional) unit conversions using exact rational factors.
/// Examples: length, mass, time (without offsets).
/// </summary>
internal sealed class LinearConverter : IUnitConverter
{
    private readonly Rational _factor;
    
    public LinearConverter(Rational factor)
    {
        _factor = factor;
    }
    
    public decimal ToBase(decimal value) => value * _factor.ToDecimal();
    
    public decimal FromBase(decimal baseValue) => baseValue / _factor.ToDecimal();
    
    public bool IsExact => true;
}
```

### DelegateConverter Implementation

```csharp
namespace Tare.Internal;

/// <summary>
/// Converter for non-linear or affine unit conversions using custom functions.
/// Examples: absolute temperature scales (Celsius, Fahrenheit).
/// </summary>
internal sealed class DelegateConverter : IUnitConverter
{
    private readonly Func<decimal, decimal> _toBase;
    private readonly Func<decimal, decimal> _fromBase;
    
    public DelegateConverter(Func<decimal, decimal> toBase, Func<decimal, decimal> fromBase)
    {
        _toBase = toBase ?? throw new ArgumentNullException(nameof(toBase));
        _fromBase = fromBase ?? throw new ArgumentNullException(nameof(fromBase));
    }
    
    public decimal ToBase(decimal value) => _toBase(value);
    
    public decimal FromBase(decimal baseValue) => _fromBase(baseValue);
    
    public bool IsExact => false; // Delegate conversions may involve approximations
}
```

### Updated UnitDefinition

```csharp
public class UnitDefinition
{
    public string Name { get; }
    public HashSet<string> Aliases { get; }
    public UnitTypeEnum UnitType { get; }
    
    /// <summary>
    /// Gets the converter for this unit.
    /// </summary>
    internal IUnitConverter Converter { get; }
    
    /// <summary>
    /// Legacy Factor property for compatibility.
    /// </summary>
    public decimal Factor => Converter.ToBase(1m);
    
    /// <summary>
    /// Creates a UnitDefinition with a decimal factor.
    /// </summary>
    public UnitDefinition(string name, decimal factor, UnitTypeEnum unitType, HashSet<string> aliases)
    {
        Name = name;
        UnitType = unitType;
        Aliases = aliases;
        Converter = new LinearConverter(Rational.FromDecimal(factor));
    }
    
    /// <summary>
    /// Creates a UnitDefinition with an exact rational factor.
    /// </summary>
    public UnitDefinition(string name, Rational factor, UnitTypeEnum unitType, HashSet<string> aliases)
    {
        Name = name;
        UnitType = unitType;
        Aliases = aliases;
        Converter = new LinearConverter(factor);
    }
    
    /// <summary>
    /// Creates a UnitDefinition with custom conversion functions.
    /// </summary>
    public UnitDefinition(string name, UnitTypeEnum unitType, HashSet<string> aliases, 
                         Func<decimal, decimal> toBase, Func<decimal, decimal> fromBase)
    {
        Name = name;
        UnitType = unitType;
        Aliases = aliases;
        Converter = new DelegateConverter(toBase, fromBase);
    }
}
```

### Simplified Conversion Logic

```csharp
public decimal Convert(string unit)
{
    var targetDef = UnitDefinitions.Parse(unit);
    var sourceDef = UnitDefinitions.Parse(Unit);
    
    // Single unified path - no special cases!
    var baseValue = sourceDef.Converter.ToBase(Value);
    var result = targetDef.Converter.FromBase(baseValue);
    return result;
}
```

---

## Benefits

### 1. Single Code Path
- All conversions use the same logic
- No special-case handling
- Easier to understand and maintain

### 2. Easier Extension
- Add new conversion types by implementing IUnitConverter
- No changes to calling code required
- Examples: logarithmic scales (decibels), non-linear scales

### 3. Better Testing
- Test converter implementations independently
- Mock converters for unit testing Quantity operations
- Clear separation of concerns

### 4. Cleaner Operators
- Arithmetic operators simplified
- No need to check HasCustomConverter
- Temperature special case can potentially be generalized

### 5. Performance Opportunities
- Can optimize LinearConverter with pre-computed reciprocals
- Can add caching to DelegateConverter if needed
- Can profile and optimize each converter independently

---

## Implementation Phases

### Phase 1: Create Converter Infrastructure (4-5 hours)
- [ ] Create IUnitConverter interface
- [ ] Implement LinearConverter with tests
- [ ] Implement DelegateConverter with tests
- [ ] Ensure all converter tests pass

### Phase 2: Update UnitDefinition (3-4 hours)
- [ ] Add Converter property to UnitDefinition
- [ ] Update three constructors to create appropriate converters
- [ ] Add tests for UnitDefinition with different converter types
- [ ] Keep legacy properties (Factor, HasCustomConverter) for compatibility
- [ ] Ensure all unit definition tests pass

### Phase 3: Refactor Conversion Methods (6-8 hours)
- [ ] Update Convert() to use converter interface
- [ ] Update As() to use converter interface
- [ ] Update BaseValue property to use converter interface
- [ ] Test that all existing conversion tests pass
- [ ] Measure performance impact

### Phase 4: Simplify Arithmetic Operators (4-5 hours)
- [ ] Evaluate if temperature special case can be generalized
- [ ] Update operators to use converter interface where applicable
- [ ] Test that all arithmetic tests pass
- [ ] Consider adding converter-aware arithmetic logic

### Phase 5: Remove Legacy Code (2-3 hours)
- [ ] Remove HasCustomConverter property
- [ ] Remove ToBaseFunc/FromBaseFunc properties
- [ ] Remove special-case handling code
- [ ] Update internal documentation
- [ ] Final test suite run

### Phase 6: Documentation and Review (2-3 hours)
- [ ] Update internal architecture documentation
- [ ] Add XML documentation to new types
- [ ] Code review for SOLID principles
- [ ] Performance benchmark comparison
- [ ] Update CHANGELOG.md

---

## Testing Strategy

### Unit Tests for Converters
```csharp
[TestFixture]
public class LinearConverterTests
{
    [Test]
    public void ToBase_WithFactor2_DoublesValue()
    {
        var converter = new LinearConverter(Rational.FromDecimal(2m));
        var result = converter.ToBase(5m);
        Assert.That(result, Is.EqualTo(10m));
    }
    
    [Test]
    public void FromBase_WithFactor2_HalvesValue()
    {
        var converter = new LinearConverter(Rational.FromDecimal(2m));
        var result = converter.FromBase(10m);
        Assert.That(result, Is.EqualTo(5m));
    }
}

[TestFixture]
public class DelegateConverterTests
{
    [Test]
    public void ToBase_CelsiusToKelvin_AddsOffset()
    {
        var converter = new DelegateConverter(
            c => c + 273.15m,
            k => k - 273.15m
        );
        var result = converter.ToBase(0m);
        Assert.That(result, Is.EqualTo(273.15m));
    }
}
```

### Integration Tests
- All existing Quantity tests must pass unchanged
- Temperature conversion tests must pass
- Arithmetic operation tests must pass
- Performance should be comparable (within 10%)

---

## Acceptance Criteria

### Functional
‚úÖ **AC-1**: All converter implementations pass unit tests  
‚úÖ **AC-2**: All existing Quantity conversion tests pass  
‚úÖ **AC-3**: All arithmetic operation tests pass  
‚úÖ **AC-4**: Temperature conversions work correctly  
‚úÖ **AC-5**: Negative number parsing still works  

### Quality
‚úÖ **AC-6**: Code coverage ‚â•85% for converter implementations  
‚úÖ **AC-7**: No public API changes  
‚úÖ **AC-8**: All tests follow naming convention  
‚úÖ **AC-9**: XML documentation complete  
‚úÖ **AC-10**: No compiler warnings  

### Non-Functional
‚úÖ **AC-11**: Single conversion code path (no if/else for converter type)  
‚úÖ **AC-12**: Performance within 10% of current implementation  
‚úÖ **AC-13**: Memory usage unchanged  
‚úÖ **AC-14**: Thread-safe (converters are immutable)  

---

## Risks and Mitigations

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Performance regression | Low | Medium | Benchmark before/after; optimize if needed |
| Breaking existing behavior | Low | High | Comprehensive test suite; careful review |
| Temperature special case can't be removed | Medium | Low | Keep special case if needed; still benefit from unified converters |
| Increased complexity for simple units | Low | Low | LinearConverter is simple; no extra complexity |

---

## Out of Scope

The following are explicitly NOT part of F-017:

‚ùå **Public API Changes**: Converter interface remains internal  
‚ùå **New Unit Types**: Focus is on refactoring, not adding features  
‚ùå **Performance Optimization**: Beyond ensuring no regression  
‚ùå **Converter Composition**: Chaining converters (defer to future)  
‚ùå **Converter Validation**: Beyond basic null checks  

---

## Success Metrics

1. **Code Quality**: Single conversion path eliminates branching
2. **Maintainability**: New unit types easier to add
3. **Test Coverage**: ‚â•85% for converter implementations
4. **Performance**: Within 10% of current performance
5. **Stability**: All 625+ tests pass

---

## Future Enhancements

After F-017 is complete, consider:

1. **F-018: Converter Composition** - Chain converters for complex transformations
2. **F-019: Converter Caching** - Cache frequently used converter instances
3. **F-020: Converter Metadata** - Add converter-specific metadata (precision, linearity, etc.)
4. **F-021: Logarithmic Converters** - Add support for decibel scales

---

## References

### Internal References
- **E-001**: Epic ‚Äî Option A Hybrid Core
- **F-015**: Operators Integration (Complete)
- **Current Issue**: Temperature arithmetic fixes (Complete)

### External References
- **Strategy Pattern**: https://refactoring.guru/design-patterns/strategy
- **SOLID Principles**: https://en.wikipedia.org/wiki/SOLID

---

## Revision History

| Version | Date | Author | Changes |
|---------|------|--------|---------|
| 1.0 | 2025-11-15 | Copilot | Initial planning document created based on temperature fix discussion |

---

**Ready for Review** ‚úÖ  
This planning document defines F-017 (Unified Converter Interface) as a refactoring effort to simplify and unify the unit conversion system using the Strategy pattern and SOLID principles.
