# F-006: Composite Unit Formatter

**Status**: Planned  
**Priority**: P1 (Must)  
**Effort**: M (1.5–2 days)  
**Epic**: E-001 — Option A Hybrid Core  
**Dependencies**: F-002 (Dimension Signature Model), F-005 (Known-Signature Naming Map)

---

## Feature Overview

This feature delivers a composite unit formatter that generates stable, human-readable unit strings for dimension signatures that are not in the known-signature map. When dimensional algebra operations produce results with unknown signatures, the formatter creates standardized composite strings using canonical ordering and exponent notation.

### User Story

**As a** Tare library user performing dimensional algebra calculations  
**I want** results with unknown dimension signatures to display as stable, readable composite unit strings  
**So that** complex operations like `(lbf * in³) / s²` are presented consistently and predictably

### Context

F-006 is the sixth feature in the E-001 epic implementing Option A (Hybrid Core). It builds on:
- **F-002**: Dimension signature model for representing dimensional compositions
- **F-005**: Known-signature naming map for recognized unit names

The composite formatter serves as a fallback mechanism when signature resolution fails:
- Takes a dimension signature and produces a deterministic string representation
- Uses canonical base unit tokens ordered consistently
- Formats exponents clearly with `^n` notation
- Separates numerator and denominator with `/`
- Ensures idempotent formatting (same signature → same string every time)

This feature will be consumed by F-007 (Operators Integration) and F-008 (Format Extensions) to present results with appropriate formatting when known unit names are not available.

---

## Mandatory Thinking Process (DDD/.NET Guidelines)

### 1. Domain Analysis (REQUIRED)

#### Domain Concepts Involved

- **Composite Unit String**: A formatted representation of a dimension signature using base unit symbols (e.g., "kg·m²/s²", "lbf·in³/s²")
- **Canonical Ordering**: A deterministic order for base unit tokens (alphabetical or dimensional order: L, M, T, I, Θ, N, J)
- **Numerator Units**: Dimensions with positive exponents
- **Denominator Units**: Dimensions with negative exponents  
- **Exponent Notation**: Format for powers (e.g., "m²" or "m^2" for m²)
- **Unit Separator**: Symbol between units in numerator or denominator (typically "·" or "*")
- **Fraction Separator**: Symbol between numerator and denominator (typically "/")
- **Dimensionless Formatting**: Special case for scalar results (empty string or "1")

#### Aggregate Boundaries and Consistency Requirements

- **Value Objects**: 
  - `DimensionSignature` — Immutable signature from F-002 (consumed)
  - `CompositeFormat` — Configuration for formatting style (optional future enhancement)
- **Domain Service**: 
  - `ICompositeFormatter` — Interface for signature → composite string conversion
  - `CompositeFormatter` — Implementation with canonical formatting rules
- **Consistency**: 
  - Same signature always produces same string (deterministic)
  - Ordering is stable across library versions (backward compatibility)
  - Format is parseable for future composite construction (F-009)

#### Ubiquitous Language Terms

- **Composite Unit**, **Canonical Ordering**, **Base Unit Token**, **Exponent Notation**, **Numerator**, **Denominator**, **Dimensional String**, **Stable Formatting**

#### Business Rules and Invariants

- **Determinism**: Same signature always produces identical formatted string
- **Idempotence**: Formatting operation is pure and repeatable
- **Canonical Order**: Base dimensions appear in consistent order (L, M, T, I, Θ, N, J)
- **Exponent Grouping**: Positive exponents in numerator, negative in denominator
- **Unit One Handling**: Exponent of 1 is implicit (not shown as "m^1", just "m")
- **Dimensionless**: Returns empty string "" or "1" based on configuration

### 2. Architecture Review (REQUIRED)

#### Layer Responsibilities

- **Domain Layer**: 
  - `ICompositeFormatter` interface (internal)
  - `CompositeFormatter` implementation (internal sealed class)
  - `CompositeFormatterOptions` (internal, future use for style configuration)
- **Integration Points**:
  - Consumes `DimensionSignature` from F-002
  - Provides fallback formatting when `KnownSignatureMap` (F-005) doesn't resolve
  - Used by F-007 (Operators Integration) for operation results
  - Used by F-008 (Format Extensions) for format target handling

#### SOLID Principles Adherence

- **SRP**: `CompositeFormatter` has single responsibility—generate composite unit strings from signatures
- **OCP**: Extensible to different formatting styles via options; closed to modification of core logic
- **LSP**: N/A (no inheritance hierarchy)
- **ISP**: Interface focused only on formatting operations
- **DIP**: Consumers depend on `ICompositeFormatter` interface, not concrete implementation

#### Domain Events

- N/A — Formatting is a pure string generation operation with no side effects

#### Security Implications

- No user credentials or sensitive data
- Deterministic behavior with no external dependencies
- Immutable operations prevent modification attacks
- String generation bounded by signature dimensions (no unbounded memory)

### 3. Implementation Planning (REQUIRED)

#### Files to Create/Modify

| File | Type | Justification |
|------|------|---------------|
| `src/Internal/Units/ICompositeFormatter.cs` | New | Interface for composite formatting service |
| `src/Internal/Units/CompositeFormatter.cs` | New | Implementation with canonical formatting logic |
| `src/Internal/Units/CompositeFormatterOptions.cs` | New | Options for formatting style (future use) |
| `tests/CompositeFormatterTests.cs` | New | Comprehensive unit tests for formatter |
| `docs/CHANGELOG.md` | Modified | Document internal implementation |

#### Test Cases (Following `MethodName_Condition_ExpectedResult()` Pattern)

**Basic Formatting:**
- `Format_LengthSignature_ReturnsMeter()`
- `Format_MassSignature_ReturnsKilogram()`
- `Format_TimeSignature_ReturnsSecond()`
- `Format_AreaSignature_ReturnsSquareMeter()`
- `Format_VolumeSignature_ReturnsCubicMeter()`
- `Format_DimensionlessSignature_ReturnsEmptyString()`

**Composite Formatting:**
- `Format_VelocitySignature_ReturnsMeterPerSecond()`
- `Format_AccelerationSignature_ReturnsMeterPerSquareSecond()`
- `Format_ForceSignature_ReturnsKilogramMeterPerSquareSecond()`
- `Format_EnergySignature_ReturnsKilogramSquareMeterPerSquareSecond()`
- `Format_PressureSignature_ReturnsKilogramPerMeterSquareSecond()`

**Complex Signatures:**
- `Format_ComplexNumeratorOnly_OrdersByDimension()`
- `Format_ComplexDenominatorOnly_OrdersByDimension()`
- `Format_ComplexMixedNumeratorDenominator_FormatsCorrectly()`
- `Format_AllSevenDimensions_FormatsAllCorrectly()`

**Exponent Handling:**
- `Format_ExponentOne_OmitsExponent()`
- `Format_ExponentTwo_ShowsExponentTwo()`
- `Format_ExponentThree_ShowsExponentThree()`
- `Format_ExponentNegativeOne_AppearsInDenominatorNoExponent()`
- `Format_ExponentNegativeTwo_AppearsInDenominatorWithExponentTwo()`

**Stability and Idempotence:**
- `Format_SameSignatureTwice_ReturnsSameString()`
- `Format_EquivalentSignatures_ReturnSameString()`
- `Format_DifferentSignatures_ReturnDifferentStrings()`

**Edge Cases:**
- `Format_AllZeroExponents_ReturnsDimensionless()`
- `Format_SinglePositiveExponent_ReturnsSimpleUnit()`
- `Format_SingleNegativeExponent_ReturnsReciprocalUnit()`

#### Error Handling and Validation Strategy

- **No Exceptions**: Formatter always succeeds for valid `DimensionSignature`
- **Null Handling**: Signature is value type, no null checks needed
- **Thread Safety**: Pure functions with no shared state ensure thread safety
- **Deterministic**: Same input always produces same output

#### Performance and Scalability Considerations

- **String Building**: Use `StringBuilder` for efficient concatenation
- **Memory**: Minimal allocations per format call; typical strings <50 characters
- **Caching**: No caching needed at formatter level; results cached by callers if needed
- **Allocation**: Consider string interning for common patterns (future optimization)

---

## Detailed Implementation Design

### ICompositeFormatter Interface

```csharp
namespace Tare.Internal.Units;

/// <summary>
/// Service interface for formatting dimension signatures as composite unit strings.
/// </summary>
internal interface ICompositeFormatter
{
    /// <summary>
    /// Formats a dimension signature as a composite unit string using canonical base units.
    /// </summary>
    /// <param name="signature">The dimension signature to format.</param>
    /// <returns>A stable, human-readable composite unit string (e.g., "kg·m²/s²").</returns>
    /// <remarks>
    /// The format is deterministic and idempotent: the same signature always produces
    /// the same string. Base dimensions appear in canonical order (L, M, T, I, Θ, N, J).
    /// Positive exponents form the numerator; negative exponents form the denominator.
    /// Dimensionless signatures return an empty string.
    /// </remarks>
    string Format(DimensionSignature signature);
    
    /// <summary>
    /// Formats a dimension signature with custom base unit tokens (for future use with non-SI bases).
    /// </summary>
    /// <param name="signature">The dimension signature to format.</param>
    /// <param name="baseUnitTokens">Custom tokens for each dimension (L, M, T, I, Θ, N, J).</param>
    /// <returns>A composite unit string using the provided base unit tokens.</returns>
    /// <remarks>
    /// This overload allows formatting using non-SI base units (e.g., US Customary).
    /// Initial implementation uses SI tokens ("m", "kg", "s", "A", "K", "mol", "cd").
    /// </remarks>
    string Format(DimensionSignature signature, string[] baseUnitTokens);
}
```

### CompositeFormatter Implementation

```csharp
using System;
using System.Text;

namespace Tare.Internal.Units;

/// <summary>
/// Formats dimension signatures as composite unit strings using canonical ordering and notation.
/// </summary>
/// <remarks>
/// This sealed class implements deterministic, idempotent formatting for composite units.
/// Base dimensions are ordered canonically (L, M, T, I, Θ, N, J), with positive exponents
/// in the numerator and negative exponents in the denominator.
/// </remarks>
internal sealed class CompositeFormatter : ICompositeFormatter
{
    /// <summary>
    /// Singleton instance for efficient reuse.
    /// </summary>
    public static readonly CompositeFormatter Instance = new CompositeFormatter();
    
    /// <summary>
    /// Default SI base unit tokens in canonical order: L, M, T, I, Θ, N, J.
    /// </summary>
    private static readonly string[] DefaultBaseUnits = { "m", "kg", "s", "A", "K", "mol", "cd" };
    
    private CompositeFormatter()
    {
    }
    
    /// <inheritdoc/>
    public string Format(DimensionSignature signature)
    {
        return Format(signature, DefaultBaseUnits);
    }
    
    /// <inheritdoc/>
    public string Format(DimensionSignature signature, string[] baseUnitTokens)
    {
        if (baseUnitTokens == null || baseUnitTokens.Length != 7)
        {
            throw new ArgumentException("Base unit tokens must be an array of exactly 7 elements (L, M, T, I, Θ, N, J).", nameof(baseUnitTokens));
        }
        
        // Get exponents in canonical order
        sbyte[] exponents = {
            signature.Length,
            signature.Mass,
            signature.Time,
            signature.ElectricCurrent,
            signature.Temperature,
            signature.AmountOfSubstance,
            signature.LuminousIntensity
        };
        
        // Check for dimensionless
        if (IsDimensionless(exponents))
        {
            return string.Empty;
        }
        
        var numerator = new StringBuilder();
        var denominator = new StringBuilder();
        
        // Build numerator and denominator
        for (int i = 0; i < 7; i++)
        {
            sbyte exp = exponents[i];
            
            if (exp > 0)
            {
                // Positive exponent: add to numerator
                if (numerator.Length > 0)
                {
                    numerator.Append('·');
                }
                numerator.Append(baseUnitTokens[i]);
                if (exp > 1)
                {
                    numerator.Append('^').Append(exp);
                }
            }
            else if (exp < 0)
            {
                // Negative exponent: add to denominator
                if (denominator.Length > 0)
                {
                    denominator.Append('·');
                }
                denominator.Append(baseUnitTokens[i]);
                if (exp < -1)
                {
                    denominator.Append('^').Append(-exp);
                }
            }
        }
        
        // Combine numerator and denominator
        if (numerator.Length == 0)
        {
            // Only denominator (e.g., 1/s²)
            return "1/" + denominator.ToString();
        }
        else if (denominator.Length == 0)
        {
            // Only numerator
            return numerator.ToString();
        }
        else
        {
            // Both numerator and denominator
            return numerator.ToString() + "/" + denominator.ToString();
        }
    }
    
    private static bool IsDimensionless(sbyte[] exponents)
    {
        foreach (var exp in exponents)
        {
            if (exp != 0)
            {
                return false;
            }
        }
        return true;
    }
}
```

### CompositeFormatterOptions (Future Use)

```csharp
namespace Tare.Internal.Units;

/// <summary>
/// Configuration options for composite unit formatting.
/// </summary>
/// <remarks>
/// This class enables future customization of formatting style.
/// Initial implementation uses fixed SI-style formatting.
/// </remarks>
internal sealed class CompositeFormatterOptions
{
    /// <summary>
    /// Gets the default formatting options (SI style).
    /// </summary>
    public static CompositeFormatterOptions Default { get; } = new CompositeFormatterOptions();
    
    /// <summary>
    /// Gets or sets the symbol used to separate units in numerator/denominator.
    /// </summary>
    /// <remarks>
    /// Default: "·" (middle dot). Alternative: "*" (asterisk).
    /// </remarks>
    public string UnitSeparator { get; init; } = "·";
    
    /// <summary>
    /// Gets or sets the symbol used to separate numerator from denominator.
    /// </summary>
    /// <remarks>
    /// Default: "/" (forward slash).
    /// </remarks>
    public string FractionSeparator { get; init; } = "/";
    
    /// <summary>
    /// Gets or sets the format for exponent notation.
    /// </summary>
    /// <remarks>
    /// Default: ExponentFormat.Caret (e.g., "m^2").
    /// Alternative: ExponentFormat.Unicode (e.g., "m²") for future use.
    /// </remarks>
    public ExponentFormat ExponentFormat { get; init; } = ExponentFormat.Caret;
    
    /// <summary>
    /// Gets or sets the string used for dimensionless results.
    /// </summary>
    /// <remarks>
    /// Default: "" (empty string). Alternative: "1" for explicit dimensionless.
    /// </remarks>
    public string DimensionlessString { get; init; } = string.Empty;
}

/// <summary>
/// Specifies the format for exponent notation in composite units.
/// </summary>
internal enum ExponentFormat
{
    /// <summary>
    /// Use caret notation (e.g., "m^2", "s^3").
    /// </summary>
    Caret = 0,
    
    /// <summary>
    /// Use Unicode superscript notation (e.g., "m²", "s³").
    /// Reserved for future implementation.
    /// </summary>
    Unicode = 1
}
```

**Note**: Initial implementation uses fixed formatting with `CompositeFormatterOptions.Default`. Custom options support will be added in a future iteration when user demand is validated.

---

## Formatting Examples

The following examples demonstrate expected formatter output:

### Base Dimensions
- **Length** (1,0,0,0,0,0,0) → "m"
- **Mass** (0,1,0,0,0,0,0) → "kg"
- **Time** (0,0,1,0,0,0,0) → "s"
- **Dimensionless** (0,0,0,0,0,0,0) → ""

### Geometric Dimensions
- **Area** (2,0,0,0,0,0,0) → "m^2"
- **Volume** (3,0,0,0,0,0,0) → "m^3"

### Kinematic Dimensions
- **Velocity** (1,0,-1,0,0,0,0) → "m/s"
- **Acceleration** (1,0,-2,0,0,0,0) → "m/s^2"

### Dynamic Dimensions
- **Force** (1,1,-2,0,0,0,0) → "kg·m/s^2"
- **Energy/Torque** (2,1,-2,0,0,0,0) → "kg·m^2/s^2"
- **Power** (2,1,-3,0,0,0,0) → "kg·m^2/s^3"
- **Pressure** (-1,1,-2,0,0,0,0) → "kg/m·s^2"

### Complex Examples
- **Momentum** (1,1,-1,0,0,0,0) → "kg·m/s"
- **Angular Momentum** (2,1,-1,0,0,0,0) → "kg·m^2/s"
- **Density** (-3,1,0,0,0,0,0) → "kg/m^3"
- **Frequency** (0,0,-1,0,0,0,0) → "1/s"

### Edge Cases
- **All Seven Dimensions** (1,1,1,1,1,1,1) → "m·kg·s·A·K·mol·cd"
- **All Negative** (-1,-1,-1,0,0,0,0) → "1/m·kg·s"
- **Mixed Large Exponents** (3,2,-4,0,0,0,0) → "m^3·kg^2/s^4"

**Formatting Stability**: All examples are deterministic and idempotent—the same signature always produces the same string.

---

## Specific Tasks

### Phase 1: Interface and Options Design (Day 1, 2 hours)

- [ ] Create `ICompositeFormatter` interface
  - [ ] Define `Format(DimensionSignature)` method signature
  - [ ] Define `Format(DimensionSignature, string[])` overload
  - [ ] Add comprehensive XML documentation
  - [ ] Document determinism and idempotence guarantees
- [ ] Create `CompositeFormatterOptions` class
  - [ ] Define option properties (UnitSeparator, FractionSeparator, etc.)
  - [ ] Create `Default` static instance
  - [ ] Add XML documentation (note: fixed formatting initially)
- [ ] Create `ExponentFormat` enum
  - [ ] Define Caret and Unicode values
  - [ ] Add XML documentation

### Phase 2: Formatter Implementation (Day 1, 3-4 hours)

- [ ] Create `CompositeFormatter` implementation
  - [ ] Define sealed class implementing `ICompositeFormatter`
  - [ ] Create singleton instance pattern
  - [ ] Define `DefaultBaseUnits` constant array
  - [ ] Implement `Format(DimensionSignature)` method
    - [ ] Call overload with default base units
  - [ ] Implement `Format(DimensionSignature, string[])` overload
    - [ ] Validate base unit tokens array (length = 7)
    - [ ] Extract exponents in canonical order
    - [ ] Check for dimensionless case
    - [ ] Build numerator with positive exponents
    - [ ] Build denominator with negative exponents
    - [ ] Handle exponent formatting (omit "^1", show others)
    - [ ] Combine numerator and denominator with separators
    - [ ] Handle special cases (numerator only, denominator only)
  - [ ] Implement `IsDimensionless` helper method
  - [ ] Add comprehensive XML documentation
- [ ] Code review for correctness
  - [ ] Verify canonical ordering (L, M, T, I, Θ, N, J)
  - [ ] Confirm exponent grouping logic
  - [ ] Validate string building efficiency

### Phase 3: Comprehensive Testing (Day 2, 3-4 hours)

- [ ] Create `CompositeFormatterTests.cs`
  - [ ] Test basic single-dimension formatting
    - [ ] Length → "m"
    - [ ] Mass → "kg"
    - [ ] Time → "s"
    - [ ] All seven base dimensions
  - [ ] Test dimensionless formatting
    - [ ] All zero exponents → ""
  - [ ] Test positive exponent formatting
    - [ ] Exponent 1 → no caret (implicit)
    - [ ] Exponent 2 → "^2"
    - [ ] Exponent 3+ → "^n"
    - [ ] Area (m^2), Volume (m^3)
  - [ ] Test negative exponent formatting
    - [ ] Single negative → "1/unit"
    - [ ] Multiple negatives → "1/unit1·unit2"
    - [ ] Exponent -1 → no caret
    - [ ] Exponent -2+ → "^n"
  - [ ] Test mixed numerator/denominator
    - [ ] Velocity (m/s)
    - [ ] Acceleration (m/s^2)
    - [ ] Force (kg·m/s^2)
    - [ ] Energy (kg·m^2/s^2)
    - [ ] Pressure (kg/m·s^2)
  - [ ] Test canonical ordering
    - [ ] Verify dimensions ordered L, M, T, I, Θ, N, J
    - [ ] Test all seven dimensions positive
    - [ ] Test all seven dimensions negative
    - [ ] Test mixed ordering
  - [ ] Test determinism and idempotence
    - [ ] Same signature twice → same string
    - [ ] Equivalent signatures → same string
    - [ ] Different signatures → different strings
  - [ ] Test custom base unit tokens
    - [ ] US Customary tokens (future use)
    - [ ] Invalid token array (null, wrong length)
  - [ ] Test singleton pattern
    - [ ] Instance is not null
    - [ ] Multiple accesses return same instance
  - [ ] Test edge cases
    - [ ] Single dimension positive
    - [ ] Single dimension negative
    - [ ] Large exponents (>9)
    - [ ] Complex mixed patterns

### Phase 4: Integration and Documentation (Day 2, 1-2 hours)

- [ ] Integration validation
  - [ ] Verify compatibility with `DimensionSignature` from F-002
  - [ ] Test with all known signatures from F-005 (should not be called for those, but verify correct fallback)
  - [ ] Validate interface suitable for F-007 and F-008 consumption
- [ ] Add comprehensive XML documentation
  - [ ] All public-within-internal members documented
  - [ ] Examples in remarks where helpful
  - [ ] Document determinism guarantees
  - [ ] Document canonical ordering rationale
- [ ] Update CHANGELOG.md
  - [ ] Note internal implementation (not public API change)
  - [ ] Document formatting conventions
  - [ ] Reference F-006 feature completion
- [ ] Code review
  - [ ] SOLID principles adherence
  - [ ] String building efficiency
  - [ ] Thread-safety confirmation
  - [ ] Naming consistency

---

## Acceptance Criteria

### Functional Requirements

✅ **AC-1**: Formats all base dimensions correctly (m, kg, s, A, K, mol, cd)  
✅ **AC-2**: Dimensionless signature returns empty string ""  
✅ **AC-3**: Exponent 1 is implicit (not shown as "^1")  
✅ **AC-4**: Exponents >1 shown with caret notation (e.g., "m^2", "s^3")  
✅ **AC-5**: Positive exponents appear in numerator  
✅ **AC-6**: Negative exponents appear in denominator (absolute value)  
✅ **AC-7**: Dimensions ordered canonically (L, M, T, I, Θ, N, J)  
✅ **AC-8**: Units separated with middle dot "·" in numerator/denominator  
✅ **AC-9**: Numerator and denominator separated with "/"  
✅ **AC-10**: Denominator-only formats as "1/denominator"

### Quality Requirements

✅ **AC-11**: All tests follow `MethodName_Condition_ExpectedResult()` naming convention  
✅ **AC-12**: Test coverage ≥85% for `CompositeFormatter`  
✅ **AC-13**: No public API changes (internal implementation only)  
✅ **AC-14**: No external dependencies added  
✅ **AC-15**: Builds successfully on both `netstandard2.0` and `net7.0` TFMs  
✅ **AC-16**: No compiler warnings related to new code

### Non-Functional Requirements

✅ **AC-17**: Deterministic formatting (same signature → same string)  
✅ **AC-18**: Idempotent operations (repeatable, no side effects)  
✅ **AC-19**: Thread-safe (pure functions, no shared mutable state)  
✅ **AC-20**: Efficient string building (use StringBuilder)  
✅ **AC-21**: Minimal memory footprint (<1KB per format call)  
✅ **AC-22**: XML documentation for all members  
✅ **AC-23**: CHANGELOG.md updated with implementation note

### Integration Requirements

✅ **AC-24**: Compatible with `DimensionSignature` from F-002  
✅ **AC-25**: Works as fallback when `KnownSignatureMap` (F-005) doesn't resolve  
✅ **AC-26**: Ready for F-007 (Operators Integration) consumption  
✅ **AC-27**: Ready for F-008 (Format Extensions) consumption  
✅ **AC-28**: Supports custom base unit tokens for future US Customary formatting

---

## Test Plan

### Test Organization

**Test Files**:
- `tests/CompositeFormatterTests.cs` — Comprehensive formatter tests

**Test Framework**: xUnit (consistent with existing test structure)  
**Test Categories**: Unit tests (no integration tests needed for pure formatting)

### Test Structure Template

```csharp
[Fact]
public void Format_LengthSignature_ReturnsMeter()
{
    // Arrange
    var formatter = CompositeFormatter.Instance;
    var lengthSignature = DimensionSignature.LengthSignature;
    
    // Act
    var result = formatter.Format(lengthSignature);
    
    // Assert
    Assert.Equal("m", result);
}

[Fact]
public void Format_VelocitySignature_ReturnsMeterPerSecond()
{
    // Arrange
    var formatter = CompositeFormatter.Instance;
    var velocitySignature = DimensionSignature.VelocitySignature;
    
    // Act
    var result = formatter.Format(velocitySignature);
    
    // Assert
    Assert.Equal("m/s", result);
}
```

### Test Coverage Matrix

| Category | Test Count | Focus Areas |
|----------|------------|-------------|
| Base Dimensions | 7 | Each base dimension (L, M, T, I, Θ, N, J) |
| Dimensionless | 2 | All zeros, empty string result |
| Positive Exponents | 6 | Exponent 1 (implicit), 2, 3+, area, volume |
| Negative Exponents | 6 | Single -1, -2+, denominator formatting |
| Mixed Numerator/Denominator | 10 | Velocity, acceleration, force, energy, pressure, etc. |
| Canonical Ordering | 5 | Order verification, all dims positive/negative/mixed |
| Determinism/Idempotence | 4 | Same signature twice, equivalent sigs, different sigs |
| Custom Base Tokens | 3 | Valid custom tokens, invalid array |
| Singleton Pattern | 2 | Instance not null, same instance |
| Edge Cases | 5 | Single dim, large exponents, complex patterns |
| **Total** | **50** | **Comprehensive coverage** |

---

## Dependencies

### Upstream Dependencies (Required)
- **F-002**: `DimensionSignature` must be implemented and tested
  - Provides signature structure with exponent properties
  - Provides value semantics for equality
- **F-005**: `KnownSignatureMap` context (understanding of fallback role)
  - While not a hard dependency, F-005 provides context for when formatter is used

### Downstream Consumers (Will Use This)
- **F-007**: Operators Integration
  - Will use formatter as fallback when known signature not found
  - Will format operation results using composite strings
- **F-008**: Format Extensions
  - Will use formatter for composite format targets
  - Will parse composite strings for formatting conversions

---

## Risks and Mitigations

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Format string ambiguity | Low | Medium | Use canonical ordering and consistent separators |
| Performance with complex signatures | Low | Low | Use StringBuilder; typical strings <50 chars |
| Breaking format changes | Medium | High | Document format as part of internal contract; version if needed |
| Inconsistent formatting across versions | Low | High | Treat format as stable; changes require major version bump |
| Unicode separator rendering issues | Medium | Low | Use ASCII separators initially ("·" supported on all platforms) |

---

## Integration Notes

### For F-007 (Operators Integration)

The formatter is designed to be consumed as a fallback when known signature resolution fails:

```csharp
// Example operator integration (to be implemented in F-007)
public static Quantity operator *(Quantity left, Quantity right)
{
    var result = engine.Multiply(...);
    
    // Try known signature first
    string unitName;
    if (KnownSignatureMap.Instance.TryGetPreferredUnit(result.Signature, out var preferred))
    {
        unitName = preferred.CanonicalName;
    }
    else
    {
        // Fallback to composite formatting
        unitName = CompositeFormatter.Instance.Format(result.Signature);
    }
    
    return new Quantity(result.Value, unitName);
}
```

### For F-008 (Format Extensions)

Format extensions will use the formatter to handle composite format targets:

```csharp
// Example format extension integration (to be implemented in F-008)
public Quantity Format(string targetUnit)
{
    // ... parse targetUnit and resolve signature ...
    
    // Format result with composite string if needed
    if (!KnownSignatureMap.Instance.TryGetPreferredUnit(signature, out var preferred))
    {
        string compositeUnit = CompositeFormatter.Instance.Format(signature);
        return new Quantity(convertedValue, compositeUnit);
    }
    
    return new Quantity(convertedValue, preferred.CanonicalName);
}
```

---

## Out of Scope

The following are explicitly NOT part of F-006:

❌ **Unicode Superscript Exponents**: Deferred to future iteration; use caret notation initially  
❌ **Localized Unit Names**: English only; localization deferred  
❌ **User-Configurable Formatting**: Fixed format initially; options support deferred  
❌ **Composite Parsing Logic**: Handled by F-009 (Optional Composite Construction)  
❌ **Operator Wiring**: Handled by F-007 (Operators Integration)  
❌ **Format Method Integration**: Handled by F-008 (Format Extensions)  
❌ **Public API Exposure**: Formatter remains internal; public API unchanged  
❌ **US Customary Base Units**: SI units only initially; custom tokens supported for future use

---

## Quality Checklist

### Domain Design Validation
- [ ] I have verified that the formatter properly generates composite strings from signatures
- [ ] I have confirmed consistent terminology (composite, canonical, numerator, denominator)
- [ ] I have verified SOLID principles adherence (SRP, OCP)
- [ ] I have validated formatting determinism and idempotence

### Implementation Quality Validation
- [ ] I have written comprehensive tests following `MethodName_Condition_ExpectedResult()` naming
- [ ] I have achieved >85% code coverage for formatter implementation
- [ ] I have used StringBuilder for efficient string building
- [ ] I have documented all APIs and design decisions

### Precision & Compliance Validation
- [ ] I have ensured exact dimension ordering (L, M, T, I, Θ, N, J)
- [ ] I have validated format strings against examples
- [ ] I have ensured deterministic behavior
- [ ] I have documented canonical ordering rationale

### Integration Readiness Validation
- [ ] I have designed interface suitable for F-007 and F-008 consumption
- [ ] I have verified no breaking changes to existing code
- [ ] I have confirmed all existing tests still pass
- [ ] I have provided clear integration examples

---

## Success Metrics

1. **Functionality**: All acceptance criteria met and validated
2. **Test Coverage**: >85% coverage for `CompositeFormatter`
3. **Performance**: Format calls complete in <1µs (baseline measurement)
4. **Quality**: Zero regressions in existing test suite
5. **Readiness**: F-007 and F-008 teams confirm interface meets their needs

---

## Timeline

**Total Estimated Effort**: 1.5 - 2 days

- **Day 1 Morning**: Interface and options design (Phase 1) - 2 hours
- **Day 1 Afternoon**: Formatter implementation (Phase 2) - 3-4 hours
- **Day 2 Morning**: Comprehensive testing (Phase 3) - 3-4 hours
- **Day 2 Afternoon**: Documentation and validation (Phase 4) - 1-2 hours

**Note**: Timeline assumes F-002 and F-005 are complete and stable.

---

## References

### Internal References
- **E-001**: Epic — Option A Hybrid Core
- **F-002**: Dimension Signature Model (dependency)
- **F-005**: Known-Signature Naming Map (context provider)
- **F-007**: Operators Integration (consumer)
- **F-008**: Format Extensions (consumer)
- **F-009**: Optional Composite Construction (future parsing consumer)

### External References
- **SI Units**: https://www.nist.gov/pml/owm/metric-si/si-units
- **SI Derived Units**: https://www.nist.gov/pml/owm/metric-si/si-derived-units
- **Dimensional Analysis (Wikipedia)**: https://en.wikipedia.org/wiki/Dimensional_analysis
- **UCUM (Unified Code for Units of Measure)**: https://ucum.org/ (reference for unit syntax)

---

## Open Questions

### Resolved Decisions

1. **Q**: Should we use Unicode superscripts or caret notation?  
   **A**: Use caret notation (^2, ^3) initially. Unicode superscripts deferred to future iteration based on user demand.

2. **Q**: How to handle separator choice ("·" vs "*")?  
   **A**: Use middle dot "·" as default per SI conventions. Asterisk "*" as alternative for future options support.

3. **Q**: Should we format dimensionless as "" or "1"?  
   **A**: Use empty string "" initially. "1" as alternative for future options support.

4. **Q**: What base unit order should we use?  
   **A**: Canonical SI base dimension order (L, M, T, I, Θ, N, J) for deterministic, stable formatting.

### Open Questions for Review

1. **Q**: Should we provide a method to "prettify" the output with Unicode symbols?  
   **Open**: Defer decision to user feedback. ASCII formatting is universal and sufficient for MVP.

2. **Q**: How should we handle very large exponents (>9)?  
   **Open**: Current design supports any exponent value. No special handling needed initially.

3. **Q**: Should we support alternative base units (e.g., US Customary "ft", "lb")?  
   **Open**: Design supports custom base tokens; actual US Customary formatting deferred to future iteration.

---

## Notes

- This is a foundational feature; correctness and determinism prioritized over flexibility
- F-007 and F-008 will validate the interface design during implementation
- Formatter is internal API; breaking changes allowed before 1.0 if needed
- Canonical ordering ensures stable, predictable output across library versions
- Format strings are designed to be parseable for future composite construction (F-009)

---

## Revision History

| Version | Date | Author | Changes |
|---------|------|--------|---------|
| 1.0 | 2025-11-08 | Planning Team | Initial planning document created per user request |

---

**Ready for Review** ✅  
This planning document defines F-006 (Composite Unit Formatter) implementation strategy, following the structure and standards established in F-002, F-003, F-004, and F-005 planning documents. The feature provides stable, deterministic composite string generation for dimension signatures not in the known-signature map.
