# S-006: UnitDefinitions Architecture Analysis (spike)

This spike analyzes the current `UnitDefinitions` architecture and evaluates alternative approaches for storing, organizing, and accessing unit names, abbreviations, and conversion factors. The goal is to identify opportunities for improved performance, maintainability, and extensibility while maintaining backward compatibility where feasible.

## Goals

- Analyze the current `UnitDefinitions` static list architecture
- Identify performance bottlenecks and inefficiencies
- Evaluate alternative storage and access patterns
- Assess trade-offs between different architectural approaches
- Provide data-driven recommendations for optimization
- Consider impact on F-003 (Unit Normalization) and F-004 (Dimensional Math Engine)

## Non-goals

- Do not implement changes during this spike (recommendations only)
- Do not break existing public API without clear justification
- Do not introduce external dependencies unless compelling benefits demonstrated
- Do not prematurely optimize without measurement

## Background

### Current Architecture

The existing `UnitDefinitions` class uses:

**Data Structure:**
```csharp
private static IEnumerable<UnitDefinition> Definitions = new List<UnitDefinition>() { ... };
```

**Access Methods:**
- `IsValidUnit(string unit)`: Linear search through all definitions, checking aliases
- `Parse(string unit)`: Sequential search through definitions (Name first, then Aliases)
- `ParseUnitType(string unit)`: LINQ Where + Select + FirstOrDefault

**UnitDefinition Type:**
```csharp
public class UnitDefinition
{
    public string Name { get; }
    public HashSet<string> Aliases { get; }
    public decimal Factor { get; }
    public UnitTypeEnum UnitType { get; }
}
```

### Current Performance Characteristics

#### Lookup Complexity
- `IsValidUnit()`: O(n*m) where n = definitions count (~100), m = average alias count (~3-5)
- `Parse()`: O(n) for name match, O(n*m) for alias match (worst case)
- `ParseUnitType()`: O(n*m) with LINQ overhead

#### Memory Footprint
- ~100 `UnitDefinition` objects on heap
- Each with `HashSet<string>` for aliases (~500 strings total across all definitions)
- Estimated: ~50-100KB for entire catalog

#### Issues Identified
1. **Linear Search**: Every lookup traverses list sequentially
2. **Duplicate Lookups**: `IsValidUnit()` and `Parse()` both scan definitions
3. **Case Sensitivity**: Aliases use `.ToLower()` on every lookup (no caching)
4. **LINQ Overhead**: `ParseUnitType()` allocates enumerator on every call
5. **Alias Redundancy**: Same aliases stored in multiple places (e.g., "in" appears in multiple definitions)
6. **No Indexing**: No fast path for common lookups (e.g., base units)

### Usage Patterns

Based on expected usage in dimensional algebra (F-003, F-004, F-007):

**Hot Paths:**
- `Parse()` called for every `Quantity` construction with string unit
- Unit normalization in F-003 will parse units repeatedly
- Dimensional operations (F-007) will resolve units on every `*` and `/`

**Cold Paths:**
- `IsValidUnit()` for validation (less frequent)
- `ParseUnitType()` for categorization (less frequent)

**Expected Call Volume:**
- **High**: 1000s of `Parse()` calls per second in typical applications
- **Medium**: 100s of normalization calls per operation chain
- **Low**: Validation and type queries

## Evaluation Criteria

### Performance Metrics
- **Lookup Speed**: Target O(1) for common units, O(log n) acceptable for rare units
- **Memory Efficiency**: Keep total footprint <500KB
- **Startup Time**: Initialization <10ms acceptable, <1ms ideal
- **Thread Safety**: Safe for concurrent reads without locks

### Maintainability Metrics
- **Extensibility**: Easy to add new units without refactoring
- **Clarity**: Structure clear for contributors
- **Testability**: Isolated components, easy to mock/test

### Compatibility Metrics
- **API Stability**: Minimize breaking changes to existing public surface
- **Migration Cost**: Low effort to adopt new architecture
- **Backward Compatibility**: Support existing code where possible

## Alternative Architectures

### Option 1: Dictionary-Based Index (Recommended)

**Description:** Replace sequential search with dictionary lookups.

**Structure:**
```csharp
public static class UnitDefinitions
{
    // Initialization happens once at startup
    private static readonly Dictionary<string, UnitDefinition> _nameIndex;
    private static readonly Dictionary<string, UnitDefinition> _aliasIndex; // case-insensitive
    private static readonly Dictionary<UnitTypeEnum, List<UnitDefinition>> _typeIndex;
    
    static UnitDefinitions()
    {
        // Build indexes from definition list
        _nameIndex = Definitions.ToDictionary(d => d.Name, StringComparer.Ordinal);
        
        _aliasIndex = new Dictionary<string, UnitDefinition>(StringComparer.OrdinalIgnoreCase);
        foreach (var def in Definitions)
        {
            foreach (var alias in def.Aliases)
            {
                if (!_aliasIndex.ContainsKey(alias))
                    _aliasIndex[alias] = def;
            }
        }
        
        _typeIndex = Definitions.GroupBy(d => d.UnitType)
                                .ToDictionary(g => g.Key, g => g.ToList());
    }
    
    public static bool IsValidUnit(string unit)
        => _aliasIndex.ContainsKey(unit);
    
    public static UnitDefinition Parse(string unit)
    {
        if (_aliasIndex.TryGetValue(unit, out var definition))
            return definition;
        
        throw new ArgumentException($"No matching unit {unit} was found.");
    }
    
    public static UnitTypeEnum ParseUnitType(string unit)
        => _aliasIndex.TryGetValue(unit, out var def) ? def.UnitType : UnitTypeEnum.Unknown;
}
```

**Advantages:**
- ✅ O(1) lookup for all operations
- ✅ Case-insensitive comparison handled once at initialization
- ✅ No LINQ overhead in hot paths
- ✅ Thread-safe (read-only after initialization)
- ✅ Minimal API changes (same public interface)

**Disadvantages:**
- ❌ Slightly higher memory (~2-3x for indexes)
- ❌ One-time initialization cost (~5-10ms)
- ❌ Duplicate alias keys consume more memory

**Performance Impact:**
- `Parse()`: **O(n) → O(1)** (100-1000x faster for typical catalog size)
- `IsValidUnit()`: **O(n*m) → O(1)** (100-1000x faster)
- `ParseUnitType()`: **O(n*m) → O(1)** (100-1000x faster)

**Memory Impact:**
- Current: ~50-100KB
- With indexes: ~150-300KB (acceptable for modern systems)

**Migration Effort:** Low (internal refactoring only, no public API change)

---

### Option 2: Trie-Based Prefix Search

**Description:** Use a trie (prefix tree) for string matching, enabling prefix searches and autocomplete.

**Structure:**
```csharp
internal class UnitTrie
{
    private class TrieNode
    {
        public Dictionary<char, TrieNode> Children { get; } = new();
        public UnitDefinition? Definition { get; set; }
    }
    
    private readonly TrieNode _root = new();
    
    public void Insert(string alias, UnitDefinition definition) { /* ... */ }
    public UnitDefinition? Search(string alias) { /* ... */ }
    public List<string> GetMatches(string prefix) { /* ... */ }
}
```

**Advantages:**
- ✅ O(k) lookup where k = key length (independent of catalog size)
- ✅ Prefix matching for autocomplete
- ✅ Memory efficient for common prefixes (e.g., "milli-", "kilo-")

**Disadvantages:**
- ❌ More complex implementation
- ❌ Higher memory overhead for sparse data
- ❌ No significant benefit over dictionary for exact matches
- ❌ Overkill for current catalog size

**Performance Impact:**
- `Parse()`: **O(n) → O(k)** where k ≈ 5-10 characters (marginal improvement over dictionary)

**Recommendation:** **Not recommended** for current needs. Trie structure beneficial only if:
- Prefix matching is required (e.g., user autocomplete)
- Catalog grows to 10,000+ entries
- Memory is extremely constrained

---

### Option 3: Code-Generated Lookup Tables

**Description:** Generate optimized lookup code at build time using source generators or T4 templates.

**Structure:**
```csharp
// Auto-generated file: UnitDefinitions.g.cs
public static partial class UnitDefinitions
{
    private static UnitDefinition ParseGenerated(string unit)
    {
        return unit.ToLowerInvariant() switch
        {
            "in" or "inch" or "inches" or "\"" or "''" => Definitions[0],
            "ft" or "feet" or "foot" or "'" => Definitions[1],
            // ... 500 more cases
            _ => throw new ArgumentException($"No matching unit {unit} was found.")
        };
    }
}
```

**Advantages:**
- ✅ Compile-time optimization (potentially fastest)
- ✅ Zero runtime initialization cost
- ✅ Compiler can optimize switch statement (jump tables)

**Disadvantages:**
- ❌ Complex build-time tooling required
- ❌ Harder to debug (generated code)
- ❌ Difficult to extend at runtime (if ever needed)
- ❌ Large generated code file (~5000+ lines for 100 definitions × 5 aliases)

**Performance Impact:**
- `Parse()`: **O(n) → O(1)** (comparable to dictionary, possibly slightly faster)

**Recommendation:** **Not recommended** unless profiling shows dictionary overhead is significant. Adds complexity without proportional benefit.

---

### Option 4: Hybrid: Dictionary + Flyweight Pattern

**Description:** Use dictionary for fast lookup, but reduce memory by sharing common data.

**Structure:**
```csharp
// Flyweight: Intern common strings
private static string Intern(string str) => string.Intern(str);

private static readonly Dictionary<string, UnitDefinition> _aliasIndex = 
    new(StringComparer.OrdinalIgnoreCase);

// Share UnitDefinition instances across aliases
static UnitDefinitions()
{
    foreach (var def in Definitions)
    {
        foreach (var alias in def.Aliases)
        {
            _aliasIndex[Intern(alias)] = def; // Same instance, multiple keys
        }
    }
}
```

**Advantages:**
- ✅ O(1) lookup (same as Option 1)
- ✅ Reduced memory: string interning reduces duplicate strings
- ✅ Same UnitDefinition instance shared across all aliases

**Disadvantages:**
- ❌ String interning adds startup cost
- ❌ Marginal memory savings (~10-20%) compared to Option 1

**Recommendation:** **Marginal improvement** over Option 1. Consider if memory profiling shows significant duplication.

---

### Option 5: Immutable Collections (ImmutableDictionary)

**Description:** Use `System.Collections.Immutable` for thread-safe, functional data structures.

**Structure:**
```csharp
using System.Collections.Immutable;

private static readonly ImmutableDictionary<string, UnitDefinition> _aliasIndex =
    Definitions.SelectMany(d => d.Aliases.Select(a => new KeyValuePair<string, UnitDefinition>(a, d)))
               .ToImmutableDictionary(StringComparer.OrdinalIgnoreCase);
```

**Advantages:**
- ✅ Thread-safe by design
- ✅ Structural sharing (if modified in future)
- ✅ Idiomatic for functional programming

**Disadvantages:**
- ❌ Lookup ~2-3x slower than mutable dictionary (O(log n) vs O(1) in practice)
- ❌ No significant benefit for read-only scenario
- ❌ Adds NuGet dependency (`System.Collections.Immutable`)

**Recommendation:** **Not recommended**. Current architecture is already thread-safe for reads (no mutations). Immutable collections add overhead without benefit.

---

### Option 6: Separate Alias Resolution Layer

**Description:** Introduce an abstraction layer between users and raw definitions.

**Structure:**
```csharp
public interface IUnitResolver
{
    UnitDefinition Resolve(string unit);
    bool IsValid(string unit);
    UnitTypeEnum GetUnitType(string unit);
}

internal class CachedUnitResolver : IUnitResolver
{
    // Internal: uses dictionary (Option 1)
    private readonly Dictionary<string, UnitDefinition> _cache;
    
    public UnitDefinition Resolve(string unit) => _cache[unit];
}

public static class UnitDefinitions
{
    private static readonly IUnitResolver _resolver = new CachedUnitResolver();
    
    public static UnitDefinition Parse(string unit) => _resolver.Resolve(unit);
}
```

**Advantages:**
- ✅ Encapsulation: implementation can change without breaking API
- ✅ Testability: IUnitResolver can be mocked
- ✅ Extensibility: Can add custom resolvers (e.g., user-defined units)

**Disadvantages:**
- ❌ Indirection overhead (virtual call)
- ❌ Over-engineering for current scope
- ❌ Doesn't improve performance vs Option 1

**Recommendation:** **Consider for F-003 integration**. Aligns with F-003's `IUnitResolver` design. May unify resolver logic across features.

---

## Benchmark Plan

### Test Scenarios

To validate performance claims, implement micro-benchmarks:

```csharp
[MemoryDiagnoser]
public class UnitLookupBenchmarks
{
    // Scenario 1: Common unit (in, ft, m)
    [Benchmark]
    public UnitDefinition Parse_CommonUnit_Current() 
        => UnitDefinitions.Parse("in");
    
    [Benchmark]
    public UnitDefinition Parse_CommonUnit_Dictionary() 
        => DictionaryBasedDefinitions.Parse("in");
    
    // Scenario 2: Rare unit (zeptosecond)
    [Benchmark]
    public UnitDefinition Parse_RareUnit_Current() 
        => UnitDefinitions.Parse("zeptosecond");
    
    [Benchmark]
    public UnitDefinition Parse_RareUnit_Dictionary() 
        => DictionaryBasedDefinitions.Parse("zeptosecond");
    
    // Scenario 3: Alias (case-insensitive)
    [Benchmark]
    public UnitDefinition Parse_Alias_Current() 
        => UnitDefinitions.Parse("INCH");
    
    [Benchmark]
    public UnitDefinition Parse_Alias_Dictionary() 
        => DictionaryBasedDefinitions.Parse("INCH");
    
    // Scenario 4: IsValidUnit check
    [Benchmark]
    public bool IsValidUnit_Current() 
        => UnitDefinitions.IsValidUnit("meter");
    
    [Benchmark]
    public bool IsValidUnit_Dictionary() 
        => DictionaryBasedDefinitions.IsValidUnit("meter");
}
```

### Expected Results

Based on algorithmic complexity analysis:

| Operation | Current (O(n)) | Dictionary (O(1)) | Expected Improvement |
|-----------|----------------|-------------------|---------------------|
| Parse("in") — first in list | ~0.5 μs | ~0.05 μs | **10x faster** |
| Parse("zeptosecond") — last in list | ~5 μs | ~0.05 μs | **100x faster** |
| Parse("INCH") — case-insensitive | ~1 μs | ~0.05 μs | **20x faster** |
| IsValidUnit("meter") | ~2 μs | ~0.05 μs | **40x faster** |

**Memory:**
- Current: ~100 KB
- Dictionary: ~250 KB (+150 KB for indexes)

**Startup:**
- Current: ~1 ms (allocate list)
- Dictionary: ~5 ms (build indexes)

---

## Recommendation Summary

### Primary Recommendation: **Option 1 (Dictionary-Based Index)**

**Rationale:**
- **Performance**: O(1) lookups vs O(n) current (100-1000x improvement)
- **Simplicity**: Straightforward implementation, easy to understand
- **Compatibility**: Zero breaking changes to public API
- **Memory**: 2-3x increase is acceptable (~150-200KB total)
- **Maintainability**: Standard .NET dictionary, well-understood

**Implementation Approach:**
1. Keep existing `UnitDefinition` class unchanged (public API)
2. Keep existing `Definitions` list as source of truth
3. Add private static dictionaries initialized in static constructor
4. Update `Parse()`, `IsValidUnit()`, `ParseUnitType()` to use dictionaries
5. Mark old implementation with `[Obsolete]` or remove entirely

### Secondary Recommendation: **Option 6 (Resolver Layer)**

**Rationale:**
- Aligns with F-003's `IUnitResolver` design
- Enables future extensibility (user-defined units, composite units)
- Testability and mockability improved

**Conditional:** Only if F-003 proceeds and resolver abstraction is already being introduced. Don't add indirection solely for UnitDefinitions.

### Not Recommended
- **Option 2 (Trie)**: Overkill for current size, no autocomplete requirement
- **Option 3 (Code Generation)**: Complex tooling without proportional benefit
- **Option 4 (Flyweight)**: Marginal memory savings, not worth complexity
- **Option 5 (Immutable)**: Slower lookups, no benefit for read-only scenario

---

## Implementation Plan (If Proceeding with Option 1)

### Phase 1: Add Indexes (Internal Refactoring) — 2 hours

- [ ] Add private static dictionaries: `_nameIndex`, `_aliasIndex`, `_typeIndex`
- [ ] Implement static constructor to build indexes
- [ ] Add unit tests for index correctness (all definitions indexed)

### Phase 2: Update Public Methods — 1 hour

- [ ] Replace `Parse()` implementation with dictionary lookup
- [ ] Replace `IsValidUnit()` with `_aliasIndex.ContainsKey()`
- [ ] Replace `ParseUnitType()` with direct dictionary lookup
- [ ] Ensure error messages unchanged (backward compatibility)

### Phase 3: Benchmarking — 1 hour

- [ ] Implement BenchmarkDotNet tests
- [ ] Run benchmarks on representative hardware
- [ ] Validate expected performance improvements
- [ ] Document results

### Phase 4: Validation — 1 hour

- [ ] Run full test suite (all existing tests must pass)
- [ ] Add regression tests for edge cases (unknown units, null inputs)
- [ ] Memory profiling (ensure <500KB total)
- [ ] Startup time measurement (ensure <10ms)

### Total Effort: **5 hours** (0.5–1 day)

---

## Integration with F-003

If Option 1 is implemented **before** F-003:

**Benefits:**
- F-003's `UnitResolver` can directly use optimized dictionaries
- No need to rebuild alias map in F-003 (reuse `_aliasIndex`)
- Normalization pipeline gets O(1) lookups "for free"

**Approach:**
1. Expose internal dictionaries to F-003 via `internal` visibility
2. F-003's `UnitResolver` wraps existing indexes rather than duplicating

```csharp
// UnitDefinitions.cs
internal static IReadOnlyDictionary<string, UnitDefinition> AliasIndex => _aliasIndex;

// F-003 UnitResolver.cs
internal class UnitResolver
{
    private readonly IReadOnlyDictionary<string, UnitDefinition> _aliasIndex = 
        UnitDefinitions.AliasIndex;
    
    public UnitToken Normalize(string unit)
    {
        if (_aliasIndex.TryGetValue(unit, out var def))
            return new UnitToken(def.Name);
        
        throw new ArgumentException($"Unknown unit: {unit}");
    }
}
```

**Alternative:** Implement Option 1 **as part of** F-003. Avoids separate refactoring effort, but F-003 scope grows slightly.

---

## Risks and Mitigations

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| **Breaking changes** | Low | High | Keep public API identical; internal-only refactoring |
| **Memory regression** | Low | Medium | Benchmark before/after; stay under 500KB budget |
| **Startup time increase** | Low | Low | Target <10ms; lazy initialization if needed |
| **Index correctness** | Medium | High | Comprehensive unit tests; validate all definitions indexed |
| **Thread safety issues** | Low | Medium | Ensure dictionaries are read-only after initialization |

---

## Decision Criteria

**Proceed with Option 1 if:**
- Benchmarks confirm 10x+ improvement in hot paths
- Memory increase stays under 500KB
- All existing tests pass unchanged
- Startup time <10ms

**Do NOT proceed if:**
- Performance gains <5x (not worth refactoring)
- Memory increases >500KB
- Test failures or behavioral changes
- Startup time >50ms

---

## Open Questions

1. **Q**: Should we expose internal dictionaries to F-003, or have F-003 build its own?  
   **A**: TBD pending F-003 design review. Recommend exposing via `internal` to avoid duplication.

2. **Q**: Should we lazy-initialize dictionaries on first access?  
   **A**: No. Eager initialization in static constructor is simpler and avoids first-call latency.

3. **Q**: How to handle duplicate aliases (if any exist in current catalog)?  
   **A**: Validate during initialization; throw exception if duplicate found. Prevents silent bugs.

4. **Q**: Should `_nameIndex` and `_aliasIndex` be separate, or merged into one?  
   **A**: Merged into `_aliasIndex` (name is just another alias). Simplifies code.

5. **Q**: Future: support for runtime unit additions (user-defined units)?  
   **A**: Out of scope for S-006. If required, use `ConcurrentDictionary` or builder pattern.

---

## Success Metrics

### Performance Goals
- [ ] `Parse()` completes in <0.1 μs (dictionary lookup)
- [ ] `IsValidUnit()` completes in <0.1 μs
- [ ] Startup time <10ms
- [ ] Memory footprint <500KB

### Quality Goals
- [ ] All existing tests pass unchanged
- [ ] No public API breaking changes
- [ ] Zero new external dependencies
- [ ] Code coverage ≥85%

### Documentation Goals
- [ ] Architecture decision documented (this spike)
- [ ] Code comments explain indexing strategy
- [ ] CHANGELOG entry if API changes

---

## Related Documents

- **Feature F-003**: `.github/features/F-003.md` — Unit Normalization and Alias Resolver
- **Feature F-004**: `.github/features/F-004.md` — Dimensional Math Engine (planned)
- **Epic E-001**: `.github/features/E-001.md` — Option A Hybrid Core
- **Repository**: `.github/copilot-instructions.md` — Tare-specific rules

---

## Findings (To Be Completed After Benchmarking)

### Summary

_[Will be filled in after spike execution]_

### Recommendation

_[Will be filled in after benchmarking]_

**Decision**: `[ ] Implement Option 1 (Dictionary)` or `[ ] Keep current architecture`

### Supporting Data

_[Benchmark results table to be added]_

| Metric | Current | Option 1 | Improvement |
|--------|---------|----------|-------------|
| Parse (common) | TBD | TBD | TBD |
| Parse (rare) | TBD | TBD | TBD |
| IsValidUnit | TBD | TBD | TBD |
| Memory (KB) | TBD | TBD | TBD |
| Startup (ms) | TBD | TBD | TBD |

---

**Status**: Ready to execute benchmarking phase  
**Next Action**: Implement benchmark suite and measure current vs. Option 1 performance
