# E-001: Epic — Option A Hybrid Core (Dimension vectors + catalog naming)

This epic plans the delivery of S-004 Option A: a dependency-free internal dimensional algebra engine (signature vectors + rational factors) integrated with Tare’s existing catalog and parsing/formatting, while retaining a simple `Quantity` API.

---

## Mandatory thinking (DDD/.NET guidelines)

### 1) Analysis

- Applicable patterns
  - DDD Value Objects: `Quantity`, `UnitDefinition`, `DimensionSignature`, `Rational` are immutable value objects.
  - Domain Service: Internal "Dimensional Engine" combines/simplifies dimensions and computes conversions.
  - SOLID
    - SRP: `Quantity` remains a value type; algebra/formatting are delegated to focused helpers/services.
    - OCP: New unit families and naming rules added via small maps/config without modifying core behaviors.
    - DIP: Public surface depends on abstractions (internal provider interface for math engine) rather than concretions.
- Layers affected
  - Domain: Value objects (`Quantity`, signatures, rationals) and domain service for algebra.
  - Application/Infrastructure: N/A in this library context; tests and docs updated.
- Ubiquitous language
  - Quantity, Unit, Alias, Dimension (L, M, T, …), Signature, Known family (e.g., Torque), Composite unit string.
- Security & compliance
  - No user secrets. Maintain deterministic, locale-stable formatting.
  - Precision: decimal used for values; exact rational factors mitigate drift.

### 2) Review against guidelines

- Aggregate boundaries: `Quantity` as a value object; no persistence/transactions; consistency ensured within value operations.
- SRP: `Quantity` focused on value semantics; algebra delegated internally.
- Domain rules encapsulated: Incompatible add/sub guarded; multiply/divide compute signatures and factors.
- Tests: `MethodName_Condition_ExpectedResult()` pattern for unit tests.
- Ubiquitous language consistent across API/docs.

### 3) Implementation plan (validation)

- Entities/value objects
  - `DimensionSignature` (internal, readonly struct): integer exponents over base dims (L, M, T, I, Θ, N, J).
  - `Rational` (internal, readonly struct): exact factor numerator/denominator; normalization (sign, gcd).
  - `UnitKey`/`UnitToken` (internal): normalized base unit symbol tokens used for signature resolution and formatting.
- Domain service/interfaces
  - `IDimensionalMath` (internal): combine signatures and compute resultant factor on `*` and `/`.
  - `KnownSignatureMap` (internal): signature → canonical family and preferred unit names (e.g., Energy→`Nm`).
  - `UnitResolver` (internal): maps between unit strings, aliases, and factors; reuses `UnitDefinitions`.
- Tests
  - Unit tests for algebra, naming, parsing/formatting; follow naming convention.

---

## Architecture overview

- Public API remains `readonly struct Quantity(decimal Value, string Unit)` (exact signature as today).
- Operators
  - `*` and `/` between `Quantity` instances now route to `IDimensionalMath` to:
    1) Normalize operands to base (canonical) factors (rational).
    2) Add/subtract exponent vectors to form the resulting `DimensionSignature`.
    3) Compute resulting factor (rational) and decimal value.
    4) Name result via `KnownSignatureMap` or canonical composite formatting.
- Naming policy
  - SI-first canonical unit selection for known signatures; alias-aware. Prefer the term "US Customary" instead of "Imperial" in documentation and configuration.
  - Composite formatter yields stable strings: numerator and denominator ordered, `*` and `/`, `^n` exponents.
- Parsing
  - Keep `Quantity.Parse("36in")` behavior.
  - Extend formatting target acceptance: `q.Format("lbf*in")` and known aliases (`Nm`).
  - Composite construction: defer accepting composite units in `Parse` for the first iterations; design remains ready to enable this later (tracked in F-009).

---

## Broad workstreams (features to be split into F-00x)

- S-005 — Decimal precision evaluation (spike)
  - Deliver: Test matrix measuring `decimal` precision in dimensional algebra scenarios; data-driven recommendation.
  - Acceptance: Clear decision documented: continue with `decimal` or implement `Rational` (F-001).
  - Timeline: 2.75 days; must complete before F-002 implementation begins.

- F-001 — Core rational arithmetic (DEFERRED pending S-005)
  - Deliver: `Rational` value object with normalization, multiply/divide, to/from decimal bridging policies.
  - Acceptance: Exact factor math; unit tests for canonical conversions (e.g., mile↔inch 63360).
  - Status: Implement only if S-005 demonstrates unacceptable `decimal` precision loss.

- F-002 — Dimension signature model
  - Deliver: `DimensionSignature` struct (L,M,T,I,Θ,N,J), add/subtract, equality/comparison, hashing.
  - Acceptance: Correct signatures for Length/Area/Volume/Time/Force/Energy and simple compositions.

- F-003 — Unit normalization and alias resolver
  - Deliver: Normalization pipeline leveraging `UnitDefinitions` (aliases → canonical tokens; factor to base).
  - Acceptance: `inch`/`in`, `pound force`/`lbf` normalize identically; factors match current conversions.

- F-004 — Dimensional math engine
  - Deliver: `IDimensionalMath` + implementation combining signatures and factors on `*` and `/`.
  - Acceptance: Test matrix examples produce correct values/signatures; scalar ops unchanged.

- F-005 — Known-signature naming map
  - Deliver: Signature→family map with preferred units (Torque, Energy, Pressure, Area, Velocity as initial set).
  - Acceptance: Results display as `Nm`/`Pa`/`m²` where applicable; fallback to composite for unknowns.

- F-006 — Composite unit formatter
  - Deliver: Stable composite string builder with canonical ordering and exponent formatting.
  - Acceptance: `(lbf*in^3)/s^2` formatting stable and idempotent.

- F-007 — Operators integration (Quantity×Quantity, Quantity÷Quantity)
  - Deliver: Wire public operators to engine; maintain existing behaviors for add/sub and scalar operators.
  - Acceptance: Back-compat tests pass; new algebra tests pass.

- F-008 — Format extensions (targets)
  - Deliver: Allow `q.Format("lbf*in")` and aliases; internal mapping to factors/signatures.
  - Acceptance: Formatting to composite/known targets yields expected value and unit.

- F-009 — Composite construction (always-on)
  - Deliver: Ability to construct quantities using composite unit strings.
  - Acceptance: `Quantity.Parse(10, "lbf*in")` and `Quantity.Parse("200 Nm")` work correctly.
  - Status: ✓ Completed

- F-010 — Composite unit operator support
  - Deliver: Enable multiplication and division operators to work with composite units by enhancing `UnitResolver` to handle composites.
  - Acceptance: Quantities with composite units can participate in dimensional arithmetic; `Quantity("2 m*s") / Quantity("0.5 s")` returns correct result.
  - Status: Planned (High Priority - completes F-009 composite unit support)

- F-011 — Performance & caching (formerly F-010)
  - Deliver: Cache normalized units, common signature results; microbenchmarks for hot paths.
  - Acceptance: No significant regressions vs baseline; allocation budget documented.

- F-012 — Error handling and diagnostics (formerly F-011)
  - Deliver: Clear exceptions for incompatible add/sub, unknown units, divide-by-zero; message consistency.
  - Acceptance: Error texts stable and tested.

- F-013 — API helpers (additive) (formerly F-012)
  - Deliver: `IsKnown()`, `Signature()`, `Normalize(preferredUnit?)` (optional but planned).
  - Acceptance: Helpers function without breaking existing code.

- F-014 — Documentation & migration notes (formerly F-013)
  - Deliver: README and docs updates (parsing, formatting, algebra examples); CHANGELOG entry; rationale.
  - Acceptance: Docs reflect new capabilities; examples compile.

- F-015 — Test suite expansion (formerly F-014)
  - Deliver: Full test matrix (from S-004) + edge cases; naming convention enforced.
  - Acceptance: All tests green across both TFMs.

- F-016 — Precision & formatting integration (built-in .NET) (formerly F-015)
  - Deliver: Expose number precision and formatting options for string output using built-in .NET mechanisms to avoid custom parsing/format logic.
    - Implement/extend `IFormattable` on `Quantity` for `ToString(string? format, IFormatProvider? provider)`.
    - On net7.0, conditionally implement `ISpanFormattable` for allocation-friendly formatting paths; fall back to `IFormattable` on netstandard2.0.
    - Support standard/custom numeric format strings for the value (e.g., "G", "F2", "N4"), and flow an `IFormatProvider`/culture.
    - Keep unit rendering policy intact (append unit or composite signature); do not reimplement numeric formatting.
    - Ensure `Quantity.Format("unit-spec", formatProvider?, valueFormat?)` can delegate numeric formatting to .NET, while selecting the requested unit.
    - Fluent pattern: support chaining unit selection with precision using existing `As(string)` + `ToString(...)`, e.g., `q.As("in").ToString("N4", CultureInfo.InvariantCulture)` and `q.As("lbf*in").ToString("F3")`.
  - Acceptance:
    - `ToString("F3", InvariantCulture)` yields value with 3 decimals and correct unit; composite units respected.
    - Culture-specific separators and grouping reflect the provided `IFormatProvider`.
    - net7.0 path uses span-based formatting in hot paths (measured), netstandard path remains correct.
    - No behavior regression for existing `Format(...)`; new precision options are additive.

- F-017 — Format overloads for current unit + provider (formerly F-016)
  - Deliver: Overloads to format using the quantity's current unit without specifying the unit explicitly; and provider-aware overloads.
    - `string Format(string valueFormat)` → uses `this.Unit` for output (e.g., `q.Format("N4")`).
    - `string Format(string valueFormat, IFormatProvider provider)` → provider-aware current-unit formatting.
    - Optional sugar: allow fluent `q.As("in").Format("N4")` as shorthand for `q.Format("in", "N4")`.
  - Acceptance:
    - `q.Format("N4")` formats with the quantity's current unit and .NET numeric formatting.
    - `q.Format("N4", CultureInfo.InvariantCulture)` respects the provider.
    - `q.As("in").Format("N4")` equals `q.Format("in", "N4")`.
    - Back-compat: existing `Format(unit, format)` unchanged.

- F-018 — Preferred Units Configuration (deferred from F-013)
  - Deliver: Runtime configuration of preferred units for `ToCanonical()` method; allow users to override SI-first policy with US Customary or custom preferences.
    - **Option A**: `ToCanonical(UnitSystemPreference preference)` method overload for per-call configuration
    - **Option B**: `QuantityConfiguration.SetPreferredUnits(...)` static class for global configuration
    - **Option C**: Hybrid approach with both global defaults and per-call overrides
  - Acceptance:
    - Users can configure preferred units at runtime (SI-first, US Customary-first, or custom mapping)
    - `ToCanonical()` respects configured preferences
    - Default SI-first policy preserved for backward compatibility
    - No breaking changes to existing API
  - Status: Deferred from F-013
  - Decision Rationale (from F-013, 2025-11-12):
    - YAGNI principle - no user demand yet; avoid speculative features
    - Keeps F-013 focused on core introspection and normalization helpers
    - Can add later without breaking changes (overload or new method)
    - Current SI-first policy serves majority of users
    - If demand exists, F-018 provides comprehensive configuration API

---

## Acceptance criteria (epic level)

- Multiplication/division between `Quantity` values produce dimensionally correct results with cancellation.
- Known signatures resolve to preferred unit names; unknowns format to stable composite signatures.
- Decimal value precision preserved; conversions use rational factors without cumulative drift.
- Parsing and formatting remain user-friendly; composite format targets supported.
- No mandatory external dependencies added; TFMs unchanged.
- All existing tests remain green; new tests cover algebra and formatting.

---

## Risks and mitigations

- Naming expectations (SI-first vs domain preferences) → Configurable preferences; default SI-first. Use "US Customary" terminology in user-facing docs and options.
- Parser complexity for composites → Phase composite construction behind a flag; start with format targets.
- Performance regressions → Benchmarks and caches; keep structs readonly and allocations minimal.
- API creep → Keep helpers optional and additive; avoid changing existing method signatures.

---

## Files likely impacted (subject to refinement)

- `src/Quantity.cs` — Operator wiring; optional helper methods; XML docs.
- `src/UnitDefinitions.cs` — Alias normalization hooks; ensure factor exposure suitable for rationals.
- `src/Extensions.cs` — Formatting extensions (targets, composite output) if applicable.
- New internal files (engine):
  - `src/Internal/Units/Rational.cs`
  - `src/Internal/Units/DimensionSignature.cs`
  - `src/Internal/Units/IDimensionalMath.cs`
  - `src/Internal/Units/DimensionalMath.cs`
  - `src/Internal/Units/KnownSignatureMap.cs`
  - `src/Internal/Units/CompositeFormatter.cs`

Note: Filenames are indicative; we’ll align with existing repo conventions.

---

## Test plan (examples; full set in F-014)

- Multiply_LengthByForce_ReturnsTorque()
- Divide_AreaByLength_ReturnsLength()
- Divide_UnitBySameUnit_ReturnsScalar()
- Convert_TorqueNm_ToLbfIn_WithinTolerance()
- Compose_VolumeOverLength_ReturnsArea()
- ParseAliases_InchAndPoundForce_NormalizeToInAndLbf()
- FormatComposite_ComplexSignature_IsStable()
- TemperatureDifference_CelsiusMinusCelsius_WorksPerPolicy()

---

## Delivery approach & timeline

- Phase 0 (Precision evaluation, ~3 days): S-005 spike to validate `decimal` sufficiency; determines if F-001 needed.
- Phase 1 (POC, ~1 week): F-002..F-007 minimal path to algebra and naming; basic tests. Use `decimal` unless S-005 indicates otherwise.
- Phase 2 (~1–2 weeks): F-008..F-012 usability, performance, diagnostics, helpers.
- Phase 3 (~1 week): F-013..F-014 docs and comprehensive tests.

**Note**: If S-005 determines `Rational` (F-001) is required, add 2 days to Phase 1 timeline.

Dates depend on availability; phases can overlap.

---

## Quality checklist (verification)

- Domain design
  - I have verified that value objects model the domain concepts and responsibilities are clear.
  - I have confirmed consistent terminology (Quantity, Unit, Signature, Known/Unknown).
  - I have verified SOLID adherence, especially SRP and DIP for the engine.
  - I have validated domain rules for dimensional algebra and compatibility.
- Implementation quality
  - I have planned comprehensive tests with `MethodName_Condition_ExpectedResult()` naming.
  - I have considered performance and memory; caches and readonly structs planned.
  - I have documented decisions and exposed no external dependencies.
- Precision & compliance
  - I have ensured decimal precision for values and exact rational factors for conversions.
  - I have confirmed deterministic, locale-stable formatting.

---

## Decisions recorded

- Base dimensions at launch: include all SI base dimensions (L, M, T, I, Θ, N, J).
- Naming policy: default SI-first; refer to the alternative system as "US Customary" rather than "Imperial" in user-facing text and configuration.
- Parse composite units: not in the first iterations; keep design and hooks to enable later (tracked under F-009).
- **Decimal vs. Rational** (2025-11-07): Defer custom `Rational` type (F-001) pending precision evaluation (S-005). MVP will use existing `decimal` factors. If S-005 demonstrates precision loss exceeding 0.001% in common scenarios, F-001 will be implemented. This approach:
  - Delivers MVP faster (~300-400 LOC saved)
  - Validates architecture before premature optimization  
  - Allows incremental `Rational` addition if needed
  - Leverages .NET's hardware-accelerated `decimal` operations

---

## References

### Internal References
- **S-001, S-002, S-003, S-004**: Spike investigations informing this epic
- **F-001 through F-017**: Feature implementations within this epic

### External References
- **Dimensional Analysis (Wikipedia)**: https://en.wikipedia.org/wiki/Dimensional_analysis
- **Types and Units of Measure (Kennedy Paper)**: http://typesatwork.imm.dtu.dk/material/TaW_Paper_TypesAtWork_Kennedy.pdf
- **Frink Programming Language**: https://frinklang.org/
- **Frink Units Database**: https://frinklang.org/frinkdata/units.txt
