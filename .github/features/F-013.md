# F-013: API Helpers (Additive)

**Status**: Planned  
**Epic**: E-001 (Option A Hybrid Core)  
**Priority**: P2 (Should)  
**Effort**: M (2‚Äì3 days)  
**Dependencies**: F-011 (Performance & Caching), F-012 (Error Handling)

---

## TL;DR ‚Äî Quick Reference

**Goal**: Expose additive helper methods on `Quantity` for introspection, diagnostics, and advanced use cases

**Effort**: 2-3 days (M)

**Impact**: Better developer experience, enables advanced scenarios, zero breaking changes

### What Gets Added

**üîç Introspection Helpers**  
Access internal dimension information, check if unit is known, inspect signatures  
**Time**: 6-8 hours

**üîß Normalization Helpers**  
Convert quantities to base SI units or preferred canonical units  
**Time**: 4-6 hours

**üìä Diagnostics Helpers**  
Expose cache statistics and performance metrics for optimization  
**Time**: 2-4 hours

**‚úÖ Test Coverage**  
Comprehensive tests for all new public APIs  
**Time**: 4-6 hours

### Quick Command Reference

```bash
# Build project
dotnet build

# Run all tests
dotnet test

# Run specific test category
dotnet test --filter "FullyQualifiedName~QuantityHelperTests"

# Check coverage (if tool installed)
dotnet-coverage collect -f cobertura -o coverage.xml dotnet test
```

---

## Mandatory Thinking (DDD/.NET Guidelines)

### 1) Analysis

**Applicable Patterns**:
- **Value Object Extensions**: Helper methods maintain immutability; all return new instances
- **SOLID Principles**:
  - **SRP**: Each helper has single, focused responsibility
  - **OCP**: Helpers are additive; existing behavior unchanged
  - **ISP**: APIs are focused and minimal; no forced dependencies
  - **DIP**: Helpers use existing internal abstractions
- **Ubiquitous Language**: All APIs use consistent terminology (Signature, Normalize, Known, Canonical, Base)

**Layers Affected**:
- **Domain**: Extension methods on `Quantity` value object
- **Application**: N/A (library context)
- **Infrastructure**: Diagnostic helpers may expose internal cache stats

**Security & Compliance**:
- No sensitive data exposed in diagnostics
- All helpers are read-only queries; no state mutation
- Deterministic behavior for audit trails

### 2) Review Against Guidelines

**Aggregate Boundaries**: Helpers respect `Quantity` as immutable value object

**SRP Compliance**: Each helper method has focused, single purpose

**Domain Rules Encapsulated**: Helpers delegate to existing internal services; no business logic duplication

**Tests**: All public helpers tested using `MethodName_Condition_ExpectedResult()` pattern

**Ubiquitous Language**: Consistent terminology throughout API surface

### 3) Implementation Plan Validation

**Files to Create/Modify**:
- Modify: `src/Quantity.cs` (add helper methods region)
- Modify: `src/Extensions.cs` (add optional extension methods)
- Create: `tests/QuantityHelperTests.cs` (comprehensive test suite)
- Optional Create: `src/Diagnostics/QuantityDiagnostics.cs` (if diagnostics warrant separate class)

**Tests**:
- All helpers tested with catalog units
- All helpers tested with composite units
- Edge cases: dimensionless, unknown signatures, null guards
- Performance: helpers should not significantly impact hot paths

**Error Handling Strategy**:
- Return false/null for query operations that fail gracefully
- Throw specific exceptions only for programmer errors (null arguments)
- Consistent with F-012 error handling standards

---

## Description

Provide additive helper methods on `Quantity` and related types to support:
1. **Introspection**: Inspect dimension signatures, check if unit is recognized
2. **Normalization**: Convert to base SI units or preferred canonical representation
3. **Diagnostics**: Access cache performance metrics for optimization
4. **Advanced Scenarios**: Enable power users to work with internal representations

All helpers are additive (no breaking changes) and follow established .NET conventions.

---

## User Stories

### User Story 1: Dimension Introspection

**As a** developer building a physics engine using Tare  
**I want** to inspect the dimensional signature of quantities at runtime  
**So that** I can validate dimensional consistency and display dimension information to users

**Example**:
```csharp
var force = Quantity.Parse("10 N");
var signature = force.GetSignature();  
// DimensionSignature: L=1, M=1, T=-2

if (force.IsKnownDimension())
{
    var description = force.GetDimensionDescription();  
    // "Force"
}
```

### User Story 2: Unit Normalization

**As a** data scientist standardizing measurement data  
**I want** to convert all quantities to canonical SI base units  
**So that** I can perform consistent analysis across datasets

**Example**:
```csharp
var pressure = Quantity.Parse("14.7 psi");
var normalized = pressure.ToBaseUnits();  
// Quantity(101352.9, "Pa")

var torque = Quantity.Parse("1500 lbf*in");
var canonical = torque.ToCanonical();  
// Quantity(169.5, "Nm")  - uses preferred unit from KnownSignatureMap
```

### User Story 3: Performance Diagnostics

**As a** performance engineer optimizing hot paths  
**I want** access to cache hit rates and performance metrics  
**So that** I can identify and optimize performance bottlenecks

**Example**:
```csharp
var stats = QuantityDiagnostics.GetCacheStatistics();
Console.WriteLine($"Composite parse cache: {stats.CompositeParserHitRate:P}");
Console.WriteLine($"Unit resolver cache: {stats.UnitResolverHitRate:P}");
// Outputs: "Composite parse cache: 87.5%"
//          "Unit resolver cache: 92.3%"
```

### User Story 4: Advanced Unit Resolution

**As a** developer building a unit converter UI  
**I want** to check if a unit string is valid before using it  
**So that** I can provide immediate feedback to users without catching exceptions

**Example**:
```csharp
string userInput = "xyz";  // Invalid unit

if (Quantity.ContainsValidUnit(userInput))
{
    var q = Quantity.Parse(userInput);  // Can be "10 m" or just "m"
    // ... use quantity
}
else
{
    ShowError($"Unknown unit: {userInput}");
}
```

### User Story 5: Unit Discovery for UI

**As a** developer building a unit converter dropdown  
**I want** to get a list of all valid units for a specific dimension  
**So that** I can populate combo boxes and selection lists for users

**Example**:
```csharp
// Option 1: Get units by UnitType
var lengthUnits = Quantity.GetUnitsForType(UnitTypeEnum.Length);
// Returns: ["m", "cm", "mm", "km", "in", "ft", "yd", "mi", ...]

// Option 2: Get units by DimensionSignature
var forceSignature = new DimensionSignature(1, 1, -2, 0, 0, 0, 0);  // L¬πM¬πT‚Åª¬≤
var forceUnits = Quantity.GetUnitsForSignature(forceSignature);
// Returns: ["N", "lbf", "kgf", ...]

// Populate dropdown
foreach (var unit in lengthUnits)
{
    comboBox.Items.Add(unit);
}
```

---

## Acceptance Criteria

### 1. Introspection Helpers

- ‚úÖ `GetSignature()` returns `DimensionSignature` for any quantity
- ‚úÖ `IsKnownDimension()` returns true if signature is in `KnownSignatureMap`
- ‚úÖ `GetDimensionDescription()` returns human-readable description (e.g., "Force", "Energy")
- ‚úÖ `GetDimensionDescription()` returns null or throws for unknown dimensions (decision needed)
- ‚úÖ Works correctly for catalog units, composite units, and dimensionless quantities

### 2. Normalization Helpers

- ‚úÖ `ToBaseUnits()` converts to SI base representation (m, kg, s, A, K, mol, cd)
- ‚úÖ `ToCanonical()` converts to preferred unit from `KnownSignatureMap` when known
- ‚úÖ `ToCanonical()` preserves unit for unknown signatures (no-op behavior)
- ‚úÖ Normalization preserves numeric value correctness (tested to precision limits)
- ‚úÖ Both methods return new `Quantity` instances (immutability preserved)

### 3. Unit Validation Helpers

- ‚úÖ `ContainsValidUnit(string)` static method returns true for catalog and composite units
- ‚úÖ `ContainsValidUnit` handles both "12 in" (with factor) and "in" (unit only) formats
- ‚úÖ `ContainsValidUnit` returns false for null, empty, malformed, or unknown units
- ‚úÖ `ContainsValidUnit` does not throw exceptions (query semantics)
- ‚úÖ Performance: `ContainsValidUnit` is fast (uses existing caches)

### 4. Unit Discovery Helpers

- ‚úÖ `GetUnitsForType(UnitTypeEnum)` returns list of unit names for a given dimension type
- ‚úÖ `GetUnitsForSignature(DimensionSignature)` returns list of compatible units for a signature
- ‚úÖ Both methods return catalog units only (not composite units)
- ‚úÖ Results suitable for populating UI dropdowns and selection lists
- ‚úÖ Performance: Methods use cached type index (O(1) lookup)

### 5. Diagnostics (Optional/Deferred)

- ‚úÖ `QuantityDiagnostics.GetCacheStatistics()` returns performance metrics
- ‚úÖ Cache stats include hit/miss counts and rates for major caches
- ‚úÖ Diagnostics are read-only; no ability to clear or modify caches via public API
- ‚è∏Ô∏è Advanced diagnostics (memory usage, operation counts) deferred to user demand

### 5. API Quality Standards

- ‚úÖ All public methods have comprehensive XML documentation
- ‚úÖ All methods follow .NET naming conventions (PascalCase, clear intent)
- ‚úÖ All methods have corresponding tests using `MethodName_Condition_ExpectedResult()` pattern
- ‚úÖ Error handling consistent with F-012 standards
- ‚úÖ Zero breaking changes to existing API surface

---

## Technical Approach

### Phase 1: Introspection API (Core)

**Add helper methods to `Quantity` struct**

#### GetSignature() Method

**Purpose**: Expose the internal `DimensionSignature` for advanced scenarios

**Design**:
```csharp
/// <summary>
/// Gets the dimension signature of this quantity, representing its dimensional composition
/// using exponents over the seven SI base dimensions (L, M, T, I, Œò, N, J).
/// </summary>
/// <returns>
/// The dimension signature. For catalog units, resolves via UnitResolver.
/// For composite units, uses the cached signature from CompositeParser.
/// </returns>
/// <remarks>
/// Examples:
/// - "m" ‚Üí Length(1), others(0)
/// - "N" ‚Üí Length(1), Mass(1), Time(-2), others(0)
/// - "Nm" ‚Üí Length(2), Mass(1), Time(-2), others(0)
/// </remarks>
public DimensionSignature GetSignature()
{
    // Fast path: catalog unit
    if (UnitDefinitions.IsValidUnit(Unit))
    {
        var resolved = UnitResolver.Instance.Resolve(Unit);
        return resolved.Signature;
    }
    
    // Slow path: composite unit
    var parser = CompositeParser.Instance;
    if (parser.TryParse(Unit, out var signature, out _))
    {
        return signature;
    }
    
    // Fallback: dimensionless (shouldn't reach here for valid quantities)
    return DimensionSignature.Dimensionless;
}
```

**Considerations**:
- `DimensionSignature` is currently internal; decision needed: make public or create DTO?
- **Recommendation**: Make `DimensionSignature` public readonly struct
  - Already well-designed value type
  - No breaking changes (additive)
  - Enables advanced user scenarios
  - Future-proof for F-014+ features

#### IsKnownDimension() Method

**Purpose**: Check if quantity's dimension is recognized in the `KnownSignatureMap`

**Design**:
```csharp
/// <summary>
/// Determines whether this quantity's dimension is recognized in the known signature map.
/// Known dimensions include standard physical quantities like Force, Energy, Pressure, etc.
/// </summary>
/// <returns>
/// True if the dimension is known and has a preferred canonical unit; otherwise, false.
/// </returns>
/// <remarks>
/// Known dimensions:
/// - Base: Length, Mass, Time, Electric Current, Temperature, Amount of Substance, Luminous Intensity
/// - Geometric: Area, Volume
/// - Kinematic: Velocity, Acceleration, Jerk
/// - Dynamic: Force, Momentum, Energy, Power, Pressure, Torque
/// - And more (see KnownSignatureMap for complete list)
/// </remarks>
public bool IsKnownDimension()
{
    var signature = GetSignature();
    return KnownSignatureMap.Instance.IsKnown(signature);
}
```

#### GetDimensionDescription() Method

**Purpose**: Get human-readable description of the quantity's dimension

**Design Option A (Nullable)**:
```csharp
/// <summary>
/// Gets a human-readable description of this quantity's dimension.
/// Returns null if the dimension is not recognized.
/// </summary>
/// <returns>
/// Description string (e.g., "Force", "Energy", "Pressure") or null if unknown.
/// </returns>
public string? GetDimensionDescription()
{
    var signature = GetSignature();
    if (KnownSignatureMap.Instance.TryGetPreferredUnit(signature, out var preferred))
    {
        return preferred.Description;
    }
    return null;
}
```

**Design Option B (Exception)**:
```csharp
/// <summary>
/// Gets a human-readable description of this quantity's dimension.
/// </summary>
/// <returns>Description string (e.g., "Force", "Energy", "Pressure").</returns>
/// <exception cref="InvalidOperationException">
/// Thrown when the dimension is not recognized in the known signature map.
/// </exception>
public string GetDimensionDescription()
{
    var signature = GetSignature();
    if (KnownSignatureMap.Instance.TryGetPreferredUnit(signature, out var preferred))
    {
        return preferred.Description;
    }
    throw new InvalidOperationException(
        "Cannot get dimension description for unknown dimension. " +
        $"Use IsKnownDimension() to check before calling. Signature: {signature}");
}
```

**Recommendation**: **Option A (Nullable)**
- More flexible; caller decides how to handle unknowns
- Consistent with TryParse patterns elsewhere
- Pair with `IsKnownDimension()` for explicit checks

### Phase 2: Normalization API

#### ToBaseUnits() Method

**Purpose**: Convert quantity to SI base unit representation

**Design**:
```csharp
/// <summary>
/// Converts this quantity to its representation in SI base units.
/// For quantities with composite dimensions, returns the composite base form.
/// </summary>
/// <returns>
/// A new quantity with the same magnitude expressed in SI base units.
/// Base units: m (length), kg (mass), s (time), A (current), K (temperature), 
/// mol (substance), cd (luminous intensity).
/// </returns>
/// <remarks>
/// Examples:
/// - 10 km ‚Üí 10000 m
/// - 5 N ‚Üí 5 kg*m/s^2
/// - 100 psi ‚Üí 689475.7 kg/(m*s^2)
/// </remarks>
public Quantity ToBaseUnits()
{
    var signature = GetSignature();
    
    // Get base value by converting through factor
    var baseValue = Value * Factor;
    
    // Format signature as composite base unit string
    var formatter = CompositeFormatter.Instance;
    var baseUnitString = formatter.Format(signature);
    
    return new Quantity(baseValue, baseUnitString);
}
```

**Considerations**:
- For dimensionless, returns scalar (empty unit string)
- For simple dimensions (Length, Mass), returns canonical SI (m, kg)
- For composites, returns algebraic notation (kg*m/s^2)

#### ToCanonical() Method

**Purpose**: Convert to preferred canonical unit when dimension is known

**Design**:
```csharp
/// <summary>
/// Converts this quantity to its canonical (preferred) unit representation.
/// Uses the known signature map to determine the preferred unit for recognized dimensions.
/// For unknown dimensions, returns the quantity unchanged.
/// </summary>
/// <returns>
/// A new quantity with the same magnitude expressed in the canonical unit.
/// For unknown dimensions, returns a copy of this quantity.
/// </returns>
/// <remarks>
/// Canonical units follow SI-first policy:
/// - Force ‚Üí N (newton)
/// - Energy ‚Üí J (joule) or Nm (newton-meter)
/// - Pressure ‚Üí Pa (pascal)
/// - Torque ‚Üí Nm (newton-meter)
/// - Power ‚Üí W (watt)
/// </remarks>
public Quantity ToCanonical()
{
    var signature = GetSignature();
    
    if (!KnownSignatureMap.Instance.TryGetPreferredUnit(signature, out var preferred))
    {
        // Unknown dimension - return copy unchanged
        return this;
    }
    
    // Convert to preferred unit using existing Format/As logic
    return this.As(preferred.Symbol);
}
```

**Alternative Design (Extension Method)**:
- Could implement as extension in `Extensions.cs`
- **Recommendation**: Keep as instance method for discoverability

**Note on Preferred Unit Configuration**:
- Current design uses hardcoded `KnownSignatureMap` with SI-first policy
- Future enhancement (deferred to F-018): Allow runtime configuration of preferred units
- Potential API: `ToCanonical(UnitSystemPreference preference)` or global setting
- Decision: Keep F-013 simple; defer customization based on user demand
- See F-018 in E-001 epic for full planned feature

### Phase 3: Validation and Discovery API

#### ContainsValidUnit() Static Method

**Purpose**: Check if string contains a valid unit (with or without factor) without throwing

**Design**:
```csharp
/// <summary>
/// Determines whether the specified string contains a valid unit.
/// Handles both formats: unit-only ("m", "lbf") and value-with-unit ("12 in", "5.5 kg").
/// This method does not throw exceptions.
/// </summary>
/// <param name="input">The string to validate (e.g., "m", "12 in", "lbf*in").</param>
/// <returns>
/// True if the string contains a valid catalog unit or a well-formed composite unit; otherwise, false.
/// Returns false for null, empty, or whitespace strings.
/// </returns>
/// <remarks>
/// Use this method to validate user input before constructing quantities.
/// 
/// Validation process:
/// 1. Extract unit portion from input (handles "12 in" ‚Üí "in")
/// 2. Check if unit is in catalog (fast path, O(1))
/// 3. If not in catalog, try parsing as composite unit (slow path)
/// 
/// Implementation Note:
/// Reuses the same static UnitsPattern regex from Quantity.Parse for consistency
/// and performance (avoids creating new Regex instances on each call).
/// 
/// Examples:
/// - ContainsValidUnit("m") ‚Üí true (catalog unit)
/// - ContainsValidUnit("12 in") ‚Üí true (extracts "in")
/// - ContainsValidUnit("lbf*in") ‚Üí true (composite unit)
/// - ContainsValidUnit("xyz") ‚Üí false (unknown)
/// </remarks>
public static bool ContainsValidUnit(string? input)
{
    // Null or empty check
    if (string.IsNullOrWhiteSpace(input))
        return false;
    
    // Extract unit portion if input contains numeric value
    // Reuse the same static UnitsPattern from the Quantity class for consistency
    string unitPortion = input;
    
    if (UnitsPattern.IsMatch(input))
    {
        unitPortion = UnitsPattern.Match(input).Value.Trim();
    }
    
    // Fast path: catalog unit
    if (UnitDefinitions.IsValidUnit(unitPortion))
        return true;
    
    // Slow path: try parsing as composite
    var parser = CompositeParser.Instance;
    return parser.TryParse(unitPortion, out _, out _);
}
```

**Use Cases**:
- Input validation in UIs (with or without numeric values)
- Pre-flight checks before parsing
- Configuration validation
- Form validation where users might type "5 meters" or just "meters"

#### GetUnitsForType() Static Method

**Purpose**: Get list of catalog units for a specific dimension type (for UI dropdowns)

**Design**:
```csharp
/// <summary>
/// Gets a list of all catalog unit names for a specified dimension type.
/// Useful for populating UI dropdowns and selection lists.
/// </summary>
/// <param name="unitType">The dimension type to query (e.g., Length, Mass, Time).</param>
/// <returns>
/// Read-only list of unit names (canonical names, not aliases).
/// Returns empty list for Unknown type.
/// </returns>
/// <remarks>
/// Only returns catalog units, not composite units.
/// Results are sorted alphabetically for UI display.
/// 
/// Example usage:
/// <code>
/// var lengthUnits = Quantity.GetUnitsForType(UnitTypeEnum.Length);
/// // Returns: ["cm", "ft", "in", "km", "m", "mi", "mm", "yd", ...]
/// 
/// foreach (var unit in lengthUnits)
/// {
///     comboBox.Items.Add(unit);
/// }
/// </code>
/// </remarks>
public static IReadOnlyList<string> GetUnitsForType(UnitTypeEnum unitType)
{
    if (unitType == UnitTypeEnum.Unknown)
        return Array.Empty<string>();
    
    // Query UnitDefinitions type index
    var units = UnitDefinitions.GetUnitsForType(unitType);
    
    // Return sorted canonical names
    return units.Select(u => u.Name).OrderBy(n => n).ToList();
}
```

**Note**: Requires adding `GetUnitsForType()` method to `UnitDefinitions` class to expose the existing `_typeIndex`.

#### GetUnitsForSignature() Static Method (Alternative to GetUnitsForType)

**Purpose**: Get catalog units compatible with a specific dimension signature

**Design**:
```csharp
/// <summary>
/// Gets a list of catalog units that match the specified dimension signature.
/// Useful for advanced scenarios where UnitType is insufficient.
/// </summary>
/// <param name="signature">The dimension signature to query.</param>
/// <returns>
/// Read-only list of unit names that resolve to the given signature.
/// May be empty if no catalog units match the signature.
/// </returns>
/// <remarks>
/// This is more precise than GetUnitsForType for composite dimensions.
/// 
/// Example:
/// <code>
/// var forceSignature = new DimensionSignature(1, 1, -2, 0, 0, 0, 0);  // L¬πM¬πT‚Åª¬≤
/// var forceUnits = Quantity.GetUnitsForSignature(forceSignature);
/// // Returns: ["N", "kgf", "lbf", ...]
/// </code>
/// </remarks>
public static IReadOnlyList<string> GetUnitsForSignature(DimensionSignature signature)
{
    var matchingUnits = new List<string>();
    
    // Iterate all catalog units and check signature match
    foreach (var definition in UnitDefinitions.GetAllDefinitions())
    {
        var unitSignature = UnitResolver.Instance.Resolve(definition.Name).Signature;
        if (unitSignature.Equals(signature))
        {
            matchingUnits.Add(definition.Name);
        }
    }
    
    return matchingUnits.OrderBy(n => n).ToList();
}
```

**Design Decision**: GetUnitsForType vs GetUnitsForSignature
- **Recommendation**: Implement **GetUnitsForType** first (simpler, covers 90% of use cases)
- **Defer**: GetUnitsForSignature to F-014+ if user demand exists
- **Rationale**: 
  - UnitType is intuitive and matches existing catalog organization
  - Signature-based lookup is more complex and niche
  - Can add later without breaking changes

### Phase 4: Diagnostics API (Optional)

#### CacheStatistics Class

**Purpose**: Expose performance metrics for caches

**Design**:
```csharp
/// <summary>
/// Provides diagnostic information about internal cache performance.
/// Use these metrics to understand and optimize Tare usage patterns.
/// </summary>
public sealed class CacheStatistics
{
    /// <summary>
    /// Gets the cache hit rate for composite unit parsing (0.0 to 1.0).
    /// Higher is better; > 0.80 indicates effective caching.
    /// </summary>
    public double CompositeParserHitRate { get; }
    
    /// <summary>
    /// Gets the cache hit rate for unit resolution (0.0 to 1.0).
    /// Higher is better; > 0.80 indicates effective caching.
    /// </summary>
    public double UnitResolverHitRate { get; }
    
    /// <summary>
    /// Gets the total number of composite parse operations performed.
    /// </summary>
    public long CompositeParseOperations { get; }
    
    /// <summary>
    /// Gets the total number of unit resolution operations performed.
    /// </summary>
    public long UnitResolveOperations { get; }
    
    internal CacheStatistics(
        double compositeParserHitRate,
        double unitResolverHitRate,
        long compositeParseOperations,
        long unitResolveOperations)
    {
        CompositeParserHitRate = compositeParserHitRate;
        UnitResolverHitRate = unitResolverHitRate;
        CompositeParseOperations = compositeParseOperations;
        UnitResolveOperations = unitResolveOperations;
    }
}

/// <summary>
/// Provides diagnostic access to internal Tare performance metrics.
/// </summary>
public static class QuantityDiagnostics
{
    /// <summary>
    /// Gets current cache statistics for internal operations.
    /// Use these metrics to monitor and optimize performance.
    /// </summary>
    /// <returns>Snapshot of current cache statistics.</returns>
    public static CacheStatistics GetCacheStatistics()
    {
        // Gather stats from internal caches
        var parserStats = CompositeParser.Instance.GetStatistics();
        var resolverStats = UnitResolver.Instance.GetStatistics();
        
        return new CacheStatistics(
            parserStats.HitRate,
            resolverStats.HitRate,
            parserStats.TotalOperations,
            resolverStats.TotalOperations);
    }
}
```

**Considerations**:
- Statistics are snapshot; not real-time
- No reset functionality exposed (internal only)
- Thread-safe reads (caches already use concurrent structures)

**Alternative**: Defer diagnostics entirely
- **Decision needed**: Include in F-013 or defer to F-014+?
- **Recommendation**: Include basic cache stats; defer advanced diagnostics

---

## API Surface Summary

### New Public Types

```csharp
// Make existing internal type public
public readonly struct DimensionSignature : IEquatable<DimensionSignature>
{
    // Existing properties become public
    public sbyte Length { get; }
    public sbyte Mass { get; }
    public sbyte Time { get; }
    public sbyte ElectricCurrent { get; }
    public sbyte Temperature { get; }
    public sbyte AmountOfSubstance { get; }
    public sbyte LuminousIntensity { get; }
    
    // Existing factory properties
    public static DimensionSignature Dimensionless { get; }
    public static DimensionSignature LengthSignature { get; }
    // ... etc
}

// New diagnostics class (optional)
public sealed class CacheStatistics { /* ... */ }
public static class QuantityDiagnostics { /* ... */ }
```

### New Instance Methods on Quantity

```csharp
public readonly struct Quantity
{
    // Introspection
    public DimensionSignature GetSignature();
    public bool IsKnownDimension();
    public string? GetDimensionDescription();
    
    // Normalization
    public Quantity ToBaseUnits();
    public Quantity ToCanonical();
}
```

### New Static Methods on Quantity

```csharp
public readonly struct Quantity
{
    // Validation
    public static bool ContainsValidUnit(string? input);
    
    // Unit Discovery
    public static IReadOnlyList<string> GetUnitsForType(UnitTypeEnum unitType);
    
    // Optional (deferred to user demand)
    // public static IReadOnlyList<string> GetUnitsForSignature(DimensionSignature signature);
}
```

### New Methods on UnitDefinitions (Required for GetUnitsForType)

```csharp
public static class UnitDefinitions
{
    // Expose type index for unit discovery
    public static IReadOnlyList<UnitDefinition> GetUnitsForType(UnitTypeEnum unitType);
    
    // Optional: expose all definitions for signature-based queries
    // public static IEnumerable<UnitDefinition> GetAllDefinitions();
}
```

---

## Out of Scope

- ‚ùå Mutable state or configuration APIs
- ‚ùå Culture-specific formatting (F-016)
- ‚ùå Custom signature map registration (future enhancement)
- ‚ùå **Runtime configuration of preferred units** (see Q5 below - deferred to F-018)
- ‚ùå GetUnitsForSignature implementation (deferred; GetUnitsForType covers common cases)
- ‚ùå Advanced dimension algebra (power, root operations)
- ‚ùå Unit aliases management (covered by existing UnitDefinitions)
- ‚ùå Performance optimization (F-011 already delivered caching)

---

## Dependencies

### Consumes
- **F-011**: Uses existing cache infrastructure (CompositeParser, UnitResolver)
- **F-012**: Follows error handling standards

### Enables
- **F-014**: Documentation can showcase helper methods
- **F-016**: Formatting helpers may build on normalization APIs

---

## Testing Strategy

### Unit Tests

**Target**: All new public helper methods

**Test File**: `tests/QuantityHelperTests.cs`

**Naming Convention**: `MethodName_Condition_ExpectedResult()`

**Coverage Goals**:
- 100% of new public methods
- All return value types tested
- Null/empty/edge cases covered

**Test Categories**:

1. **Introspection Tests**
```csharp
[Fact]
public void GetSignature_CatalogUnit_ReturnsCorrectSignature()
{
    // Arrange
    var force = Quantity.Parse("10 N");
    
    // Act
    var signature = force.GetSignature();
    
    // Assert
    Assert.Equal(1, signature.Length);
    Assert.Equal(1, signature.Mass);
    Assert.Equal(-2, signature.Time);
    Assert.Equal(0, signature.ElectricCurrent);
}

[Fact]
public void IsKnownDimension_Force_ReturnsTrue()
{
    // Arrange
    var force = Quantity.Parse("10 N");
    
    // Act
    var isKnown = force.IsKnownDimension();
    
    // Assert
    Assert.True(isKnown);
}

[Fact]
public void GetDimensionDescription_Energy_ReturnsEnergy()
{
    // Arrange
    var energy = Quantity.Parse("100 J");
    
    // Act
    var description = energy.GetDimensionDescription();
    
    // Assert
    Assert.Equal("Energy", description);
}

[Fact]
public void GetDimensionDescription_UnknownSignature_ReturnsNull()
{
    // Arrange - create quantity with unknown composite signature
    var unknown = Quantity.Parse("10 m^5");
    
    // Act
    var description = unknown.GetDimensionDescription();
    
    // Assert
    Assert.Null(description);
}
```

2. **Normalization Tests**
```csharp
[Fact]
public void ToBaseUnits_Kilometers_ReturnsMeters()
{
    // Arrange
    var distance = Quantity.Parse("5 km");
    
    // Act
    var baseUnits = distance.ToBaseUnits();
    
    // Assert
    Assert.Equal(5000m, baseUnits.Value);
    Assert.Equal("m", baseUnits.Unit);
}

[Fact]
public void ToBaseUnits_Force_ReturnsCompositeBase()
{
    // Arrange
    var force = Quantity.Parse("10 N");
    
    // Act
    var baseUnits = force.ToBaseUnits();
    
    // Assert
    Assert.Equal(10m, baseUnits.Value);
    Assert.Contains("kg", baseUnits.Unit);
    Assert.Contains("m", baseUnits.Unit);
    Assert.Contains("s^-2", baseUnits.Unit);
}

[Fact]
public void ToCanonical_TorqueInLbfIn_ReturnsNm()
{
    // Arrange
    var torque = Quantity.Parse("1500 lbf*in");
    
    // Act
    var canonical = torque.ToCanonical();
    
    // Assert
    Assert.Equal("Nm", canonical.Unit);
    // Value should be correctly converted (approximately 169.5)
    Assert.True(Math.Abs(169.5m - canonical.Value) < 0.1m);
}

[Fact]
public void ToCanonical_UnknownDimension_ReturnsUnchanged()
{
    // Arrange
    var unknown = Quantity.Parse("10 m^5");
    
    // Act
    var canonical = unknown.ToCanonical();
    
    // Assert
    Assert.Equal("m^5", canonical.Unit);
    Assert.Equal(10m, canonical.Value);
}
```

3. **Validation Tests**
```csharp
[Fact]
public void ContainsValidUnit_CatalogUnit_ReturnsTrue()
{
    // Act & Assert
    Assert.True(Quantity.ContainsValidUnit("m"));
    Assert.True(Quantity.ContainsValidUnit("kg"));
    Assert.True(Quantity.ContainsValidUnit("N"));
}

[Fact]
public void ContainsValidUnit_UnitWithValue_ReturnsTrue()
{
    // Act & Assert
    Assert.True(Quantity.ContainsValidUnit("12 in"));
    Assert.True(Quantity.ContainsValidUnit("5.5 kg"));
    Assert.True(Quantity.ContainsValidUnit("100 N"));
}

[Fact]
public void ContainsValidUnit_CompositeUnit_ReturnsTrue()
{
    // Act & Assert
    Assert.True(Quantity.ContainsValidUnit("Nm"));
    Assert.True(Quantity.ContainsValidUnit("m/s"));
    Assert.True(Quantity.ContainsValidUnit("kg*m^2/s^2"));
}

[Fact]
public void ContainsValidUnit_CompositeWithValue_ReturnsTrue()
{
    // Act & Assert
    Assert.True(Quantity.ContainsValidUnit("200 Nm"));
    Assert.True(Quantity.ContainsValidUnit("10.5 m/s"));
}

[Fact]
public void ContainsValidUnit_InvalidUnit_ReturnsFalse()
{
    // Act & Assert
    Assert.False(Quantity.ContainsValidUnit("xyz"));
    Assert.False(Quantity.ContainsValidUnit("invalid"));
    Assert.False(Quantity.ContainsValidUnit("m/"));
    Assert.False(Quantity.ContainsValidUnit("12 xyz"));
}

[Fact]
public void ContainsValidUnit_NullOrEmpty_ReturnsFalse()
{
    // Act & Assert
    Assert.False(Quantity.ContainsValidUnit(null));
    Assert.False(Quantity.ContainsValidUnit(""));
    Assert.False(Quantity.ContainsValidUnit("   "));
}
```

4. **Unit Discovery Tests**
```csharp
[Fact]
public void GetUnitsForType_Length_ReturnsLengthUnits()
{
    // Act
    var units = Quantity.GetUnitsForType(UnitTypeEnum.Length);
    
    // Assert
    Assert.NotEmpty(units);
    Assert.Contains("m", units);
    Assert.Contains("cm", units);
    Assert.Contains("in", units);
    Assert.Contains("ft", units);
    // Should be sorted
    Assert.True(IsSorted(units));
}

[Fact]
public void GetUnitsForType_Force_ReturnsForceUnits()
{
    // Act
    var units = Quantity.GetUnitsForType(UnitTypeEnum.Force);
    
    // Assert
    Assert.NotEmpty(units);
    Assert.Contains("N", units);
    Assert.Contains("lbf", units);
}

[Fact]
public void GetUnitsForType_Unknown_ReturnsEmpty()
{
    // Act
    var units = Quantity.GetUnitsForType(UnitTypeEnum.Unknown);
    
    // Assert
    Assert.Empty(units);
}

private bool IsSorted(IReadOnlyList<string> list)
{
    for (int i = 1; i < list.Count; i++)
    {
        if (string.Compare(list[i - 1], list[i], StringComparison.Ordinal) > 0)
            return false;
    }
    return true;
}
```

5. **Diagnostics Tests** (if included)
```csharp
[Fact]
public void GetCacheStatistics_ReturnsValidData()
{
    // Act
    var stats = QuantityDiagnostics.GetCacheStatistics();
    
    // Assert
    Assert.NotNull(stats);
    Assert.InRange(stats.CompositeParserHitRate, 0.0, 1.0);
    Assert.InRange(stats.UnitResolverHitRate, 0.0, 1.0);
    Assert.True(stats.CompositeParseOperations >= 0);
    Assert.True(stats.UnitResolveOperations >= 0);
}
```

### Integration Tests

**Target**: End-to-end helper scenarios

**Examples**:
- Use introspection to validate dimensions before operations
- Use normalization in data standardization workflow
- Use diagnostics to optimize hot paths

---

## Breaking Changes

‚úÖ **NONE** - This feature is 100% backwards compatible

**Why No Breaking Changes**:
1. All APIs are additive (new methods only)
2. Existing public surface unchanged
3. Making `DimensionSignature` public is additive (was internal)
4. No changes to existing method signatures or behavior

**Migration Guide**: Not needed (backwards compatible)

---

## Documentation Updates

### XML Comments

All new public APIs must have comprehensive XML documentation:

```csharp
/// <summary>
/// Gets the dimension signature of this quantity.
/// </summary>
/// <returns>The dimension signature representing dimensional composition.</returns>
/// <remarks>
/// The signature uses integer exponents over seven SI base dimensions.
/// Examples: Force (L¬πM¬πT‚Åª¬≤), Energy (L¬≤M¬πT‚Åª¬≤), Pressure (L‚Åª¬πM¬πT‚Åª¬≤).
/// </remarks>
public DimensionSignature GetSignature() { /* ... */ }
```

### CHANGELOG.md

Add entry:
```markdown
## [version] - [date]

### Added
- Added `GetSignature()` method to inspect dimension composition (F-013)
- Added `IsKnownDimension()` method to check if dimension is recognized (F-013)
- Added `GetDimensionDescription()` method for human-readable dimension names (F-013)
- Added `ToBaseUnits()` method to convert to SI base representation (F-013)
- Added `ToCanonical()` method to convert to preferred canonical units (F-013)
- Added `ContainsValidUnit()` static method for input validation with or without factors (F-013)
- Added `GetUnitsForType()` static method to get list of units for a dimension type (F-013)
- Added `DimensionSignature` as public type for advanced scenarios (F-013)
- Added `UnitDefinitions.GetUnitsForType()` method to support unit discovery (F-013)
- (Optional) Added `QuantityDiagnostics` class for cache performance metrics (F-013)

### Improved
- Enhanced developer experience with introspection and normalization helpers (F-013)
- Better UI support with unit discovery methods for combo boxes (F-013)
```

### README.md

Add section:
```markdown
## Helper Methods

### Introspection

Check dimension information at runtime:

```csharp
var force = Quantity.Parse("10 N");

// Get dimension signature
var signature = force.GetSignature();
Console.WriteLine($"Force: L^{signature.Length} M^{signature.Mass} T^{signature.Time}");
// Output: "Force: L^1 M^1 T^-2"

// Check if dimension is known
if (force.IsKnownDimension())
{
    var description = force.GetDimensionDescription();
    Console.WriteLine($"Dimension: {description}");
    // Output: "Dimension: Force"
}
```

### Normalization

Convert to standard representations:

```csharp
var pressure = Quantity.Parse("14.7 psi");

// Convert to SI base units
var baseUnits = pressure.ToBaseUnits();
Console.WriteLine(baseUnits);  // "689475.7 kg/(m*s^2)"

// Convert to canonical (preferred) unit
var canonical = pressure.ToCanonical();
Console.WriteLine(canonical);  // "101352.9 Pa"
```

### Validation and Discovery

Validate unit strings and discover available units:

```csharp
// Validate user input (with or without values)
string userInput = GetUserInput();

if (Quantity.ContainsValidUnit(userInput))  // Works with "m" or "12 in"
{
    var q = Quantity.Parse(userInput);
    // ... use quantity
}
else
{
    Console.WriteLine($"Invalid unit: {userInput}");
}

// Get units for UI dropdowns
var lengthUnits = Quantity.GetUnitsForType(UnitTypeEnum.Length);
foreach (var unit in lengthUnits)
{
    comboBox.Items.Add(unit);  // Adds: "cm", "ft", "in", "km", "m", ...
}
```
```

---

## Files to Modify

### Core Implementation
- `src/Quantity.cs` (add helper methods region, ~200 LOC for new methods)
- `src/UnitDefinitions.cs` (add GetUnitsForType method, ~20 LOC)
- `src/Internal/Units/DimensionSignature.cs` (change `internal` to `public`, add XML docs)
- `src/Internal/Units/CompositeParser.cs` (add statistics methods if diagnostics included)
- `src/Internal/Units/UnitResolver.cs` (add statistics methods if diagnostics included)

### Diagnostics (Optional)
- `src/Diagnostics/CacheStatistics.cs` (new file, ~60 LOC)
- `src/Diagnostics/QuantityDiagnostics.cs` (new file, ~40 LOC)

### Tests
- `tests/QuantityHelperTests.cs` (new file, comprehensive tests, ~600-700 LOC)
- `tests/UnitDefinitionsTests.cs` (add tests for GetUnitsForType, ~50 LOC)
- `tests/DimensionSignatureTests.cs` (enhance existing if needed)

### Documentation
- `README.md` (add Helper Methods section with validation and discovery examples)
- `docs/CHANGELOG.md` (add F-013 entry)
- XML comments on all new public APIs

---

## Quality Gates

### Before Committing
- [ ] All tests pass (including new helper tests)
- [ ] `DimensionSignature` made public with complete XML docs
- [ ] All new methods have comprehensive XML documentation
- [ ] All helper methods tested using `MethodName_Condition_ExpectedResult()` pattern
- [ ] Zero breaking changes validated
- [ ] ContainsValidUnit handles both "unit" and "value unit" formats correctly

### Before PR Merge
- [ ] Code review passed
- [ ] CHANGELOG.md updated
- [ ] README.md updated with examples (including UI dropdown usage)
- [ ] Build succeeds with zero warnings
- [ ] Test coverage > 95% for new APIs

---

## Quality Checklist

### Domain Design Validation
- ‚úÖ I have verified that helpers preserve value object immutability
- ‚úÖ I have confirmed consistent terminology (Signature, Canonical, Base, Known)
- ‚úÖ I have verified SOLID principles, especially SRP and OCP
- ‚úÖ I have validated that helpers delegate to existing domain services

### Implementation Quality Validation
- ‚úÖ I have written comprehensive tests using `MethodName_Condition_ExpectedResult()` naming
- ‚úÖ I have considered performance (helpers should not impact hot paths)
- ‚úÖ I have implemented null checks where appropriate (ContainsValidUnit)
- ‚úÖ I have documented all public APIs with XML comments
- ‚úÖ I have verified ContainsValidUnit handles both unit-only and value+unit formats

### API Design Validation
- ‚úÖ I have verified naming follows .NET conventions
- ‚úÖ I have ensured all methods are focused and single-purpose
- ‚úÖ I have validated that APIs are additive (zero breaking changes)
- ‚úÖ I have tested all methods with catalog and composite units
- ‚úÖ I have provided unit discovery methods suitable for UI scenarios

---

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| Making `DimensionSignature` public expands API surface | Medium | Low | Struct is well-designed; already tested internally |
| Performance impact of helper methods | Low | Low | Helpers delegate to cached operations; benchmarks validate |
| User confusion about when to use helpers | Medium | Low | Clear documentation with examples; optional usage |
| Diagnostics API misuse or misinterpretation | Low | Low | Clear documentation; read-only access only |

---

## Timeline

**Estimated Effort**: 2‚Äì3 days

**Breakdown**:
- Day 1 AM: Design decisions (nullable vs exception, diagnostics scope, GetUnitsForType design)
- Day 1 PM: Implement introspection helpers (GetSignature, IsKnownDimension, GetDimensionDescription)
- Day 2 AM: Implement normalization helpers (ToBaseUnits, ToCanonical)
- Day 2 PM: Implement validation helper (ContainsValidUnit), unit discovery (GetUnitsForType)
- Day 2 PM: Add UnitDefinitions.GetUnitsForType support method
- Day 3 AM: Write comprehensive tests for all new methods
- Day 3 PM: (Optional) Implement diagnostics API
- Day 3 PM: Documentation, final verification, PR prep

---

## Success Metrics

### Objective Measures
- ‚úÖ All tests pass (100% for new APIs)
- ‚úÖ Zero breaking changes (verified by existing tests)
- ‚úÖ All public APIs have XML documentation
- ‚úÖ README examples compile and run correctly

### Subjective Measures
- ‚úÖ Helper methods reviewed and deemed useful by team
- ‚úÖ API design reviewed and deemed intuitive
- ‚úÖ Documentation reviewed and deemed comprehensive

---

## References

### Internal
- **E-001**: Epic defining F-013 scope and dependencies
- **F-011**: Performance & Caching (provides cache infrastructure)
- **F-012**: Error Handling (provides standards for consistency)
- **F-014**: Documentation (will showcase helper methods)

### External
- **.NET Design Guidelines**: https://learn.microsoft.com/en-us/dotnet/standard/design-guidelines/
- **API Design Best Practices**: Clear, consistent, minimal surface area
- **Value Object Pattern**: Immutability and query methods

---

## Open Questions

### Q1: Should GetDimensionDescription() return nullable or throw?

**Context**: Unknown dimensions exist (e.g., m^5). How should API behave?

**Options**:
- **A**: Return `string?` (nullable) - returns null for unknown
- **B**: Throw `InvalidOperationException` for unknown

**Decision**: **Option A (Nullable)**. Rationale:
- More flexible for callers
- Consistent with Try* patterns
- Pair with `IsKnownDimension()` for explicit checks
- No performance penalty

### Q2: Should we include diagnostics API in F-013?

**Context**: Cache statistics are useful but may be niche use case.

**Options**:
- **A**: Include basic `QuantityDiagnostics` with cache stats
- **B**: Defer all diagnostics to user demand / future feature

**Decision**: **Option A (Include basic diagnostics)**. Rationale:
- Minimal implementation cost (~2-3 hours)
- Enables performance optimization scenarios
- Follows through on F-011/F-012 diagnostics discussion
- Can always expand later if demand exists

### Q3: Should ToBaseUnits() return composite string or formatted string?

**Context**: Base units for Force could be "kg*m/s^2" or formatted with special chars.

**Options**:
- **A**: Use `CompositeFormatter` as-is (ASCII-safe: "kg*m/s^2")
- **B**: Add optional pretty-print (Unicode: "kg¬∑m¬∑s‚Åª¬≤")

**Decision**: **Option A (ASCII-safe)**. Rationale:
- Consistent with existing composite formatting
- Works in all environments (console, logs, files)
- Pretty-print can be added in F-016 (formatting feature)
- Keeps F-013 focused

### Q4: GetUnitsForType vs GetUnitsForSignature - which to implement?

**Context**: Users need unit lists for UI dropdowns. Two approaches possible.

**Options**:
- **A**: Implement `GetUnitsForType(UnitTypeEnum)` only (simpler, 90% use case)
- **B**: Implement `GetUnitsForSignature(DimensionSignature)` only (more precise)
- **C**: Implement both methods

**Decision**: **Option A (GetUnitsForType only)**. Rationale:
- UnitType aligns with existing catalog organization
- Simpler API for common UI scenarios
- Can add GetUnitsForSignature later if needed (no breaking change)
- Keeps F-013 focused on practical use cases

### Q5: Should ToCanonical support runtime configuration of preferred units?

**Context**: Current design uses hardcoded `KnownSignatureMap` with SI-first policy. Users may want different preferences (US Customary first, industry-specific units).

**Options**:
- **A**: Keep F-013 simple; defer to F-014+ based on user demand
- **B**: Add `ToCanonical(UnitSystemPreference preference)` overload now
- **C**: Add global configuration API (e.g., `QuantityConfiguration.SetPreferredUnits(...)`)

**Decision**: **Option A (Defer)**. Rationale:
- YAGNI - no user demand yet; avoid speculative features
- Keeps F-013 focused on core helpers
- Can add later without breaking changes (overload or new method)
- If added, likely belongs in separate feature (F-018: Preferred Units Configuration)
- Current SI-first policy serves majority of users

**Future Consideration**: If demand exists, implement in F-018 with:
- `ToCanonical(UnitSystemPreference)` method overload
- Or: `QuantityConfiguration` static class for global preferences
- Support SI-first, US Customary-first, or custom maps
- Full specification added to E-001 epic (see F-018)

---

## Decisions Recorded

1. **DimensionSignature Visibility** (2025-11-12): Make `DimensionSignature` public readonly struct. Well-designed, tested, enables advanced scenarios. No breaking changes (additive).

2. **Nullable Description** (2025-11-12): `GetDimensionDescription()` returns `string?` (nullable). More flexible; consistent with query semantics.

3. **Diagnostics Inclusion** (2025-11-12): Include basic `QuantityDiagnostics` with cache statistics. Minimal cost; high value for optimization scenarios.

4. **ToBaseUnits Format** (2025-11-12): Use existing ASCII-safe composite formatting. Defer pretty-print to F-016.

5. **Helper Location** (2025-11-12): Implement helpers as instance methods on `Quantity` (not extensions). Better discoverability; consistent with value object pattern.

6. **API Naming** (2025-11-12): Rename `IsValidUnit` to `ContainsValidUnit`. More accurate name for a method that extracts and validates units from strings like "12 in" or "lbf".

7. **Unit Discovery API** (2025-11-12): Implement `GetUnitsForType(UnitTypeEnum)` only. Defer `GetUnitsForSignature` to future based on user demand. Simpler API covers 90% of use cases.

8. **Preferred Units Configuration** (2025-11-12): Defer runtime configuration of preferred units to F-018 based on user demand. Current SI-first policy sufficient for F-013. Full feature specification added to E-001 epic.

9. **ContainsValidUnit Implementation** (2025-11-13): Reuse existing static `UnitsPattern` regex from `Quantity` class instead of creating new instances. Ensures consistency with library's parsing approach and avoids performance overhead.
