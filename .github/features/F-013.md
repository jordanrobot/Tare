# F-013: API Helpers (Additive)

**Status**: Planned  
**Epic**: E-001 (Option A Hybrid Core)  
**Priority**: P2 (Should)  
**Effort**: M (2‚Äì3 days)  
**Dependencies**: F-011 (Performance & Caching), F-012 (Error Handling)

---

## TL;DR ‚Äî Quick Reference

**Goal**: Expose additive helper methods on `Quantity` for introspection, diagnostics, and advanced use cases

**Effort**: 2-3 days (M)

**Impact**: Better developer experience, enables advanced scenarios, zero breaking changes

### What Gets Added

**üîç Introspection Helpers**  
Access internal dimension information, check if unit is known, inspect signatures  
**Time**: 6-8 hours

**üîß Normalization Helpers**  
Convert quantities to base SI units or preferred canonical units  
**Time**: 4-6 hours

**üìä Diagnostics Helpers**  
Expose cache statistics and performance metrics for optimization  
**Time**: 2-4 hours

**‚úÖ Test Coverage**  
Comprehensive tests for all new public APIs  
**Time**: 4-6 hours

### Quick Command Reference

```bash
# Build project
dotnet build

# Run all tests
dotnet test

# Run specific test category
dotnet test --filter "FullyQualifiedName~QuantityHelperTests"

# Check coverage (if tool installed)
dotnet-coverage collect -f cobertura -o coverage.xml dotnet test
```

---

## Mandatory Thinking (DDD/.NET Guidelines)

### 1) Analysis

**Applicable Patterns**:
- **Value Object Extensions**: Helper methods maintain immutability; all return new instances
- **SOLID Principles**:
  - **SRP**: Each helper has single, focused responsibility
  - **OCP**: Helpers are additive; existing behavior unchanged
  - **ISP**: APIs are focused and minimal; no forced dependencies
  - **DIP**: Helpers use existing internal abstractions
- **Ubiquitous Language**: All APIs use consistent terminology (Signature, Normalize, Known, Canonical, Base)

**Layers Affected**:
- **Domain**: Extension methods on `Quantity` value object
- **Application**: N/A (library context)
- **Infrastructure**: Diagnostic helpers may expose internal cache stats

**Security & Compliance**:
- No sensitive data exposed in diagnostics
- All helpers are read-only queries; no state mutation
- Deterministic behavior for audit trails

### 2) Review Against Guidelines

**Aggregate Boundaries**: Helpers respect `Quantity` as immutable value object

**SRP Compliance**: Each helper method has focused, single purpose

**Domain Rules Encapsulated**: Helpers delegate to existing internal services; no business logic duplication

**Tests**: All public helpers tested using `MethodName_Condition_ExpectedResult()` pattern

**Ubiquitous Language**: Consistent terminology throughout API surface

### 3) Implementation Plan Validation

**Files to Create/Modify**:
- Modify: `src/Quantity.cs` (add helper methods region)
- Modify: `src/Extensions.cs` (add optional extension methods)
- Create: `tests/QuantityHelperTests.cs` (comprehensive test suite)
- Optional Create: `src/Diagnostics/QuantityDiagnostics.cs` (if diagnostics warrant separate class)

**Tests**:
- All helpers tested with catalog units
- All helpers tested with composite units
- Edge cases: dimensionless, unknown signatures, null guards
- Performance: helpers should not significantly impact hot paths

**Error Handling Strategy**:
- Return false/null for query operations that fail gracefully
- Throw specific exceptions only for programmer errors (null arguments)
- Consistent with F-012 error handling standards

---

## Description

Provide additive helper methods on `Quantity` and related types to support:
1. **Introspection**: Inspect dimension signatures, check if unit is recognized
2. **Normalization**: Convert to base SI units or preferred canonical representation
3. **Diagnostics**: Access cache performance metrics for optimization
4. **Advanced Scenarios**: Enable power users to work with internal representations

All helpers are additive (no breaking changes) and follow established .NET conventions.

---

## User Stories

### User Story 1: Dimension Introspection

**As a** developer building a physics engine using Tare  
**I want** to inspect the dimensional signature of quantities at runtime  
**So that** I can validate dimensional consistency and display dimension information to users

**Example**:
```csharp
var force = Quantity.Parse("10 N");
var signature = force.GetSignature();  
// DimensionSignature: L=1, M=1, T=-2

if (force.IsKnownDimension())
{
    var description = force.GetDimensionDescription();  
    // "Force"
}
```

### User Story 2: Unit Normalization

**As a** data scientist standardizing measurement data  
**I want** to convert all quantities to canonical SI base units  
**So that** I can perform consistent analysis across datasets

**Example**:
```csharp
var pressure = Quantity.Parse("14.7 psi");
var normalized = pressure.ToBaseUnits();  
// Quantity(101352.9, "Pa")

var torque = Quantity.Parse("1500 lbf*in");
var canonical = torque.ToCanonical();  
// Quantity(169.5, "Nm")  - uses preferred unit from KnownSignatureMap
```

### User Story 3: Performance Diagnostics

**As a** performance engineer optimizing hot paths  
**I want** access to cache hit rates and performance metrics  
**So that** I can identify and optimize performance bottlenecks

**Example**:
```csharp
var stats = QuantityDiagnostics.GetCacheStatistics();
Console.WriteLine($"Composite parse cache: {stats.CompositeParserHitRate:P}");
Console.WriteLine($"Unit resolver cache: {stats.UnitResolverHitRate:P}");
// Outputs: "Composite parse cache: 87.5%"
//          "Unit resolver cache: 92.3%"
```

### User Story 4: Advanced Unit Resolution

**As a** developer building a unit converter UI  
**I want** to check if a unit string is valid before using it  
**So that** I can provide immediate feedback to users without catching exceptions

**Example**:
```csharp
string userInput = "xyz";  // Invalid unit

if (Quantity.IsValidUnit(userInput))
{
    var q = Quantity.Parse($"10 {userInput}");
    // ... use quantity
}
else
{
    ShowError($"Unknown unit: {userInput}");
}
```

---

## Acceptance Criteria

### 1. Introspection Helpers

- ‚úÖ `GetSignature()` returns `DimensionSignature` for any quantity
- ‚úÖ `IsKnownDimension()` returns true if signature is in `KnownSignatureMap`
- ‚úÖ `GetDimensionDescription()` returns human-readable description (e.g., "Force", "Energy")
- ‚úÖ `GetDimensionDescription()` returns null or throws for unknown dimensions (decision needed)
- ‚úÖ Works correctly for catalog units, composite units, and dimensionless quantities

### 2. Normalization Helpers

- ‚úÖ `ToBaseUnits()` converts to SI base representation (m, kg, s, A, K, mol, cd)
- ‚úÖ `ToCanonical()` converts to preferred unit from `KnownSignatureMap` when known
- ‚úÖ `ToCanonical()` preserves unit for unknown signatures (no-op behavior)
- ‚úÖ Normalization preserves numeric value correctness (tested to precision limits)
- ‚úÖ Both methods return new `Quantity` instances (immutability preserved)

### 3. Unit Validation Helpers

- ‚úÖ `IsValidUnit(string)` static method returns true for catalog and composite units
- ‚úÖ `IsValidUnit` returns false for null, empty, malformed, or unknown units
- ‚úÖ `IsValidUnit` does not throw exceptions (query semantics)
- ‚úÖ Performance: `IsValidUnit` is fast (uses existing caches)

### 4. Diagnostics (Optional/Deferred)

- ‚úÖ `QuantityDiagnostics.GetCacheStatistics()` returns performance metrics
- ‚úÖ Cache stats include hit/miss counts and rates for major caches
- ‚úÖ Diagnostics are read-only; no ability to clear or modify caches via public API
- ‚è∏Ô∏è Advanced diagnostics (memory usage, operation counts) deferred to user demand

### 5. API Quality Standards

- ‚úÖ All public methods have comprehensive XML documentation
- ‚úÖ All methods follow .NET naming conventions (PascalCase, clear intent)
- ‚úÖ All methods have corresponding tests using `MethodName_Condition_ExpectedResult()` pattern
- ‚úÖ Error handling consistent with F-012 standards
- ‚úÖ Zero breaking changes to existing API surface

---

## Technical Approach

### Phase 1: Introspection API (Core)

**Add helper methods to `Quantity` struct**

#### GetSignature() Method

**Purpose**: Expose the internal `DimensionSignature` for advanced scenarios

**Design**:
```csharp
/// <summary>
/// Gets the dimension signature of this quantity, representing its dimensional composition
/// using exponents over the seven SI base dimensions (L, M, T, I, Œò, N, J).
/// </summary>
/// <returns>
/// The dimension signature. For catalog units, resolves via UnitResolver.
/// For composite units, uses the cached signature from CompositeParser.
/// </returns>
/// <remarks>
/// Examples:
/// - "m" ‚Üí Length(1), others(0)
/// - "N" ‚Üí Length(1), Mass(1), Time(-2), others(0)
/// - "Nm" ‚Üí Length(2), Mass(1), Time(-2), others(0)
/// </remarks>
public DimensionSignature GetSignature()
{
    // Fast path: catalog unit
    if (UnitDefinitions.IsValidUnit(Unit))
    {
        var resolved = UnitResolver.Instance.Resolve(Unit);
        return resolved.Signature;
    }
    
    // Slow path: composite unit
    var parser = CompositeParser.Instance;
    if (parser.TryParse(Unit, out var signature, out _))
    {
        return signature;
    }
    
    // Fallback: dimensionless (shouldn't reach here for valid quantities)
    return DimensionSignature.Dimensionless;
}
```

**Considerations**:
- `DimensionSignature` is currently internal; decision needed: make public or create DTO?
- **Recommendation**: Make `DimensionSignature` public readonly struct
  - Already well-designed value type
  - No breaking changes (additive)
  - Enables advanced user scenarios
  - Future-proof for F-014+ features

#### IsKnownDimension() Method

**Purpose**: Check if quantity's dimension is recognized in the `KnownSignatureMap`

**Design**:
```csharp
/// <summary>
/// Determines whether this quantity's dimension is recognized in the known signature map.
/// Known dimensions include standard physical quantities like Force, Energy, Pressure, etc.
/// </summary>
/// <returns>
/// True if the dimension is known and has a preferred canonical unit; otherwise, false.
/// </returns>
/// <remarks>
/// Known dimensions:
/// - Base: Length, Mass, Time, Electric Current, Temperature, Amount of Substance, Luminous Intensity
/// - Geometric: Area, Volume
/// - Kinematic: Velocity, Acceleration, Jerk
/// - Dynamic: Force, Momentum, Energy, Power, Pressure, Torque
/// - And more (see KnownSignatureMap for complete list)
/// </remarks>
public bool IsKnownDimension()
{
    var signature = GetSignature();
    return KnownSignatureMap.Instance.IsKnown(signature);
}
```

#### GetDimensionDescription() Method

**Purpose**: Get human-readable description of the quantity's dimension

**Design Option A (Nullable)**:
```csharp
/// <summary>
/// Gets a human-readable description of this quantity's dimension.
/// Returns null if the dimension is not recognized.
/// </summary>
/// <returns>
/// Description string (e.g., "Force", "Energy", "Pressure") or null if unknown.
/// </returns>
public string? GetDimensionDescription()
{
    var signature = GetSignature();
    if (KnownSignatureMap.Instance.TryGetPreferredUnit(signature, out var preferred))
    {
        return preferred.Description;
    }
    return null;
}
```

**Design Option B (Exception)**:
```csharp
/// <summary>
/// Gets a human-readable description of this quantity's dimension.
/// </summary>
/// <returns>Description string (e.g., "Force", "Energy", "Pressure").</returns>
/// <exception cref="InvalidOperationException">
/// Thrown when the dimension is not recognized in the known signature map.
/// </exception>
public string GetDimensionDescription()
{
    var signature = GetSignature();
    if (KnownSignatureMap.Instance.TryGetPreferredUnit(signature, out var preferred))
    {
        return preferred.Description;
    }
    throw new InvalidOperationException(
        "Cannot get dimension description for unknown dimension. " +
        $"Use IsKnownDimension() to check before calling. Signature: {signature}");
}
```

**Recommendation**: **Option A (Nullable)**
- More flexible; caller decides how to handle unknowns
- Consistent with TryParse patterns elsewhere
- Pair with `IsKnownDimension()` for explicit checks

### Phase 2: Normalization API

#### ToBaseUnits() Method

**Purpose**: Convert quantity to SI base unit representation

**Design**:
```csharp
/// <summary>
/// Converts this quantity to its representation in SI base units.
/// For quantities with composite dimensions, returns the composite base form.
/// </summary>
/// <returns>
/// A new quantity with the same magnitude expressed in SI base units.
/// Base units: m (length), kg (mass), s (time), A (current), K (temperature), 
/// mol (substance), cd (luminous intensity).
/// </returns>
/// <remarks>
/// Examples:
/// - 10 km ‚Üí 10000 m
/// - 5 N ‚Üí 5 kg*m/s^2
/// - 100 psi ‚Üí 689475.7 kg/(m*s^2)
/// </remarks>
public Quantity ToBaseUnits()
{
    var signature = GetSignature();
    
    // Get base value by converting through factor
    var baseValue = Value * Factor;
    
    // Format signature as composite base unit string
    var formatter = CompositeFormatter.Instance;
    var baseUnitString = formatter.Format(signature);
    
    return new Quantity(baseValue, baseUnitString);
}
```

**Considerations**:
- For dimensionless, returns scalar (empty unit string)
- For simple dimensions (Length, Mass), returns canonical SI (m, kg)
- For composites, returns algebraic notation (kg*m/s^2)

#### ToCanonical() Method

**Purpose**: Convert to preferred canonical unit when dimension is known

**Design**:
```csharp
/// <summary>
/// Converts this quantity to its canonical (preferred) unit representation.
/// Uses the known signature map to determine the preferred unit for recognized dimensions.
/// For unknown dimensions, returns the quantity unchanged.
/// </summary>
/// <returns>
/// A new quantity with the same magnitude expressed in the canonical unit.
/// For unknown dimensions, returns a copy of this quantity.
/// </returns>
/// <remarks>
/// Canonical units follow SI-first policy:
/// - Force ‚Üí N (newton)
/// - Energy ‚Üí J (joule) or Nm (newton-meter)
/// - Pressure ‚Üí Pa (pascal)
/// - Torque ‚Üí Nm (newton-meter)
/// - Power ‚Üí W (watt)
/// </remarks>
public Quantity ToCanonical()
{
    var signature = GetSignature();
    
    if (!KnownSignatureMap.Instance.TryGetPreferredUnit(signature, out var preferred))
    {
        // Unknown dimension - return copy unchanged
        return this;
    }
    
    // Convert to preferred unit using existing Format/As logic
    return this.As(preferred.Symbol);
}
```

**Alternative Design (Extension Method)**:
- Could implement as extension in `Extensions.cs`
- **Recommendation**: Keep as instance method for discoverability

### Phase 3: Validation API

#### IsValidUnit() Static Method

**Purpose**: Check if unit string is valid (catalog or composite) without throwing

**Design**:
```csharp
/// <summary>
/// Determines whether the specified unit string is valid (either a catalog unit or a valid composite).
/// This method does not throw exceptions.
/// </summary>
/// <param name="unit">The unit string to validate.</param>
/// <returns>
/// True if the unit is a valid catalog unit or a well-formed composite unit; otherwise, false.
/// Returns false for null, empty, or whitespace strings.
/// </returns>
/// <remarks>
/// Use this method to validate user input before constructing quantities.
/// Performs fast catalog lookup first, then composite parsing if needed.
/// </remarks>
public static bool IsValidUnit(string? unit)
{
    // Null or empty check
    if (string.IsNullOrWhiteSpace(unit))
        return false;
    
    // Fast path: catalog unit
    if (UnitDefinitions.IsValidUnit(unit))
        return true;
    
    // Slow path: try parsing as composite
    var parser = CompositeParser.Instance;
    return parser.TryParse(unit, out _, out _);
}
```

**Use Cases**:
- Input validation in UIs
- Pre-flight checks before parsing
- Configuration validation

### Phase 4: Diagnostics API (Optional)

#### CacheStatistics Class

**Purpose**: Expose performance metrics for caches

**Design**:
```csharp
/// <summary>
/// Provides diagnostic information about internal cache performance.
/// Use these metrics to understand and optimize Tare usage patterns.
/// </summary>
public sealed class CacheStatistics
{
    /// <summary>
    /// Gets the cache hit rate for composite unit parsing (0.0 to 1.0).
    /// Higher is better; > 0.80 indicates effective caching.
    /// </summary>
    public double CompositeParserHitRate { get; }
    
    /// <summary>
    /// Gets the cache hit rate for unit resolution (0.0 to 1.0).
    /// Higher is better; > 0.80 indicates effective caching.
    /// </summary>
    public double UnitResolverHitRate { get; }
    
    /// <summary>
    /// Gets the total number of composite parse operations performed.
    /// </summary>
    public long CompositeParseOperations { get; }
    
    /// <summary>
    /// Gets the total number of unit resolution operations performed.
    /// </summary>
    public long UnitResolveOperations { get; }
    
    internal CacheStatistics(
        double compositeParserHitRate,
        double unitResolverHitRate,
        long compositeParseOperations,
        long unitResolveOperations)
    {
        CompositeParserHitRate = compositeParserHitRate;
        UnitResolverHitRate = unitResolverHitRate;
        CompositeParseOperations = compositeParseOperations;
        UnitResolveOperations = unitResolveOperations;
    }
}

/// <summary>
/// Provides diagnostic access to internal Tare performance metrics.
/// </summary>
public static class QuantityDiagnostics
{
    /// <summary>
    /// Gets current cache statistics for internal operations.
    /// Use these metrics to monitor and optimize performance.
    /// </summary>
    /// <returns>Snapshot of current cache statistics.</returns>
    public static CacheStatistics GetCacheStatistics()
    {
        // Gather stats from internal caches
        var parserStats = CompositeParser.Instance.GetStatistics();
        var resolverStats = UnitResolver.Instance.GetStatistics();
        
        return new CacheStatistics(
            parserStats.HitRate,
            resolverStats.HitRate,
            parserStats.TotalOperations,
            resolverStats.TotalOperations);
    }
}
```

**Considerations**:
- Statistics are snapshot; not real-time
- No reset functionality exposed (internal only)
- Thread-safe reads (caches already use concurrent structures)

**Alternative**: Defer diagnostics entirely
- **Decision needed**: Include in F-013 or defer to F-014+?
- **Recommendation**: Include basic cache stats; defer advanced diagnostics

---

## API Surface Summary

### New Public Types

```csharp
// Make existing internal type public
public readonly struct DimensionSignature : IEquatable<DimensionSignature>
{
    // Existing properties become public
    public sbyte Length { get; }
    public sbyte Mass { get; }
    public sbyte Time { get; }
    public sbyte ElectricCurrent { get; }
    public sbyte Temperature { get; }
    public sbyte AmountOfSubstance { get; }
    public sbyte LuminousIntensity { get; }
    
    // Existing factory properties
    public static DimensionSignature Dimensionless { get; }
    public static DimensionSignature LengthSignature { get; }
    // ... etc
}

// New diagnostics class (optional)
public sealed class CacheStatistics { /* ... */ }
public static class QuantityDiagnostics { /* ... */ }
```

### New Instance Methods on Quantity

```csharp
public readonly struct Quantity
{
    // Introspection
    public DimensionSignature GetSignature();
    public bool IsKnownDimension();
    public string? GetDimensionDescription();
    
    // Normalization
    public Quantity ToBaseUnits();
    public Quantity ToCanonical();
}
```

### New Static Methods on Quantity

```csharp
public readonly struct Quantity
{
    // Validation
    public static bool IsValidUnit(string? unit);
}
```

---

## Out of Scope

- ‚ùå Mutable state or configuration APIs
- ‚ùå Culture-specific formatting (F-016)
- ‚ùå Custom signature map registration (future enhancement)
- ‚ùå Advanced dimension algebra (power, root operations)
- ‚ùå Unit aliases management (covered by existing UnitDefinitions)
- ‚ùå Performance optimization (F-011 already delivered caching)

---

## Dependencies

### Consumes
- **F-011**: Uses existing cache infrastructure (CompositeParser, UnitResolver)
- **F-012**: Follows error handling standards

### Enables
- **F-014**: Documentation can showcase helper methods
- **F-016**: Formatting helpers may build on normalization APIs

---

## Testing Strategy

### Unit Tests

**Target**: All new public helper methods

**Test File**: `tests/QuantityHelperTests.cs`

**Naming Convention**: `MethodName_Condition_ExpectedResult()`

**Coverage Goals**:
- 100% of new public methods
- All return value types tested
- Null/empty/edge cases covered

**Test Categories**:

1. **Introspection Tests**
```csharp
[Fact]
public void GetSignature_CatalogUnit_ReturnsCorrectSignature()
{
    // Arrange
    var force = Quantity.Parse("10 N");
    
    // Act
    var signature = force.GetSignature();
    
    // Assert
    Assert.Equal(1, signature.Length);
    Assert.Equal(1, signature.Mass);
    Assert.Equal(-2, signature.Time);
    Assert.Equal(0, signature.ElectricCurrent);
}

[Fact]
public void IsKnownDimension_Force_ReturnsTrue()
{
    // Arrange
    var force = Quantity.Parse("10 N");
    
    // Act
    var isKnown = force.IsKnownDimension();
    
    // Assert
    Assert.True(isKnown);
}

[Fact]
public void GetDimensionDescription_Energy_ReturnsEnergy()
{
    // Arrange
    var energy = Quantity.Parse("100 J");
    
    // Act
    var description = energy.GetDimensionDescription();
    
    // Assert
    Assert.Equal("Energy", description);
}

[Fact]
public void GetDimensionDescription_UnknownSignature_ReturnsNull()
{
    // Arrange - create quantity with unknown composite signature
    var unknown = Quantity.Parse("10 m^5");
    
    // Act
    var description = unknown.GetDimensionDescription();
    
    // Assert
    Assert.Null(description);
}
```

2. **Normalization Tests**
```csharp
[Fact]
public void ToBaseUnits_Kilometers_ReturnsMeters()
{
    // Arrange
    var distance = Quantity.Parse("5 km");
    
    // Act
    var baseUnits = distance.ToBaseUnits();
    
    // Assert
    Assert.Equal(5000m, baseUnits.Value);
    Assert.Equal("m", baseUnits.Unit);
}

[Fact]
public void ToBaseUnits_Force_ReturnsCompositeBase()
{
    // Arrange
    var force = Quantity.Parse("10 N");
    
    // Act
    var baseUnits = force.ToBaseUnits();
    
    // Assert
    Assert.Equal(10m, baseUnits.Value);
    Assert.Contains("kg", baseUnits.Unit);
    Assert.Contains("m", baseUnits.Unit);
    Assert.Contains("s^-2", baseUnits.Unit);
}

[Fact]
public void ToCanonical_TorqueInLbfIn_ReturnsNm()
{
    // Arrange
    var torque = Quantity.Parse("1500 lbf*in");
    
    // Act
    var canonical = torque.ToCanonical();
    
    // Assert
    Assert.Equal("Nm", canonical.Unit);
    // Value should be correctly converted (approximately 169.5)
    Assert.True(Math.Abs(169.5m - canonical.Value) < 0.1m);
}

[Fact]
public void ToCanonical_UnknownDimension_ReturnsUnchanged()
{
    // Arrange
    var unknown = Quantity.Parse("10 m^5");
    
    // Act
    var canonical = unknown.ToCanonical();
    
    // Assert
    Assert.Equal("m^5", canonical.Unit);
    Assert.Equal(10m, canonical.Value);
}
```

3. **Validation Tests**
```csharp
[Fact]
public void IsValidUnit_CatalogUnit_ReturnsTrue()
{
    // Act & Assert
    Assert.True(Quantity.IsValidUnit("m"));
    Assert.True(Quantity.IsValidUnit("kg"));
    Assert.True(Quantity.IsValidUnit("N"));
}

[Fact]
public void IsValidUnit_CompositeUnit_ReturnsTrue()
{
    // Act & Assert
    Assert.True(Quantity.IsValidUnit("Nm"));
    Assert.True(Quantity.IsValidUnit("m/s"));
    Assert.True(Quantity.IsValidUnit("kg*m^2/s^2"));
}

[Fact]
public void IsValidUnit_InvalidUnit_ReturnsFalse()
{
    // Act & Assert
    Assert.False(Quantity.IsValidUnit("xyz"));
    Assert.False(Quantity.IsValidUnit("invalid"));
    Assert.False(Quantity.IsValidUnit("m/"));
}

[Fact]
public void IsValidUnit_NullOrEmpty_ReturnsFalse()
{
    // Act & Assert
    Assert.False(Quantity.IsValidUnit(null));
    Assert.False(Quantity.IsValidUnit(""));
    Assert.False(Quantity.IsValidUnit("   "));
}
```

4. **Diagnostics Tests** (if included)
```csharp
[Fact]
public void GetCacheStatistics_ReturnsValidData()
{
    // Act
    var stats = QuantityDiagnostics.GetCacheStatistics();
    
    // Assert
    Assert.NotNull(stats);
    Assert.InRange(stats.CompositeParserHitRate, 0.0, 1.0);
    Assert.InRange(stats.UnitResolverHitRate, 0.0, 1.0);
    Assert.True(stats.CompositeParseOperations >= 0);
    Assert.True(stats.UnitResolveOperations >= 0);
}
```

### Integration Tests

**Target**: End-to-end helper scenarios

**Examples**:
- Use introspection to validate dimensions before operations
- Use normalization in data standardization workflow
- Use diagnostics to optimize hot paths

---

## Breaking Changes

‚úÖ **NONE** - This feature is 100% backwards compatible

**Why No Breaking Changes**:
1. All APIs are additive (new methods only)
2. Existing public surface unchanged
3. Making `DimensionSignature` public is additive (was internal)
4. No changes to existing method signatures or behavior

**Migration Guide**: Not needed (backwards compatible)

---

## Documentation Updates

### XML Comments

All new public APIs must have comprehensive XML documentation:

```csharp
/// <summary>
/// Gets the dimension signature of this quantity.
/// </summary>
/// <returns>The dimension signature representing dimensional composition.</returns>
/// <remarks>
/// The signature uses integer exponents over seven SI base dimensions.
/// Examples: Force (L¬πM¬πT‚Åª¬≤), Energy (L¬≤M¬πT‚Åª¬≤), Pressure (L‚Åª¬πM¬πT‚Åª¬≤).
/// </remarks>
public DimensionSignature GetSignature() { /* ... */ }
```

### CHANGELOG.md

Add entry:
```markdown
## [version] - [date]

### Added
- Added `GetSignature()` method to inspect dimension composition (F-013)
- Added `IsKnownDimension()` method to check if dimension is recognized (F-013)
- Added `GetDimensionDescription()` method for human-readable dimension names (F-013)
- Added `ToBaseUnits()` method to convert to SI base representation (F-013)
- Added `ToCanonical()` method to convert to preferred canonical units (F-013)
- Added `IsValidUnit()` static method for input validation (F-013)
- Added `DimensionSignature` as public type for advanced scenarios (F-013)
- (Optional) Added `QuantityDiagnostics` class for cache performance metrics (F-013)

### Improved
- Enhanced developer experience with introspection and normalization helpers (F-013)
```

### README.md

Add section:
```markdown
## Helper Methods

### Introspection

Check dimension information at runtime:

```csharp
var force = Quantity.Parse("10 N");

// Get dimension signature
var signature = force.GetSignature();
Console.WriteLine($"Force: L^{signature.Length} M^{signature.Mass} T^{signature.Time}");
// Output: "Force: L^1 M^1 T^-2"

// Check if dimension is known
if (force.IsKnownDimension())
{
    var description = force.GetDimensionDescription();
    Console.WriteLine($"Dimension: {description}");
    // Output: "Dimension: Force"
}
```

### Normalization

Convert to standard representations:

```csharp
var pressure = Quantity.Parse("14.7 psi");

// Convert to SI base units
var baseUnits = pressure.ToBaseUnits();
Console.WriteLine(baseUnits);  // "689475.7 kg/(m*s^2)"

// Convert to canonical (preferred) unit
var canonical = pressure.ToCanonical();
Console.WriteLine(canonical);  // "101352.9 Pa"
```

### Validation

Validate unit strings before parsing:

```csharp
string userInput = GetUserInput();

if (Quantity.IsValidUnit(userInput))
{
    var q = Quantity.Parse($"10 {userInput}");
    // ... use quantity
}
else
{
    Console.WriteLine($"Invalid unit: {userInput}");
}
```
```

---

## Files to Modify

### Core Implementation
- `src/Quantity.cs` (add helper methods region, ~150 LOC)
- `src/Internal/Units/DimensionSignature.cs` (change `internal` to `public`, add XML docs)
- `src/Internal/Units/CompositeParser.cs` (add statistics methods if diagnostics included)
- `src/Internal/Units/UnitResolver.cs` (add statistics methods if diagnostics included)

### Diagnostics (Optional)
- `src/Diagnostics/CacheStatistics.cs` (new file, ~60 LOC)
- `src/Diagnostics/QuantityDiagnostics.cs` (new file, ~40 LOC)

### Tests
- `tests/QuantityHelperTests.cs` (new file, comprehensive tests, ~500-600 LOC)
- `tests/DimensionSignatureTests.cs` (enhance existing if needed)

### Documentation
- `README.md` (add Helper Methods section)
- `docs/CHANGELOG.md` (add F-013 entry)
- XML comments on all new public APIs

---

## Quality Gates

### Before Committing
- [ ] All tests pass (including new helper tests)
- [ ] `DimensionSignature` made public with complete XML docs
- [ ] All new methods have comprehensive XML documentation
- [ ] All helper methods tested using `MethodName_Condition_ExpectedResult()` pattern
- [ ] Zero breaking changes validated

### Before PR Merge
- [ ] Code review passed
- [ ] CHANGELOG.md updated
- [ ] README.md updated with examples
- [ ] Build succeeds with zero warnings
- [ ] Test coverage > 95% for new APIs

---

## Quality Checklist

### Domain Design Validation
- ‚úÖ I have verified that helpers preserve value object immutability
- ‚úÖ I have confirmed consistent terminology (Signature, Canonical, Base, Known)
- ‚úÖ I have verified SOLID principles, especially SRP and OCP
- ‚úÖ I have validated that helpers delegate to existing domain services

### Implementation Quality Validation
- ‚úÖ I have written comprehensive tests using `MethodName_Condition_ExpectedResult()` naming
- ‚úÖ I have considered performance (helpers should not impact hot paths)
- ‚úÖ I have implemented null checks where appropriate (IsValidUnit)
- ‚úÖ I have documented all public APIs with XML comments

### API Design Validation
- ‚úÖ I have verified naming follows .NET conventions
- ‚úÖ I have ensured all methods are focused and single-purpose
- ‚úÖ I have validated that APIs are additive (zero breaking changes)
- ‚úÖ I have tested all methods with catalog and composite units

---

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| Making `DimensionSignature` public expands API surface | Medium | Low | Struct is well-designed; already tested internally |
| Performance impact of helper methods | Low | Low | Helpers delegate to cached operations; benchmarks validate |
| User confusion about when to use helpers | Medium | Low | Clear documentation with examples; optional usage |
| Diagnostics API misuse or misinterpretation | Low | Low | Clear documentation; read-only access only |

---

## Timeline

**Estimated Effort**: 2‚Äì3 days

**Breakdown**:
- Day 1 AM: Design decisions (nullable vs exception, diagnostics scope)
- Day 1 PM: Implement introspection helpers (GetSignature, IsKnownDimension, GetDimensionDescription)
- Day 2 AM: Implement normalization helpers (ToBaseUnits, ToCanonical)
- Day 2 PM: Implement validation helper (IsValidUnit), write tests
- Day 3 AM: (Optional) Implement diagnostics API
- Day 3 PM: Documentation, final verification, PR prep

---

## Success Metrics

### Objective Measures
- ‚úÖ All tests pass (100% for new APIs)
- ‚úÖ Zero breaking changes (verified by existing tests)
- ‚úÖ All public APIs have XML documentation
- ‚úÖ README examples compile and run correctly

### Subjective Measures
- ‚úÖ Helper methods reviewed and deemed useful by team
- ‚úÖ API design reviewed and deemed intuitive
- ‚úÖ Documentation reviewed and deemed comprehensive

---

## References

### Internal
- **E-001**: Epic defining F-013 scope and dependencies
- **F-011**: Performance & Caching (provides cache infrastructure)
- **F-012**: Error Handling (provides standards for consistency)
- **F-014**: Documentation (will showcase helper methods)

### External
- **.NET Design Guidelines**: https://learn.microsoft.com/en-us/dotnet/standard/design-guidelines/
- **API Design Best Practices**: Clear, consistent, minimal surface area
- **Value Object Pattern**: Immutability and query methods

---

## Open Questions

### Q1: Should GetDimensionDescription() return nullable or throw?

**Context**: Unknown dimensions exist (e.g., m^5). How should API behave?

**Options**:
- **A**: Return `string?` (nullable) - returns null for unknown
- **B**: Throw `InvalidOperationException` for unknown

**Decision**: **Option A (Nullable)**. Rationale:
- More flexible for callers
- Consistent with Try* patterns
- Pair with `IsKnownDimension()` for explicit checks
- No performance penalty

### Q2: Should we include diagnostics API in F-013?

**Context**: Cache statistics are useful but may be niche use case.

**Options**:
- **A**: Include basic `QuantityDiagnostics` with cache stats
- **B**: Defer all diagnostics to user demand / future feature

**Decision**: **Option A (Include basic diagnostics)**. Rationale:
- Minimal implementation cost (~2-3 hours)
- Enables performance optimization scenarios
- Follows through on F-011/F-012 diagnostics discussion
- Can always expand later if demand exists

### Q3: Should ToBaseUnits() return composite string or formatted string?

**Context**: Base units for Force could be "kg*m/s^2" or formatted with special chars.

**Options**:
- **A**: Use `CompositeFormatter` as-is (ASCII-safe: "kg*m/s^2")
- **B**: Add optional pretty-print (Unicode: "kg¬∑m¬∑s‚Åª¬≤")

**Decision**: **Option A (ASCII-safe)**. Rationale:
- Consistent with existing composite formatting
- Works in all environments (console, logs, files)
- Pretty-print can be added in F-016 (formatting feature)
- Keeps F-013 focused

---

## Decisions Recorded

1. **DimensionSignature Visibility** (2025-11-12): Make `DimensionSignature` public readonly struct. Well-designed, tested, enables advanced scenarios. No breaking changes (additive).

2. **Nullable Description** (2025-11-12): `GetDimensionDescription()` returns `string?` (nullable). More flexible; consistent with query semantics.

3. **Diagnostics Inclusion** (2025-11-12): Include basic `QuantityDiagnostics` with cache statistics. Minimal cost; high value for optimization scenarios.

4. **ToBaseUnits Format** (2025-11-12): Use existing ASCII-safe composite formatting. Defer pretty-print to F-016.

5. **Helper Location** (2025-11-12): Implement helpers as instance methods on `Quantity` (not extensions). Better discoverability; consistent with value object pattern.
