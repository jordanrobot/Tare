# S-002: Greenfield dimensional units system (Unconstrained options spike)

This document explores design options for a dimensional analysis and cross-unit arithmetic system without constraints from the existing Tare API or internals. The aim is to evaluate approaches that maximize correctness, ergonomics, and performance for unit-safe computations.

Example scenarios to support:

- 6 in × 10 lbf → 60 lbf·in (torque/energy unit)
- 48 in*in ÷ 4 in → 12 in (length)
- 48 in ÷ 1 in → 48 (unit cancellation to scalar)
- 100 Nm → ~885.0 lbf·in (cross-unit conversion)
- 0.5 m × 20 N → 10 Nm (SI checks)
- 2 inch × 3 pound force → 6 lbf·in (alias handling)
- 144 in^3 / 12 in → 12 in^2 (area from volume/length)

## Goals

- Dimensionally correct arithmetic across multiplication/division with automatic simplification/cancellation.
- Deterministic naming/formatting of derived units with conversions to equivalent units (e.g., lbf·in ↔ Nm).
- Clear error modes for incompatible operations (e.g., addition across non-like dimensions).
- High precision arithmetic; avoid floating drift in conversion chains.
- Developer ergonomics: intuitive API and discoverable operations.
- Users can extend the unit catalog with custom derived units.
- End users can perform common engineering calculations safely and easily.
- End users can parse and format composite units naturally at runtime. E.g. the user can create a representation of "12 in" easily, or the end user of the software can enter different values and have them computed at runtime. 

## Non-goals

- Backward compatibility with existing Tare types (this is a greenfield evaluation).
- Maintaining the current `UnitDefinitions` shape or `UnitTypeEnum` semantics.
- Targeting legacy TFMs unless explicitly chosen for desired reach; TFMs and dependencies are open for discussion.

## Success criteria

- Type- or runtime-guaranteed dimensional correctness for `*` and `/`.
- Unit cancellation: area ÷ length → length; unit ÷ unit → scalar.
- Conversion correctness across SI and Imperial with rational/decimal factors.
- Usable formatting and parsing of composites (e.g., `lbf*in`, `N*m`, canonical forms) at runtime for end users.
- Extensible unit catalog (via configuration/DSL or runtime registration) without recompilation.
- Test suite covering showcased scenarios and edge cases.

---

## Option 1 — Compile-time dimensions with generic type parameters

Concept
- Represent dimensions at the type level, e.g., `Quantity<Dim<L1, M0, T-2>>`.
- Each fundamental dimension (Length L, Mass M, Time T, …) has an integer exponent encoded as a type (e.g., `P1`, `Z0`, `N2`).
- Operators `*` and `/` are implemented with generic metaprogramming to produce new types with combined exponents.

API sketch
- `readonly struct Quantity<TDim>(decimal value, Unit unit)` where `TDim : IDimension`.
- Multiplication: `Quantity<DL,MM,TT> * Quantity<DL2,MM2,TT2> => Quantity<Add<DL,DL2>, Add<MM,MM2>, Add<TT,TT2>>` via static abstract generics or source-gen.
- Named unit types as marker types (e.g., `NewtonMeter` maps to `Dim<L2, M1, T-2>`).

Pros
- Strong compile-time guarantees; impossible to multiply incompatible types without correct resulting type.
- No runtime overhead for dimensional checks when fully resolved at compile time.
- IDE discoverability via types; safer refactors.

Cons / Risks
- C# lacks type-level integers; encoding exponents requires marker types and boilerplate or source generators.
- Complexity of operator type arithmetic; may require Roslyn source generators to remain ergonomic.
- Exploding generic combinations; API can be intimidating to consumers if not encapsulated.

Extensibility and runtime parsing
- End-user runtime parsing of arbitrary composite strings (e.g., "lbf*in") into compile-time types is non-trivial; typically requires a dynamic facade or pairing with a generator (Option 2).
- Custom unit addition by users usually requires code generation or recompilation.

Feasibility notes
- Modern C# (static abstract members in interfaces) and source generators can make this viable.
- Alternative: use F# Units of Measure and expose to C# (see Option 6).

---

## Option 2 — Source-generated units and operators from a DSL/catalog

Concept
- Define units and fundamental dimensions in a declarative schema or DSL.
- A Roslyn source generator emits strongly-typed unit structs, conversions, and operator overloads (including derived units) at build time.

API sketch
- Users author a `units.json`/`units.yml`/`.uom` file declaring units, factors, dimensions, and aliases.
- Generated code provides `Length`, `Force`, `Energy` types and derived composites with safe operators.

Pros
- Compile-time validation and rich IntelliSense without manual boilerplate.
- Flexible: extend catalog by updating the DSL; generator regenerates safe APIs.
- Can generate both friendly named composites (e.g., `Torque`) and canonical fallbacks.

Cons / Risks
- Requires generator infrastructure and build integration.
- Generated surface area can be large; versioning and binary compatibility must be managed.
- Cross-language usage depends on generated API design.

Feasibility notes
- Pairs well with Option 1 (generator emits the generic-dimension layer and friendly facades).

Extensibility and runtime parsing
- End users can extend the unit catalog by editing the DSL and regenerating; hot-reload at runtime is possible with a runtime parser bound to the generated catalog.
- Provide a parser/formatter over the generated catalog to handle inputs like "2 inch" or "lbf*in" at runtime.

---

## Option 3 — Runtime dimension vectors with canonicalization

Concept
- Represent dimensions at runtime as small fixed vectors of integer exponents over base dimensions (e.g., `[L, M, T, I, Θ, N, J]`).
- `Quantity` carries `(decimal value, Unit unit, DimensionVector dims, Rational factorToSI)`.
- Operators `*` and `/` add/subtract exponent vectors; units simplify by canonicalization rules.

API sketch
- `readonly struct Quantity(decimal value, Unit unit, Dimension dims)`.
- `Unit` encodes conversion factor to a canonical basis (e.g., SI), stored as rational for exactness.
- Formatting chooses a preferred unit for the resulting `Dimension` via a map (e.g., Energy → `Nm`).

Pros
- General solution; easy to extend dimensions and unit catalogs.
- Natural unit cancellation emerges from exponent algebra.
- Maintains a simple single generic/non-generic `Quantity` for users.

Extensibility and runtime parsing
- Supports user-defined units and aliases at runtime via a pluggable catalog.
- Natural fit for a runtime parser to accept composite expressions (e.g., "N*m", "lbf*in") and produce quantities.

Cons / Risks
- Runtime checks (slight overhead vs compile-time guarantees).
- Requires careful design of naming policy and canonicalization to avoid surprising unit strings.
- Potential allocations if not carefully optimized (cache maps, structs preferred).

Feasibility notes
- Pragmatic and performant if implemented with readonly structs, pooled maps, and precomputed conversions.

---

## Option 4 — Symbolic algebra with rational factors and prime unit bases

Concept
- Treat units as symbolic expressions with rational coefficients (e.g., `lbf*in`, `m^2/s^2`).
- Normalize to a prime unit basis (SI preferred) and maintain exact rational factors to eliminate drift.
- Simplify expressions with rewrite rules and canonical ordering.

API sketch
- `UnitExpr` as an immutable symbolic tree with exponent integers and rational coefficient.
- `Quantity` holds `(decimal value) × UnitExpr`; operators compose/simplify `UnitExpr` and rescale value.

Pros
- Very robust algebra; supports advanced composite units and human-readable formatting.
- Exact rational math avoids cumulative conversion error.

Extensibility and runtime parsing
- Pairs well with a grammar-based parser for end-user input and custom units; rewrite rules can incorporate user-registered symbols.

Cons / Risks
- More complex implementation and formatting policy decisions.
- Performance considerations for symbolic manipulation (can be mitigated with caching and normalization).

Feasibility notes
- Can be layered beneath Option 3’s vector model as the presentation/normalization engine.

---

## Option 5 — Adopt a mature external library (e.g., UnitsNet)

Concept
- Leverage an established units/dimensions library with a comprehensive catalog, conversions, and operators.

Pros
- Feature-rich, well-tested, broad unit coverage.
- Reduced maintenance burden; community contributions.

Cons / Risks
- Third-party dependency and its versioning/licensing.
- API surface dictated by the library; less control over ergonomics and naming.
- Potential mismatch with desired decimal precision or formatting conventions.

Feasibility notes
- Fastest path to capability; can wrap the library with a thin facade to enforce local conventions.

---

## Option 6 — F# Units of Measure (UoM) with C# interop

Concept
- Implement domain logic in F# using built-in Units of Measure (compile-time dimensional safety).
- Expose needed API to C# via .NET interop.

Pros
- Best-in-class compile-time dimensional safety with minimal boilerplate.
- Very concise unit declarations and derived units in F#.

Cons / Risks
- Mixed-language solution; contributor ramp-up and tooling considerations.
- Interop constraints may limit some ergonomics for C# consumers.

Feasibility notes
- Viable for greenfield services/components where F# is acceptable.

Extensibility and runtime parsing
- Runtime parsing for end-user inputs is straightforward, but mapping arbitrary parsed expressions to statically typed F# UoM values in C# is constrained; may require dynamic bridges or a dual-API (typed + untyped quantities).

---

## Option 7 — Service-oriented dimensional engine (out-of-process)

Concept
- Provide dimensional computations as a service (local or remote), with a simple client SDK.

Pros
- Centralizes catalog/versioning and heavy computations; polyglot consumers can reuse.
- Allows specialized engines/languages without constraining client tech stack.

Cons / Risks
- Network/process boundary overhead; availability considerations.
- Added operational complexity; overkill for library scenarios.

Feasibility notes
- Useful if multiple apps/teams need a single source of truth for units.

Extensibility and runtime parsing
- Central catalog can be updated without client redeployments; service parser/formatter handles end-user composite inputs and returns normalized quantities.

---

## Cross-cutting considerations

- Precision: prefer `decimal` for values and `BigRational`/rational for unit factors to prevent drift.
- Catalog: SI-first canonicalization; aliases and pluralization handled at parse/format boundaries.
- Formatting and parsing: consistent symbols (e.g., `N*m` vs `Nm`), middle dot vs `*`, exponent formatting (`^` vs superscript); configurable policy. Provide a runtime grammar for composite units and robust error messages for invalid input.
- Performance: readonly structs for quantities and units; cache dimension vectors; avoid boxing; SIMD not applicable but consider span-based parsers.
- Extensibility: pluggable unit catalogs and naming preferences.
- Error modes: clear exceptions for incompatible add/sub; safe-guards for divide-by-zero and unknown units.

## Minimal test matrix (illustrative)

- Multiply: `6 in * 10 lbf = 60 lbf*in`; equals `~6.779 Nm`.
- Divide (compose then reduce): `48 in*in / 4 in = 12 in`.
- Unit cancellation to scalar: `48 in / 1 in = 48`.
- SI checks: `0.5 m * 20 N = 10 N*m`; convertible to `~88.50 lbf*in`.
- Mixed aliases: `2 inch * 3 pound force` → `6 lbf*in`.
- Negative/zero values and divide-by-zero edge cases.
 - Cross-unit conversion: `100 N*m` ↔ `~885.0 lbf*in` (value equivalence within tolerance).
 - Volume/length to area: `144 in^3 / 12 in = 12 in^2`.

## Recommendations

- If prioritizing maximal safety and are open to advanced tooling: pursue Option 1 + Option 2 (generic dimensions with source generation) for compile-time dimensional correctness and ergonomic APIs.
- If prioritizing pragmatic delivery and broad flexibility: pursue Option 3 with elements of Option 4 for robust runtime algebra and friendly naming.
- If time-to-capability dominates and dependency is acceptable: evaluate Option 5 (UnitsNet) with a small adapter layer for decimal precision and formatting policy.

## Next steps

- Choose a preferred track (Compile-time vs Runtime vs External) for a spike.
- Define base dimensions (L, M, T [and optionally I, Θ, N, J]) and a minimal derived set (Force, Energy, Pressure, Velocity, Acceleration).
- Decide on canonical naming policy (SI-first; middle dot vs `*`; exponent style).
- Implement a small POC and the test matrix above; measure performance and developer ergonomics.
